typedef unsigned char   undefined;

typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef unsigned long long    GUID;
typedef pointer32 ImageBaseOffset32;

typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    wchar16;
typedef short    wchar_t;
typedef unsigned short    word;
typedef struct CLIENT_ID CLIENT_ID, *PCLIENT_ID;

struct CLIENT_ID {
    void *UniqueProcess;
    void *UniqueThread;
};

typedef struct _cpinfo _cpinfo, *P_cpinfo;

typedef uint UINT;

typedef uchar BYTE;

struct _cpinfo {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
};

typedef struct _cpinfo *LPCPINFO;

typedef struct _OVERLAPPED _OVERLAPPED, *P_OVERLAPPED;

typedef ulong ULONG_PTR;

typedef union _union_518 _union_518, *P_union_518;

typedef void *HANDLE;

typedef struct _struct_519 _struct_519, *P_struct_519;

typedef void *PVOID;

typedef ulong DWORD;

struct _struct_519 {
    DWORD Offset;
    DWORD OffsetHigh;
};

union _union_518 {
    struct _struct_519 s;
    PVOID Pointer;
};

struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union _union_518 u;
    HANDLE hEvent;
};

typedef struct _SYSTEMTIME _SYSTEMTIME, *P_SYSTEMTIME;

typedef ushort WORD;

struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
};

typedef struct _TIME_ZONE_INFORMATION _TIME_ZONE_INFORMATION, *P_TIME_ZONE_INFORMATION;

typedef long LONG;

typedef wchar_t WCHAR;

typedef struct _SYSTEMTIME SYSTEMTIME;

struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[32];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[32];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;

typedef void *LPVOID;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};

typedef struct _STARTUPINFOA _STARTUPINFOA, *P_STARTUPINFOA;

typedef char CHAR;

typedef CHAR *LPSTR;

typedef BYTE *LPBYTE;

struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef DWORD (*PTHREAD_START_ROUTINE)(LPVOID);

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

typedef LONG (*PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS *);

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef CONTEXT *PCONTEXT;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
};

struct _CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
};

struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
};

struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
};

typedef struct _TIME_ZONE_INFORMATION *LPTIME_ZONE_INFORMATION;

typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef struct _OVERLAPPED *LPOVERLAPPED;

typedef struct _STARTUPINFOA *LPSTARTUPINFOA;

typedef struct _RTL_CRITICAL_SECTION _RTL_CRITICAL_SECTION, *P_RTL_CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTION;

typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG _RTL_CRITICAL_SECTION_DEBUG, *P_RTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION_DEBUG *PRTL_CRITICAL_SECTION_DEBUG;

typedef struct _LIST_ENTRY _LIST_ENTRY, *P_LIST_ENTRY;

typedef struct _LIST_ENTRY LIST_ENTRY;

struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY *Flink;
    struct _LIST_ENTRY *Blink;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD;
};

typedef struct _SYSTEMTIME *LPSYSTEMTIME;

typedef struct _MEMORY_BASIC_INFORMATION _MEMORY_BASIC_INFORMATION, *P_MEMORY_BASIC_INFORMATION;

typedef ULONG_PTR SIZE_T;

struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
};

typedef WCHAR *LPWSTR;

typedef WCHAR *PCNZWCH;

typedef WCHAR *LPWCH;

typedef WCHAR *LPCWSTR;

typedef CHAR *LPCSTR;

typedef struct _MEMORY_BASIC_INFORMATION *PMEMORY_BASIC_INFORMATION;

typedef LONG *PLONG;

typedef CHAR *LPCH;

typedef struct _OSVERSIONINFOA _OSVERSIONINFOA, *P_OSVERSIONINFOA;

struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[128];
};

typedef struct _OSVERSIONINFOA *LPOSVERSIONINFOA;

typedef DWORD LCID;

typedef CHAR *PCNZCH;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef DWORD *LPDWORD;

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

typedef struct HINSTANCE__ *HINSTANCE;

struct HINSTANCE__ {
    int unused;
};

typedef struct HWND__ HWND__, *PHWND__;

typedef struct HWND__ *HWND;

struct HWND__ {
    int unused;
};

typedef HINSTANCE HMODULE;

typedef int (*FARPROC)(void);

typedef WORD *LPWORD;

typedef int INT;

typedef BOOL *LPBOOL;

typedef void *LPCVOID;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct IMAGE_DIRECTORY_ENTRY_EXPORT IMAGE_DIRECTORY_ENTRY_EXPORT, *PIMAGE_DIRECTORY_ENTRY_EXPORT;

struct IMAGE_DIRECTORY_ENTRY_EXPORT {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    ImageBaseOffset32 Name;
    dword Base;
    dword NumberOfFunctions;
    dword NumberOfNames;
    ImageBaseOffset32 AddressOfFunctions;
    ImageBaseOffset32 AddressOfNames;
    ImageBaseOffset32 AddressOfNameOrdinals;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
};

typedef struct _iobuf FILE;

typedef uint size_t;

typedef int errno_t;

typedef ulonglong uint64_t;

typedef uint uint32_t;

typedef ushort uint16_t;

typedef uchar uint8_t;

typedef int int32_t;




// Setting prototype: uLong zlib_adler32(uLong adler, const Bytef *buf, uInt len)

uint32_t zlib_adler32(uint32_t adler,byte *buf,uint32_t len)

{
  uint k;
  uint s1;
  int iVar1;
  int sum1;
  int iVar2;
  int sum2;
  int iVar3;
  int sum3;
  int iVar4;
  int sum4;
  int iVar5;
  int sum5;
  int iVar6;
  int sum6;
  int iVar7;
  int sum7;
  int iVar8;
  uint uVar9;
  byte *pbVar10;
  uint s2;
  
                    // /*
                    //  * Adler-32 checksum algorithm.
                    //  * This function computes the Adler-32 checksum of a data buffer.
                    //  *
                    //  * @param adler The initial Adler-32 value. This should be 1 for the first
                    // call.
                    //  * @param buf A pointer to the data buffer.
                    //  * @param len The length of the data buffer in bytes.
                    //  * @return The updated Adler-32 checksum.
                    //  */
  s1 = adler & 0xffff;
  s2 = adler >> 0x10;
  if (buf == (byte *)0x0) {
    return 1;
  }
  if (len != 0) {
    do {
      k = len;
      if (0x15af < len) {
        k = 0x15b0;
      }
      len = len - k;
      if (0xf < (int)k) {
        uVar9 = k >> 4;
        k = k + uVar9 * -0x10;
        pbVar10 = buf;
        do {
          buf = pbVar10 + 0x10;
          iVar1 = s1 + *pbVar10;
          sum1 = iVar1 + (uint)pbVar10[1];
          iVar2 = sum1 + (uint)pbVar10[2];
          sum2 = iVar2 + (uint)pbVar10[3];
          iVar3 = sum2 + (uint)pbVar10[4];
          sum3 = iVar3 + (uint)pbVar10[5];
          iVar4 = sum3 + (uint)pbVar10[6];
          sum4 = iVar4 + (uint)pbVar10[7];
          iVar5 = sum4 + (uint)pbVar10[8];
          sum5 = iVar5 + (uint)pbVar10[9];
          iVar6 = sum5 + (uint)pbVar10[10];
          sum6 = iVar6 + (uint)pbVar10[0xb];
          iVar7 = sum6 + (uint)pbVar10[0xc];
          sum7 = iVar7 + (uint)pbVar10[0xd];
          iVar8 = sum7 + (uint)pbVar10[0xe];
          s1 = iVar8 + (uint)pbVar10[0xf];
          s2 = s2 + iVar1 + sum1 + iVar2 + sum2 + iVar3 + sum3 + iVar4 + sum4 + iVar5 + sum5 + iVar6
               + sum6 + iVar7 + sum7 + iVar8 + s1;
          uVar9 = uVar9 - 1;
          pbVar10 = buf;
        } while (uVar9 != 0);
      }
      for (; k != 0; k = k - 1) {
        s1 = s1 + *buf;
        buf = buf + 1;
        s2 = s2 + s1;
      }
      s1 = s1 % 0xfff1;
      s2 = s2 % 0xfff1;
    } while (len != 0);
  }
  return s2 << 0x10 | s1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void send_broadcast_message(void)

void send_broadcast_message(void)

{
  int sock;
  uint16_t local_res4;
  void *message;
  undefined4 local_24;
  undefined2 sock_addr;
  uint16_t sock_addr_port;
  uint32_t sock_addr_addr;
  undefined2 local_10;
  uint16_t broadcast_addr_port;
  uint32_t broadcast_addr_addr;
  
                    // This function sends a UDP broadcast message, likely for server discovery or
                    // as a keep-alive signal.
  local_24 = 1;
                    // Create a UDP socket.
  sock = socket(2,2,0);
                    // Set the socket to allow broadcast messages.
  setsockopt(sock,0xffff,0x20,&local_24,4);
  sock_addr = 2;
  sock_addr_addr = htonl(0);
  sock_addr_port = htons(0);
                    // Bind the socket to any address and port 0.
  bind(sock,&sock_addr,0x10);
  local_10 = 2;
  broadcast_addr_addr = htonl(0xffffffff);
  broadcast_addr_port = htons(local_res4);
                    // Send a broadcast message to the specified port.
  sendto(sock,message,0x6a,0,&local_10,0x10);
                    // Close the socket.
  closesocket(sock);
                    // Log that a broadcast message was sent.
  logMessage(net_broadcast_source_file,0x14f,net_broadcast_sending_msg,1);
  return;
}



// Setting prototype: unsigned long crc32(unsigned long crc, const unsigned char *buf, unsigned int
// len)

uint32_t zlib_crc32(uint32_t crc,byte *buf,uint32_t len)

{
  uint crc_val;
  uint uVar1;
  
                    // Bytef is a typedef for unsigned char
  if (buf == (byte *)0x0) {
    return 0;
  }
  crc_val = ~crc;
  if (7 < len) {
    uVar1 = len >> 3;
    do {
      len = len - 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)*buf) * 4) ^ crc_val >> 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[1]) * 4) ^ crc_val >> 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[2]) * 4) ^ crc_val >> 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[3]) * 4) ^ crc_val >> 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[4]) * 4) ^ crc_val >> 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[5]) * 4) ^ crc_val >> 8;
      crc_val = *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[6]) * 4) ^ crc_val >> 8;
      crc_val = crc_val >> 8 ^ *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)buf[7]) * 4);
      buf = buf + 8;
      uVar1 = uVar1 - 1;
    } while (uVar1 != 0);
  }
  for (; len != 0; len = len - 1) {
    crc_val = crc_val >> 8 ^ *(uint *)(&zlib_crc32_table + (crc_val & 0xff ^ (uint)*buf) * 4);
    buf = buf + 1;
  }
  return ~crc_val;
}



// Setting prototype: int deflateInit2_(void *strm, int level, int method, int windowBits, int
// memLevel, int strategy, char *version, int stream_size)

int zlib_deflateInit2_(void *strm,int level,int method,int windowBits,int memLevel,int strategy,
                      char *version,int stream_size)

{
  undefined4 *s;
  undefined4 uVar1;
  int result;
  int iVar2;
  bool noheader;
  uint hash_size;
  
                    // strm is a pointer to a z_stream structure.
  if (((version == (char *)0x0) || (*version != *zlib_version_string)) || (stream_size != 0x38)) {
    return -6;
  }
  if (strm != (void *)0x0) {
    *(undefined4 *)((int)strm + 0x18) = 0;
    if (*(int *)((int)strm + 0x20) == 0) {
      *(code **)((int)strm + 0x20) = zlib_zcalloc;
      *(undefined4 *)((int)strm + 0x28) = 0;
    }
    if (*(int *)((int)strm + 0x24) == 0) {
      *(undefined1 **)((int)strm + 0x24) = &LAB_10009300;
    }
    if (level == -1) {
      level = 6;
    }
    noheader = windowBits < 0;
    if (noheader) {
      windowBits = -windowBits;
    }
    if (((((0 < memLevel) && (memLevel < 10)) &&
         ((method == 8 && ((7 < windowBits && (windowBits < 0x10)))))) && (-1 < level)) &&
       (((level < 10 && (-1 < strategy)) && (strategy < 3)))) {
      s = (undefined4 *)(**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),1,0x16b8);
      if (s == (undefined4 *)0x0) {
        return -4;
      }
      *(undefined4 **)((int)strm + 0x1c) = s;
      s[6] = (uint)noheader;
      iVar2 = 1 << ((byte)windowBits & 0x1f);
      s[10] = windowBits;
      *s = strm;
      s[0x12] = memLevel + 7;
      s[9] = iVar2;
      s[0xb] = iVar2 + -1;
      result = 1 << ((byte)(memLevel + 7) & 0x1f);
      s[0x11] = result;
      s[0x13] = result + -1;
      s[0x14] = (memLevel + 9U) / 3;
      uVar1 = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),iVar2,2);
      s[0xc] = uVar1;
      uVar1 = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),s[9],2);
      s[0xe] = uVar1;
      uVar1 = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),s[0x11],2);
      s[0xf] = uVar1;
      result = 1 << ((char)memLevel + 6U & 0x1f);
      s[0x5a5] = result;
      result = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),result,4);
      hash_size = s[0x5a5];
      s[2] = result;
      s[3] = hash_size * 4;
      if (((s[0xc] != 0) && (s[0xe] != 0)) && ((s[0xf] != 0 && (result != 0)))) {
        *(undefined1 *)((int)s + 0x1d) = 8;
        s[0x5a7] = result + (hash_size & 0xfffffffe);
        s[0x5a4] = result + hash_size * 3;
        s[0x20] = strategy;
        s[0x1f] = level;
        result = zlib_deflateReset(strm);
        return result;
      }
      *(undefined **)((int)strm + 0x18) = zlib_insufficient_memory_msg;
      zlib_deflateEnd(strm);
      return -4;
    }
  }
  return -2;
}



// Setting prototype: int deflateReset(void *strm)

int zlib_deflateReset(void *strm)

{
  void *s;
  
                    // strm is a pointer to a z_stream structure.
  if ((((strm != (void *)0x0) && (s = *(void **)((int)strm + 0x1c), s != (void *)0x0)) &&
      (*(int *)((int)strm + 0x20) != 0)) && (*(int *)((int)strm + 0x24) != 0)) {
    *(undefined4 *)((int)strm + 0x14) = 0;
    *(undefined4 *)((int)strm + 8) = 0;
    *(undefined4 *)((int)strm + 0x18) = 0;
    *(undefined4 *)((int)strm + 0x2c) = 2;
    *(undefined4 *)((int)s + 0x14) = 0;
    *(undefined4 *)((int)s + 0x10) = *(undefined4 *)((int)s + 8);
    if (*(int *)((int)s + 0x18) < 0) {
      *(undefined4 *)((int)s + 0x18) = 0;
    }
    *(uint *)((int)s + 4) = (-(uint)(*(int *)((int)s + 0x18) != 0) & 0x47) + 0x2a;
    *(undefined4 *)((int)strm + 0x30) = 1;
    *(undefined4 *)((int)s + 0x20) = 0;
    zlib_ct_init(s);
    reset_data(s);
    return 0;
  }
  return -2;
}



// Setting prototype: int deflate(void *strm, int flush)

int zlib_deflate(void *strm,int flush)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 *s;
  
                    // strm is a pointer to a z_stream structure.
  if ((((strm == (void *)0x0) || (s = *(undefined4 **)((int)strm + 0x1c), s == (undefined4 *)0x0))
      || (4 < flush)) || (flush < 0)) {
    return -2;
  }
                    // WARNING: Load size is inaccurate
  if (((*(int *)((int)strm + 0xc) == 0) || ((*strm == 0 && (*(int *)((int)strm + 4) != 0)))) ||
     ((s[1] == 0x29a && (flush != 4)))) {
    *(undefined **)((int)strm + 0x18) = zlib_stream_error_msg;
    return -2;
  }
  if (*(int *)((int)strm + 0x10) == 0) {
    *(undefined **)((int)strm + 0x18) = zlib_buffer_error_msg;
    return -5;
  }
  iVar2 = s[8];
  *s = strm;
  s[8] = flush;
  if (s[1] == 0x2a) {
    uVar1 = s[0x1f] + -1 >> 1;
    if (3 < uVar1) {
      uVar1 = 3;
    }
    uVar1 = s[10] * 0x1000 - 0x7800U | uVar1 << 6;
    if (s[0x19] != 0) {
      uVar1 = uVar1 | 0x20;
    }
    s[1] = 0x71;
    write_to_buffer(s,((short)uVar1 - (short)(uVar1 % 0x1f)) + 0x1f);
    if (s[0x19] != 0) {
      write_to_buffer(s,(uint16_t)((uint)*(undefined4 *)((int)strm + 0x30) >> 0x10));
      write_to_buffer(s,(uint16_t)*(undefined4 *)((int)strm + 0x30));
    }
    *(undefined4 *)((int)strm + 0x30) = 1;
  }
  if (s[5] == 0) {
    if (((*(int *)((int)strm + 4) == 0) && (flush <= iVar2)) && (flush != 4)) {
      *(undefined **)((int)strm + 0x18) = zlib_buffer_error_msg;
      return -5;
    }
  }
  else {
    flush_buffer(strm);
    if (*(int *)((int)strm + 0x10) == 0) {
      s[8] = 0xffffffff;
      return 0;
    }
  }
  if (s[1] == 0x29a) {
    if (*(int *)((int)strm + 4) != 0) {
      *(undefined **)((int)strm + 0x18) = zlib_buffer_error_msg;
      return -5;
    }
LAB_10001722:
    if ((s[0x1b] == 0) && ((flush == 0 || (s[1] == 0x29a)))) goto LAB_100017dc;
  }
  else if (*(int *)((int)strm + 4) == 0) goto LAB_10001722;
  iVar2 = (**(code **)(&DAT_100245e0 + s[0x1f] * 0xc))(s,flush);
  if ((iVar2 == 2) || (iVar2 == 3)) {
    s[1] = 0x29a;
  }
  if ((iVar2 == 0) || (iVar2 == 2)) {
    if (*(int *)((int)strm + 0x10) == 0) {
      s[8] = 0xffffffff;
    }
    return 0;
  }
  if (iVar2 == 1) {
    if (flush == 1) {
      zlib_ct_tally(s);
    }
    else {
      zlib_tr_flush_block(s,0,0,0);
      if (flush == 3) {
        *(undefined2 *)(s[0xf] + -2 + s[0x11] * 2) = 0;
        uVar1 = s[0x11] * 2 - 2;
        puVar4 = (undefined4 *)s[0xf];
        for (uVar3 = uVar1 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
          *puVar4 = 0;
          puVar4 = puVar4 + 1;
        }
        for (uVar1 = uVar1 & 3; uVar1 != 0; uVar1 = uVar1 - 1) {
          *(undefined1 *)puVar4 = 0;
          puVar4 = (undefined4 *)((int)puVar4 + 1);
        }
      }
    }
    flush_buffer(strm);
    if (*(int *)((int)strm + 0x10) == 0) {
      s[8] = 0xffffffff;
      return 0;
    }
  }
LAB_100017dc:
  if (flush != 4) {
    return 0;
  }
  if (s[6] == 0) {
    write_to_buffer(s,(uint16_t)((uint)*(undefined4 *)((int)strm + 0x30) >> 0x10));
    write_to_buffer(s,(uint16_t)*(undefined4 *)((int)strm + 0x30));
    flush_buffer(strm);
    s[6] = 0xffffffff;
    return (uint)(s[5] == 0);
  }
  return 1;
}



// Setting prototype: void write_to_buffer(void *s, uint16_t val)

void __cdecl write_to_buffer(void *s,uint16_t val)

{
  int iVar1;
  
                    // 
                    // Writes a 16-bit value to the output buffer.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   val: The 16-bit value to write.
                    // 
  *(char *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) = (char)(val >> 8);
  iVar1 = *(int *)((int)s + 0x14) + 1;
  *(int *)((int)s + 0x14) = iVar1;
  *(char *)(*(int *)((int)s + 8) + iVar1) = (char)val;
  *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
  return;
}



// Setting prototype: void flush_buffer(void *strm)

void __cdecl flush_buffer(void *strm)

{
  uint uVar1;
  uint n;
  undefined4 *puVar2;
  undefined4 *puVar3;
  int s;
  
                    // 
                    // Flushes the output buffer to the z_stream.
                    // 
                    // Parameters:
                    //   strm: Pointer to the z_stream structure.
                    // 
  n = *(uint *)(*(int *)((int)strm + 0x1c) + 0x14);
  if (*(uint *)((int)strm + 0x10) < n) {
    n = *(uint *)((int)strm + 0x10);
  }
  if (n != 0) {
    puVar2 = *(undefined4 **)(*(int *)((int)strm + 0x1c) + 0x10);
    puVar3 = *(undefined4 **)((int)strm + 0xc);
    for (uVar1 = n >> 2; uVar1 != 0; uVar1 = uVar1 - 1) {
      *puVar3 = *puVar2;
      puVar2 = puVar2 + 1;
      puVar3 = puVar3 + 1;
    }
    for (uVar1 = n & 3; uVar1 != 0; uVar1 = uVar1 - 1) {
      *(undefined1 *)puVar3 = *(undefined1 *)puVar2;
      puVar2 = (undefined4 *)((int)puVar2 + 1);
      puVar3 = (undefined4 *)((int)puVar3 + 1);
    }
    *(uint *)((int)strm + 0xc) = *(int *)((int)strm + 0xc) + n;
    *(uint *)(*(int *)((int)strm + 0x1c) + 0x10) = *(int *)(*(int *)((int)strm + 0x1c) + 0x10) + n;
    *(uint *)((int)strm + 0x14) = *(int *)((int)strm + 0x14) + n;
    *(uint *)((int)strm + 0x10) = *(int *)((int)strm + 0x10) - n;
    *(uint *)(*(int *)((int)strm + 0x1c) + 0x14) = *(int *)(*(int *)((int)strm + 0x1c) + 0x14) - n;
    s = *(int *)((int)strm + 0x1c);
    if (*(int *)(s + 0x14) == 0) {
      *(undefined4 *)(s + 0x10) = *(undefined4 *)(s + 8);
    }
  }
  return;
}



// Setting prototype: int deflateEnd(void *strm)

int zlib_deflateEnd(void *strm)

{
  int iVar1;
  int iVar2;
  
                    // strm is a pointer to a z_stream structure.
  if (((strm != (void *)0x0) && (iVar1 = *(int *)((int)strm + 0x1c), iVar1 != 0)) &&
     ((iVar2 = *(int *)(iVar1 + 4), iVar2 == 0x2a || ((iVar2 == 0x71 || (iVar2 == 0x29a)))))) {
    if (*(int *)(iVar1 + 8) != 0) {
      (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),*(int *)(iVar1 + 8));
    }
    iVar1 = *(int *)(*(int *)((int)strm + 0x1c) + 0x3c);
    if (iVar1 != 0) {
      (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),iVar1);
    }
    iVar1 = *(int *)(*(int *)((int)strm + 0x1c) + 0x38);
    if (iVar1 != 0) {
      (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),iVar1);
    }
    iVar1 = *(int *)(*(int *)((int)strm + 0x1c) + 0x30);
    if (iVar1 != 0) {
      (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),iVar1);
    }
    (**(code **)((int)strm + 0x24))
              (*(undefined4 *)((int)strm + 0x28),*(undefined4 *)((int)strm + 0x1c));
    *(undefined4 *)((int)strm + 0x1c) = 0;
    return (iVar2 != 0x71) - 1 & 0xfffffffd;
  }
  return -2;
}



// Setting prototype: void reset_data(void *s)

void __cdecl reset_data(void *s)

{
  ushort uVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined4 *puVar5;
  
                    // 
                    // Resets internal data structures of the deflate state.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  *(int *)((int)s + 0x34) = *(int *)((int)s + 0x24) << 1;
  *(undefined2 *)(*(int *)((int)s + 0x3c) + -2 + *(int *)((int)s + 0x44) * 2) = 0;
  uVar4 = *(int *)((int)s + 0x44) * 2 - 2;
  puVar5 = *(undefined4 **)((int)s + 0x3c);
  for (uVar3 = uVar4 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    *puVar5 = 0;
    puVar5 = puVar5 + 1;
  }
  for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
    *(undefined1 *)puVar5 = 0;
    puVar5 = (undefined4 *)((int)puVar5 + 1);
  }
  iVar2 = *(int *)((int)s + 0x7c) * 0xc;
  *(uint *)((int)s + 0x78) = (uint)*(ushort *)(&DAT_100245da + iVar2);
  *(uint *)((int)s + 0x84) = (uint)*(ushort *)(&DAT_100245d8 + iVar2);
  *(uint *)((int)s + 0x88) = (uint)*(ushort *)(&DAT_100245dc + iVar2);
  uVar1 = *(ushort *)(&DAT_100245de + iVar2);
  *(undefined4 *)((int)s + 100) = 0;
  *(undefined4 *)((int)s + 0x54) = 0;
  *(undefined4 *)((int)s + 0x6c) = 0;
  *(undefined4 *)((int)s + 0x60) = 0;
  *(undefined4 *)((int)s + 0x40) = 0;
  *(uint *)((int)s + 0x74) = (uint)uVar1;
  *(undefined4 *)((int)s + 0x70) = 2;
  *(undefined4 *)((int)s + 0x58) = 2;
  return;
}



// Setting prototype: int deflate_stored(void *s, int flush)

int __cdecl zlib_deflate_stored(void *s,int flush)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint32_t uVar5;
  uint uVar6;
  
                    // 
                    // Handles the compression of a stored block in the deflate algorithm.
                    // This function writes uncompressed data blocks to the output stream.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   flush: The flush mode (e.g., Z_NO_FLUSH, Z_FINISH).
                    // 
                    // Return values:
                    //   Z_OK (0) if successful, or an error code.
                    // 
  uVar3 = *(int *)((int)s + 0xc) - 5;
  uVar6 = 0xffff;
  if (uVar3 < 0xffff) {
    uVar6 = uVar3;
  }
  do {
    uVar3 = *(uint *)((int)s + 0x6c);
    if (uVar3 < 2) {
      zlib_fill_window(s);
      uVar3 = *(uint *)((int)s + 0x6c);
      if (uVar3 == 0) {
        if (flush == 0) {
          return 0;
        }
        iVar1 = *(int *)((int)s + 0x54);
        if (iVar1 < 0) {
          uVar5 = 0;
        }
        else {
          uVar5 = *(int *)((int)s + 0x30) + iVar1;
        }
        zlib_bi_flush(s,uVar5,*(int *)((int)s + 100) - iVar1,(uint)(flush == 4));
                    // WARNING: Load size is inaccurate
        *(undefined4 *)((int)s + 0x54) = *(undefined4 *)((int)s + 100);
        flush_buffer(*s);
                    // WARNING: Load size is inaccurate
        if (*(int *)(*s + 0x10) != 0) {
          return (-(uint)(flush != 4) & 0xfffffffe) + 3;
        }
        return (flush != 4) - 1 & 2;
      }
    }
    *(undefined4 *)((int)s + 0x6c) = 0;
    iVar4 = *(int *)((int)s + 100) + uVar3;
    *(int *)((int)s + 100) = iVar4;
    iVar1 = *(int *)((int)s + 0x54);
    uVar2 = *(uint *)((int)s + 100);
    uVar3 = iVar1 + uVar6;
    if ((iVar4 == 0) || (uVar3 <= uVar2)) {
      *(uint *)((int)s + 100) = uVar3;
      *(uint *)((int)s + 0x6c) = uVar2 - uVar3;
      if (iVar1 < 0) {
        uVar5 = 0;
      }
      else {
        uVar5 = *(int *)((int)s + 0x30) + iVar1;
      }
      zlib_bi_flush(s,uVar5,uVar3 - iVar1,0);
                    // WARNING: Load size is inaccurate
      *(undefined4 *)((int)s + 0x54) = *(undefined4 *)((int)s + 100);
      flush_buffer(*s);
                    // WARNING: Load size is inaccurate
      if (*(int *)(*s + 0x10) == 0) {
        return 0;
      }
    }
    iVar1 = *(int *)((int)s + 0x54);
    uVar3 = *(int *)((int)s + 100) - iVar1;
    if (*(int *)((int)s + 0x24) - 0x106U <= uVar3) {
      if (iVar1 < 0) {
        uVar5 = 0;
      }
      else {
        uVar5 = *(int *)((int)s + 0x30) + iVar1;
      }
      zlib_bi_flush(s,uVar5,uVar3,0);
                    // WARNING: Load size is inaccurate
      *(undefined4 *)((int)s + 0x54) = *(undefined4 *)((int)s + 100);
      flush_buffer(*s);
                    // WARNING: Load size is inaccurate
      if (*(int *)(*s + 0x10) == 0) {
        return 0;
      }
    }
  } while( true );
}



// Setting prototype: void fill_window(void *s)

void __cdecl zlib_fill_window(void *s)

{
  byte *pbVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  ushort *puVar5;
  uint uVar6;
  uint32_t uVar7;
  uint32_t len;
  undefined4 *puVar8;
  int iVar9;
  undefined4 *puVar10;
  
                    // 
                    // Fills the sliding window with new data from the input stream.
                    // This function manages the circular buffer used for LZ77 compression.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  uVar2 = *(uint *)((int)s + 0x24);
  do {
    uVar6 = *(uint *)((int)s + 100);
    uVar7 = (*(int *)((int)s + 0x34) - uVar6) - *(int *)((int)s + 0x6c);
    if (uVar7 == 0) {
      if ((uVar6 != 0) || (len = uVar2, *(int *)((int)s + 0x6c) != 0)) {
LAB_10001bf5:
        len = uVar7;
        if (*(int *)((int)s + 0x24) + -0x106 + uVar2 <= uVar6) {
          puVar8 = (undefined4 *)((int)*(undefined4 **)((int)s + 0x30) + uVar2);
          puVar10 = *(undefined4 **)((int)s + 0x30);
          for (uVar6 = uVar2 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
            *puVar10 = *puVar8;
            puVar8 = puVar8 + 1;
            puVar10 = puVar10 + 1;
          }
          for (uVar6 = uVar2 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
            *(undefined1 *)puVar10 = *(undefined1 *)puVar8;
            puVar8 = (undefined4 *)((int)puVar8 + 1);
            puVar10 = (undefined4 *)((int)puVar10 + 1);
          }
          *(uint *)((int)s + 0x68) = *(int *)((int)s + 0x68) - uVar2;
          iVar9 = *(int *)((int)s + 0x44);
          *(uint *)((int)s + 100) = *(int *)((int)s + 100) - uVar2;
          *(uint *)((int)s + 0x54) = *(int *)((int)s + 0x54) - uVar2;
          puVar5 = (ushort *)(*(int *)((int)s + 0x3c) + iVar9 * 2);
          do {
            puVar5 = puVar5 + -1;
            if (*puVar5 < uVar2) {
              uVar3 = 0;
            }
            else {
              uVar3 = *puVar5 - (short)uVar2;
            }
            iVar9 = iVar9 + -1;
            *puVar5 = uVar3;
          } while (iVar9 != 0);
          puVar5 = (ushort *)(*(int *)((int)s + 0x38) + uVar2 * 2);
          uVar6 = uVar2;
          do {
            puVar5 = puVar5 + -1;
            if (*puVar5 < uVar2) {
              uVar3 = 0;
            }
            else {
              uVar3 = *puVar5 - (short)uVar2;
            }
            uVar6 = uVar6 - 1;
            *puVar5 = uVar3;
          } while (uVar6 != 0);
          len = uVar7 + uVar2;
        }
      }
    }
    else {
      if (uVar7 != 0xffffffff) goto LAB_10001bf5;
      len = 0xfffffffe;
    }
                    // WARNING: Load size is inaccurate
    if (*(int *)((int)*s + 4) == 0) {
      return;
    }
    uVar7 = zlib_read_buf(*s,(byte *)(*(int *)((int)s + 0x6c) + *(int *)((int)s + 100) +
                                     *(int *)((int)s + 0x30)),len);
    uVar6 = *(int *)((int)s + 0x6c) + uVar7;
    *(uint *)((int)s + 0x6c) = uVar6;
    if (2 < uVar6) {
      pbVar1 = (byte *)(*(int *)((int)s + 100) + *(int *)((int)s + 0x30));
      uVar4 = (uint)*pbVar1;
      *(uint *)((int)s + 0x40) = uVar4;
      *(uint *)((int)s + 0x40) =
           (uVar4 << ((byte)*(undefined4 *)((int)s + 0x50) & 0x1f) ^ (uint)pbVar1[1]) &
           *(uint *)((int)s + 0x4c);
    }
    if (0x105 < uVar6) {
      return;
    }
                    // WARNING: Load size is inaccurate
    if (*(int *)(*s + 4) == 0) {
      return;
    }
  } while( true );
}



// Setting prototype: uint32_t read_buf(void *strm, byte *buf, uint32_t len)

uint32_t __cdecl zlib_read_buf(void *strm,byte *buf,uint32_t len)

{
  uint32_t uVar1;
  uint uVar2;
  uint len_00;
  byte *pbVar3;
  
                    // 
                    // Reads data from the input buffer of the z_stream.
                    // 
                    // Parameters:
                    //   strm: Pointer to the z_stream structure.
                    //   buf: Pointer to the destination buffer.
                    //   len: Number of bytes to read.
                    // 
                    // Return values:
                    //   The number of bytes actually read.
                    // 
  uVar2 = *(uint *)((int)strm + 4);
  len_00 = uVar2;
  if (len < uVar2) {
    len_00 = len;
  }
  if (len_00 == 0) {
    return 0;
  }
  *(uint *)((int)strm + 4) = uVar2 - len_00;
  if (*(int *)(*(int *)((int)strm + 0x1c) + 0x18) == 0) {
                    // WARNING: Load size is inaccurate
    uVar1 = zlib_adler32(*(uint32_t *)((int)strm + 0x30),*strm,len_00);
    *(uint32_t *)((int)strm + 0x30) = uVar1;
  }
                    // WARNING: Load size is inaccurate
  pbVar3 = *strm;
  for (uVar2 = len_00 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
    *(undefined4 *)buf = *(undefined4 *)pbVar3;
    pbVar3 = pbVar3 + 4;
    buf = buf + 4;
  }
  for (uVar2 = len_00 & 3; uVar2 != 0; uVar2 = uVar2 - 1) {
    *buf = *pbVar3;
    pbVar3 = pbVar3 + 1;
    buf = buf + 1;
  }
                    // WARNING: Load size is inaccurate
  *(uint *)strm = *strm + len_00;
  *(uint *)((int)strm + 8) = *(int *)((int)strm + 8) + len_00;
  return len_00;
}



// Setting prototype: void logEvent(LPCSTR message, byte flags, int log_level)

void __cdecl logEvent(LPCSTR message,byte flags,int log_level)

{
  char cVar1;
  int iVar2;
  FILE *file_ptr;
  int *piVar3;
  uint uVar4;
  LPCSTR pCVar5;
  DWORD local_108;
  FILE local_104 [8];
  
                    // flags: Bitmask for logging destinations: 0x01 = file, 0x04 = debug output,
                    // 0x08 = console
  if ((flags & 1) != 0) {
    iVar2 = 0;
    piVar3 = &DAT_10027078;
    do {
      if (log_level == *piVar3) {
        file_ptr = (FILE *)printf_wrapper((undefined1 *)local_104,s__s__s_100270fc,&DAT_11766100,
                                          s___server_log_10027084 + iVar2 * 0x20);
        open_file_wrapper(local_104,&DAT_100270f8);
        if (file_ptr != (FILE *)0x0) goto LAB_100026e6;
        break;
      }
      piVar3 = piVar3 + 1;
      iVar2 = iVar2 + 1;
    } while ((int)piVar3 < 0x10027084);
    printf_wrapper((undefined1 *)local_104,s__s__s_100270fc,&DAT_11766100,s___server_log_100270e8);
    file_ptr = local_104;
    open_file_wrapper(file_ptr,&DAT_100270f8);
    if (file_ptr != (FILE *)0x0) {
LAB_100026e6:
      write_string_to_file(message,file_ptr);
      write_string_to_file(&DAT_100270e4,file_ptr);
      fclose_wrapper(file_ptr);
    }
  }
  if ((flags & 4) != 0) {
    OutputDebugStringA(message);
    OutputDebugStringA(&DAT_100270e4);
  }
  if ((flags & 8) != 0) {
    uVar4 = 0xffffffff;
    pCVar5 = message;
    do {
      if (uVar4 == 0) break;
      uVar4 = uVar4 - 1;
      cVar1 = *pCVar5;
      pCVar5 = pCVar5 + 1;
    } while (cVar1 != '\0');
    WriteConsoleA(DAT_11766204,message,~uVar4 - 1,&local_108,(LPVOID)0x0);
    WriteConsoleA(DAT_11766204,&DAT_100270e4,1,&local_108,(LPVOID)0x0);
  }
  return;
}



// Setting prototype: LONG unhandledExceptionHandler(_EXCEPTION_POINTERS *ExceptionInfo)

long unhandledExceptionHandler(_EXCEPTION_POINTERS *ExceptionInfo)

{
  char cVar1;
  DWORD DVar2;
  char *pcVar3;
  HANDLE pvVar4;
  uint *lpBuffer;
  uint uVar5;
  BOOL BVar6;
  uint32_t uVar7;
  uint *puVar8;
  int iVar9;
  CHAR *lpBuffer_00;
  undefined4 *puVar10;
  char *pcVar11;
  SIZE_T nSize;
  DWORD DVar12;
  DWORD DStack_280;
  undefined2 uStack_27c;
  undefined1 auStack_27a [4];
  char local_276;
  undefined1 uStack_275;
  uint uStack_274;
  uint uStack_270;
  LPCVOID pvStack_26c;
  int iStack_268;
  PCONTEXT local_264;
  HANDLE pvStack_260;
  uint *puStack_25c;
  HANDLE pvStack_258;
  uint *puStack_254;
  HANDLE pvStack_250;
  LPCVOID pvStack_24c;
  int aiStack_248 [4];
  _MEMORY_BASIC_INFORMATION _Stack_238;
  undefined4 uStack_21c;
  CHAR aCStack_200 [7];
  undefined1 auStack_1f9 [249];
  char cStack_100;
  char acStack_ff [255];
  
                    // This function is an unhandled exception filter that generates a crash dump.
  local_264 = ExceptionInfo->ContextRecord;
  local_276 = '\0';
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  DVar2 = GetModuleFileNameA((HMODULE)0x0,&cStack_100,0x100);
  if (DVar2 == 0) goto LAB_10002e66;
  pcVar3 = &cStack_100;
  if (cStack_100 == '\0') {
LAB_100027d5:
    do {
      if (*pcVar3 == '.') goto LAB_100027eb;
      pcVar3 = pcVar3 + -1;
    } while (&cStack_100 <= pcVar3);
  }
  else {
    do {
      pcVar11 = pcVar3 + 1;
      pcVar3 = pcVar3 + 1;
    } while (*pcVar11 != '\0');
    if (&cStack_100 <= pcVar3) goto LAB_100027d5;
  }
  if (*pcVar3 == '.') {
LAB_100027eb:
    builtin_strncpy(pcVar3 + 1,"dbg",4);
  }
  pvVar4 = CreateFileA(&cStack_100,0x80000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0x80,(HANDLE)0x0);
  pvStack_260 = pvVar4;
  if (pvVar4 == (HANDLE)0xffffffff) {
    logMessage(s_D__Develop_Units_Error_Error_c_10027144,0x220,s_no_dbg_file_10027104,1);
    goto LAB_10002e66;
  }
  ReadFile(pvVar4,&uStack_274,4,&uStack_270,(LPOVERLAPPED)0x0);
  if (uStack_270 != 4) {
    pcVar3 = s_bad_dbg_file_10027110;
    iVar9 = 0x21b;
LAB_10002e35:
    logMessage(s_D__Develop_Units_Error_Error_c_10027144,iVar9,pcVar3,1);
    CloseHandle(pvVar4);
    goto LAB_10002e66;
  }
  lpBuffer = (uint *)VirtualAlloc((LPVOID)0x0,uStack_274,0x1000,4);
  puStack_25c = lpBuffer;
  if (lpBuffer == (uint *)0x0) {
    pcVar3 = s_no_memory_10027120;
    iVar9 = 0x218;
    goto LAB_10002e35;
  }
  ReadFile(pvVar4,lpBuffer,uStack_274,&uStack_270,(LPOVERLAPPED)0x0);
  if (uStack_274 != uStack_270) {
    logMessage(s_D__Develop_Units_Error_Error_c_10027144,0x213,s_bad__small__dbg_file_1002712c,1);
    VirtualFree(lpBuffer,0,0x8000);
    CloseHandle(pvVar4);
    goto LAB_10002e66;
  }
  pvVar4 = CreateFileA(s___crashdump_log_10027318,0x40000000,0,(LPSECURITY_ATTRIBUTES)0x0,4,0x80,
                       (HANDLE)0x0);
  uVar5 = *lpBuffer;
  uStack_274 = 0;
  puVar8 = lpBuffer + 4;
  if (uStack_270 >> 2 != 4) {
    do {
      uVar5 = uVar5 << 0xf | uVar5 >> 0x11;
      *puVar8 = *puVar8 ^ uVar5;
      uStack_274 = uStack_274 + 1;
      puVar8 = puVar8 + 1;
    } while (uStack_274 < (uStack_270 >> 2) - 4);
  }
  if (pvVar4 == (HANDLE)0xffffffff) {
    logMessage(s_D__Develop_Units_Error_Error_c_10027144,0x20f,s_not_open_crashdump_10027164,1);
    pvVar4 = pvStack_260;
    VirtualFree(lpBuffer,0,0x8000);
    CloseHandle(pvVar4);
    goto LAB_10002e66;
  }
  pvStack_258 = GetCurrentProcess();
  uStack_27c = DAT_10027314;
  pcVar3 = s__________________________100272f8;
  puVar10 = &uStack_21c;
  for (iVar9 = 6; iVar9 != 0; iVar9 = iVar9 + -1) {
    *puVar10 = *(undefined4 *)pcVar3;
    pcVar3 = pcVar3 + 4;
    puVar10 = puVar10 + 1;
  }
  *(undefined2 *)puVar10 = *(undefined2 *)pcVar3;
  DVar2 = local_264->Esp;
  iStack_268 = 0x800;
  auStack_27a[0] = DAT_10027316;
  uStack_275 = 0x20;
  *(char *)((int)puVar10 + 2) = pcVar3[2];
  SetFilePointer(pvVar4,-1,(PLONG)0x0,2);
  WriteFile(pvVar4,&uStack_21c,0x1a,&DStack_280,(LPOVERLAPPED)0x0);
  iVar9 = GetDateFormatA(0x400,2,(SYSTEMTIME *)0x0,(LPCSTR)0x0,aCStack_200,0x100);
  if (iVar9 != 0) {
    WriteFile(pvVar4,aCStack_200,iVar9 - 1,&DStack_280,(LPOVERLAPPED)0x0);
    WriteFile(pvVar4,&uStack_275,1,&DStack_280,(LPOVERLAPPED)0x0);
  }
  iVar9 = GetTimeFormatA(0x400,8,(SYSTEMTIME *)0x0,(LPCSTR)0x0,aCStack_200,0x100);
  if (iVar9 != 0) {
    WriteFile(pvVar4,aCStack_200,iVar9 - 1,&DStack_280,(LPOVERLAPPED)0x0);
    WriteFile(pvVar4,&uStack_27c,2,&DStack_280,(LPOVERLAPPED)0x0);
  }
  uVar5 = ExceptionInfo->ExceptionRecord->ExceptionCode;
  if (uVar5 < 0xc000008f) {
    if (uVar5 == 0xc000008e) {
      DVar12 = 0x12;
      pcVar3 = s_FLT_DIVIDE_BY_ZERO_1002721c;
    }
    else {
      if (uVar5 < 0xc000001e) {
        if (uVar5 == 0xc000001d) {
          DVar12 = 0x13;
          pcVar3 = s_ILLEGAL_INSTRUCTION_10027290;
        }
        else if (uVar5 < 0xc0000006) {
          if (uVar5 != 0xc0000005) {
            if (uVar5 == 0x80000003) {
              DVar12 = 10;
              pcVar3 = s_BREAKPOINT_100272e0;
            }
            else {
              if (uVar5 != 0x80000004) goto switchD_10002b2a_caseD_c0000027;
              DVar12 = 0xb;
              pcVar3 = s_SINGLE_STEP_100272ec;
            }
            goto LAB_10002b7f;
          }
          WriteFile(pvVar4,s_ACCESS_VIOLATION_100272cc,0x11,&DStack_280,(LPOVERLAPPED)0x0);
          if (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] == 0) {
            DVar12 = 5;
            pcVar3 = s_READ_100272c4;
          }
          else {
            DVar12 = 6;
            pcVar3 = s_WRITE_100272bc;
          }
          WriteFile(pvVar4,pcVar3,DVar12,&DStack_280,(LPOVERLAPPED)0x0);
          printf_wrapper(aCStack_200,s_0x_08X_100272b4,
                         ExceptionInfo->ExceptionRecord->ExceptionInformation[1]);
          uVar5 = 0xffffffff;
          pcVar3 = aCStack_200;
          pcVar11 = aCStack_200;
          do {
            if (uVar5 == 0) break;
            uVar5 = uVar5 - 1;
            cVar1 = *pcVar11;
            pcVar11 = pcVar11 + 1;
          } while (cVar1 != '\0');
          DVar12 = ~uVar5 - 1;
        }
        else {
          if (uVar5 != 0xc0000006) goto switchD_10002b2a_caseD_c0000027;
          DVar12 = 0xd;
          pcVar3 = s_IN_PAGE_ERROR_100272a4;
        }
        goto LAB_10002c40;
      }
      switch(uVar5) {
      case 0xc0000025:
        DVar12 = 0x18;
        pcVar3 = s_NONCONTINUABLE_EXCEPTION_10027230;
        break;
      case 0xc0000026:
        DVar12 = 0x13;
        pcVar3 = s_INVALID_DISPOSITION_1002724c;
        break;
      default:
        goto switchD_10002b2a_caseD_c0000027;
      case 0xc000008c:
        DVar12 = 0x15;
        pcVar3 = s_ARRAY_BOUNDS_EXCEEDED_10027278;
        break;
      case 0xc000008d:
        DVar12 = 0x14;
        pcVar3 = s_FLT_DENORMAL_OPERAND_10027260;
      }
    }
LAB_10002b7f:
    WriteFile(pvVar4,pcVar3,DVar12,&DStack_280,(LPOVERLAPPED)0x0);
  }
  else {
    switch(uVar5) {
    case 0xc000008f:
      DVar12 = 0x12;
      pcVar3 = s_FLT_INEXACT_RESULT_10027208;
      break;
    case 0xc0000090:
      DVar12 = 0x15;
      pcVar3 = s_FLT_INVALID_OPERATION_100271f0;
      break;
    case 0xc0000091:
      DVar12 = 0xc;
      pcVar3 = s_FLT_OVERFLOW_100271e0;
      break;
    case 0xc0000092:
      DVar12 = 0xf;
      pcVar3 = s_FLT_STACK_CHECK_100271d0;
      break;
    case 0xc0000093:
      DVar12 = 0xd;
      pcVar3 = s_FLT_UNDERFLOW_100271c0;
      break;
    case 0xc0000094:
      DVar12 = 0x12;
      pcVar3 = s_INT_DIVIDE_BY_ZERO_100271ac;
      break;
    case 0xc0000095:
      DVar12 = 0xc;
      pcVar3 = s_INT_OVERFLOW_1002719c;
      break;
    case 0xc0000096:
      DVar12 = 0x10;
      pcVar3 = s_PRIV_INSTRUCTION_10027188;
      break;
    default:
      goto switchD_10002b2a_caseD_c0000027;
    case 0xc00000fd:
      DVar12 = 0xe;
      pcVar3 = s_STACK_OVERFLOW_10027178;
    }
LAB_10002c40:
    WriteFile(pvVar4,pcVar3,DVar12,&DStack_280,(LPOVERLAPPED)0x0);
  }
  WriteFile(pvVar4,&uStack_27c,2,&DStack_280,(LPOVERLAPPED)0x0);
switchD_10002b2a_caseD_c0000027:
  puStack_254 = puStack_25c;
  pvStack_24c = (LPCVOID)local_264->Eip;
  pvStack_26c = (LPCVOID)(DVar2 - 4);
  aiStack_248[0] = 0;
  aiStack_248[1] = 0;
  aiStack_248[2] = 0;
  aiStack_248[3] = 0;
  pvStack_250 = pvVar4;
  do {
    VirtualQuery(pvStack_24c,&_Stack_238,0x1c);
    iVar9 = checkMemoryProtection(_Stack_238.Protect);
    if (((char)iVar9 != '\0') && (_Stack_238.State == 0x1000)) {
      if (pvStack_24c != (LPCVOID)local_264->Eip) {
        nSize = 7;
        lpBuffer_00 = aCStack_200;
        do {
          BVar6 = ReadProcessMemory(pvStack_258,(LPCVOID)((int)pvStack_24c - nSize),lpBuffer_00,
                                    nSize,(SIZE_T *)0x0);
          if (BVar6 != 0) break;
          nSize = nSize - 1;
          lpBuffer_00 = lpBuffer_00 + 1;
        } while (0 < (int)nSize);
        uVar7 = analyzeBytePattern((int)auStack_1f9,nSize,(int)pvStack_24c,aiStack_248);
        if ((char)uVar7 == '\0') goto LAB_10002d31;
      }
      uVar7 = writeArchiveFile(&puStack_254);
      if ((char)uVar7 != '\0') {
        iStack_268 = iStack_268 + -1;
      }
    }
LAB_10002d31:
    pvStack_26c = (LPCVOID)((int)pvStack_26c + 4);
  } while ((0 < iStack_268) &&
          (BVar6 = ReadProcessMemory(pvStack_258,pvStack_26c,&pvStack_24c,4,(SIZE_T *)0x0),
          BVar6 != 0));
  if (DAT_10034614 != (code *)0x0) {
    (*DAT_10034614)(pvVar4);
    local_276 = '\x01';
  }
  WriteFile(pvVar4,auStack_27a,1,&DStack_280,(LPOVERLAPPED)0x0);
  CloseHandle(pvVar4);
  pvVar4 = pvStack_260;
  VirtualFree(puStack_25c,0,0x8000);
  CloseHandle(pvVar4);
LAB_10002e66:
  if ((DAT_10034614 != (code *)0x0) && (local_276 == '\0')) {
    (*DAT_10034614)(0xffffffff);
  }
  UnhandledExceptionFilter(ExceptionInfo);
  return 1;
}



// Setting prototype: uint32_t writeArchiveFile(void *archive)

uint32_t __cdecl writeArchiveFile(void *archive)

{
  void *pvVar1;
  uint uVar2;
  int *piVar3;
  BOOL BVar4;
  int *entry;
  undefined2 magic;
  undefined1 version;
  undefined4 *header;
  DWORD bytes_written;
  undefined4 val_1;
  undefined1 val_2;
  undefined4 val_3;
  undefined1 val_4;
  int archive_handle;
  
                    // This function writes data to an archive file, likely as part of the crash
                    // dump generation.
  pvVar1 = archive;
                    // WARNING: Load size is inaccurate
  archive_handle = *archive;
  entry = (int *)(*(int *)(archive_handle + 0xc) + 0x10 + archive_handle);
  uVar2 = 0;
  if (*(uint *)(archive_handle + 8) != 0) {
    do {
      if (((uint)entry[1] <= *(uint *)((int)archive + 8)) &&
         (*(uint *)((int)archive + 8) <= (uint)entry[2])) {
        val_2 = DAT_10027338;
        val_1 = DAT_10027334;
        val_4 = DAT_10027330;
        val_3 = DAT_1002732c;
        header = (undefined4 *)0x0;
        if (*(int *)((int)archive + 0x10) == 0) {
          *(int *)((int)archive + 0x10) = entry[1];
        }
        else if (*(int *)((int)archive + 0x10) == *(int *)((int)archive + 0xc)) {
          *(int *)((int)archive + 0x10) = entry[1];
          *(int *)((int)archive + 0x18) = *(int *)((int)archive + 0x18) + 1;
        }
        else {
          header = &val_1;
          uVar2 = *(uint *)((int)archive + 0x14);
          if ((uVar2 == 0) || (1 < *(uint *)((int)archive + 0x18))) {
            if (DAT_1003461c == '\0') break;
          }
          else {
            header = &val_3;
            *(int *)((int)archive + 0x10) = entry[1];
            *(uint *)((int)archive + 0x14) = uVar2 - 1;
          }
        }
        piVar3 = (int *)getDataBlock(archive_handle,entry[3]);
        archive = (void *)CONCAT22(archive._2_2_,DAT_10027328);
        magic = DAT_10027314;
        version = DAT_10027316;
        if (header != (undefined4 *)0x0) {
          WriteFile(*(HANDLE *)((int)pvVar1 + 4),header,4,&bytes_written,(LPOVERLAPPED)0x0);
        }
        WriteFile(*(HANDLE *)((int)pvVar1 + 4),entry + 4,*entry - 1,&bytes_written,(LPOVERLAPPED)0x0
                 );
        if (piVar3 != (int *)0x0) {
          WriteFile(*(HANDLE *)((int)pvVar1 + 4),&archive,1,&bytes_written,(LPOVERLAPPED)0x0);
          WriteFile(*(HANDLE *)((int)pvVar1 + 4),piVar3 + 1,*piVar3 - 1,&bytes_written,
                    (LPOVERLAPPED)0x0);
        }
        BVar4 = WriteFile(*(HANDLE *)((int)pvVar1 + 4),&magic,2,&bytes_written,(LPOVERLAPPED)0x0);
        return CONCAT31((int3)((uint)BVar4 >> 8),1);
      }
      uVar2 = uVar2 + 1;
      entry = (int *)((int)entry + *entry + 0x10);
    } while (uVar2 < *(uint *)(archive_handle + 8));
  }
  return uVar2 & 0xffffff00;
}



// Setting prototype: int *getDataBlock(void *data_structure, uint32_t block_index)

int * getDataBlock(int data_structure,uint block_index)

{
  int *block_ptr;
  
                    // This function retrieves a data block from a data structure, likely for crash
                    // dump generation.
  if (block_index < *(uint *)(data_structure + 4)) {
    block_ptr = (int *)(data_structure + 0x10);
    if (block_index != 0) {
      do {
        block_index = block_index - 1;
        block_ptr = (int *)((int)block_ptr + *block_ptr + 4);
      } while (block_index != 0);
      return block_ptr;
    }
  }
  else {
    block_ptr = (int *)0x0;
  }
  return block_ptr;
}



// Setting prototype: int checkMemoryProtection(uint32_t address)

int __cdecl checkMemoryProtection(uint32_t address)

{
  uint3 protection;
  _MEMORY_BASIC_INFORMATION mem_info;
  
                    // This function checks the memory protection of a given address, likely for
                    // crash dump generation.
  VirtualQuery(checkMemoryProtection,&mem_info,0x1c);
  protection = (uint3)((address & 0xff) - 2 >> 8);
  switch(address & 0xff) {
  case 2:
  case 4:
    break;
  default:
    return (uint)protection << 8;
  case 0x10:
  case 0x20:
  case 0x40:
  case 0x80:
    return CONCAT31(protection,1);
  }
  if ((mem_info.Protect != 2) && (mem_info.Protect != 4)) {
    return 0;
  }
  return 1;
}



// Setting prototype: uint32_t analyzeBytePattern(int pattern_start, int length, int offset_val, int
// *found_address)

uint32_t __cdecl analyzeBytePattern(int pattern_start,int length,int offset_val,int *found_address)

{
  int iVar1;
  uint3 uVar2;
  
                    // This function analyzes a byte pattern for specific sequences, likely to
                    // identify function prologues for crash dump generation.
  *found_address = 0;
  if ((4 < length) && (*(char *)(pattern_start + -5) == -0x18)) {
    iVar1 = *(int *)(pattern_start + -4) + offset_val;
    *found_address = iVar1;
    return CONCAT31((int3)((uint)iVar1 >> 8),1);
  }
  uVar2 = (uint3)((uint)pattern_start >> 8);
  if (((2 < length) && (*(char *)(pattern_start + -3) == -1)) &&
     (*(char *)(pattern_start + -2) == '\x14')) {
    return CONCAT31(uVar2,2);
  }
  if (((5 < length) && (*(char *)(pattern_start + -6) == -1)) &&
     (*(char *)(pattern_start + -5) == '\x15')) {
    return CONCAT31(uVar2,2);
  }
  if ((1 < length) && (*(char *)(pattern_start + -2) == -1)) {
    if (*(byte *)(pattern_start + -1) < 0x40) {
      return CONCAT31(uVar2,2);
    }
    if ((*(byte *)(pattern_start + -1) & 0xf8) == 0xd0) {
      return CONCAT31(uVar2,2);
    }
  }
  if (((2 < length) && (*(char *)(pattern_start + -3) == -1)) &&
     ((*(byte *)(pattern_start + -2) & 0xf8) == 0x50)) {
    return CONCAT31(uVar2,2);
  }
  if (((6 < length) && (*(char *)(pattern_start + -7) == -1)) &&
     ((*(byte *)(pattern_start + -6) & 0xf8) == 0x90)) {
    return CONCAT31(uVar2,2);
  }
  return (uint)uVar2 << 8;
}



// Setting prototype: void errorHandlerInit(void *exception_callback, void *user_data, HWND
// main_window_handle, uint32_t init_flags)

void __cdecl
errorHandlerInit(void *exception_callback,void *user_data,HWND main_window_handle,
                uint32_t init_flags)

{
  LPTOP_LEVEL_EXCEPTION_FILTER pPVar1;
  char *pcVar2;
  uint32_t uVar3;
  int file_size;
  FILE *file_ptr;
  int *piVar4;
  LPTOP_LEVEL_EXCEPTION_FILTER pPStack_208;
  FILE aFStack_204 [8];
  CHAR window_title [256];
  
                    // This function initializes the error handling for the application, including
                    // setting an unhandled exception filter and configuring logging.
  DAT_10034610 = exception_callback;
  DAT_10034618 = init_flags;
  DAT_1003461c = (byte)(init_flags >> 4) & 1;
  DAT_10034614 = user_data;
  DAT_117660e0 = main_window_handle;
  pPVar1 = SetUnhandledExceptionFilter(unhandledExceptionHandler);
  get_local_time((uint32_t *)0x0);
  pPStack_208 = pPVar1;
  GetWindowTextA(main_window_handle,window_title,0x100);
  GetModuleFileNameA((HMODULE)0x0,&DAT_11766100,0x104);
  pcVar2 = _strrchr(&DAT_11766100,0x5c);
  *pcVar2 = '\0';
  uVar3 = get_current_time(&pPStack_208);
  printf_wrapper(&DAT_117640e0,s__________________________________1002735c,window_title,uVar3);
  if ((DAT_10034618 & 1) != 0) {
    pcVar2 = s___server_log_10027084;
    do {
      printf_wrapper((undefined1 *)aFStack_204,s__s__s_100270fc,&DAT_11766100,pcVar2);
      file_ptr = aFStack_204;
      open_file_wrapper(file_ptr,&DAT_100270f8);
      if (file_ptr != (FILE *)0x0) {
        file_seek(file_ptr,0,2);
        file_size = get_file_size_wrapper(file_ptr);
        if (0x10000 < file_size) {
          file_ptr = (FILE *)fclose_wrapper(file_ptr);
          open_file_wrapper(aFStack_204,&DAT_10027358);
          write_string_to_file(s_LogFile_has_been_deleted__1002733c,file_ptr);
        }
        fclose_wrapper(file_ptr);
      }
      pcVar2 = pcVar2 + 0x20;
    } while ((int)pcVar2 < 0x100270e4);
  }
  if ((DAT_10034618 & 8) != 0) {
    AllocConsole();
    DAT_11766204 = GetStdHandle(0xfffffff5);
  }
  piVar4 = &DAT_10027078;
  do {
    logEvent(&DAT_117640e0,(byte)DAT_10034618,*piVar4);
    piVar4 = piVar4 + 1;
  } while ((int)piVar4 < 0x10027084);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void errorHandlerCleanup(void)

void errorHandlerCleanup(void)

{
  int *piVar1;
  
                    // This function cleans up the error handling system.
  piVar1 = &DAT_10027078;
  do {
    logEvent(s_Error_Handler_closed__100273ac,(byte)DAT_10034618,*piVar1);
    piVar1 = piVar1 + 1;
  } while ((int)piVar1 < 0x10027084);
  if ((DAT_10034618 & 8) != 0) {
    FreeConsole();
    DAT_11766204 = 0;
  }
  DAT_10034610 = 0;
  DAT_117660e0 = 0;
  DAT_10034618 = 0;
  return;
}



// Setting prototype: void fatalError(LPCSTR file_name, uint32_t line_number, LPCSTR error_message)

void __cdecl fatalError(LPCSTR file_name,uint32_t line_number,LPCSTR error_message)

{
  int msgbox_result;
  LPCSTR retaddr;
  
                    // This function handles fatal errors by displaying a message box and logging
                    // the error.
  if (DAT_10034610 == (code *)0x0) {
    MessageBoxA((HWND)0x0,s_ERROR_Handler_has_not_been_start_100273fc,s_Error__10027424,0x30);
  }
  else if (DAT_10034618 != 0) {
    if ((DAT_10034618 & 0xf) != 0) {
      printf_wrapper(&DAT_117640e0,s_FATAL_ERROR___s__lu____s_100273e0,file_name,line_number,
                     error_message);
    }
    if ((DAT_10034618 & 0xd) != 0) {
      logEvent(&DAT_117640e0,(byte)DAT_10034618,1);
    }
    if ((DAT_10034618 & 2) != 0) {
      msgbox_result =
           MessageBoxA(DAT_117660e0,&DAT_117640e0,s_Fatal_Error__Abort_Program__100273c4,0x124);
      if (msgbox_result == 6) {
        (*DAT_10034610)();
        exit_program_2(0xf);
        if (DAT_10034610 == (code *)0x0) {
          MessageBoxA((HWND)0x0,s_ERROR_Handler_has_not_been_start_100273fc,s_Error__10027424,
                      0x10030);
          return;
        }
        if (DAT_10034618 != 0) {
          if ((DAT_10034618 & 0xd) != 0) {
            printf_wrapper(&DAT_117640e0,s_MESSAGE___s_10027438,retaddr);
            logEvent(&DAT_117640e0,(byte)DAT_10034618,1);
          }
          if ((DAT_10034618 & 2) != 0) {
            MessageBoxA((HWND)0x0,retaddr,s_Message__1002742c,0x1030);
          }
        }
        return;
      }
    }
  }
  return;
}



// Setting prototype: void showMessage(LPCSTR message)

void __cdecl showMessage(LPCSTR message)

{
                    // This function displays a message to the user.
  if (DAT_10034610 == 0) {
    MessageBoxA((HWND)0x0,s_ERROR_Handler_has_not_been_start_100273fc,s_Error__10027424,0x10030);
    return;
  }
  if (DAT_10034618 != 0) {
    if ((DAT_10034618 & 0xd) != 0) {
      printf_wrapper(&DAT_117640e0,s_MESSAGE___s_10027438,message);
      logEvent(&DAT_117640e0,(byte)DAT_10034618,1);
    }
    if ((DAT_10034618 & 2) != 0) {
      MessageBoxA((HWND)0x0,message,s_Message__1002742c,0x1030);
    }
  }
  return;
}



// Setting prototype: void logMessage(LPCSTR file, int line, LPCSTR message, int log_type)

void __cdecl logMessage(LPCSTR file,int line,LPCSTR message,int log_type)

{
  DWORD time;
  
                    // This function logs a message with file and line number information.
  if (DAT_10034610 == 0) {
    MessageBoxA((HWND)0x0,s_ERROR_Handler_has_not_been_start_100273fc,s_Error__10027424,0x10030);
    return;
  }
  if ((DAT_10034618 & 1) != 0) {
    if ((DAT_10034618 & 0x20) == 0) {
      printf_wrapper(&DAT_117640e0,s_tModule___s___Line__lu___s_10027448,file,line,message);
    }
    else {
      time = timeGetTime();
      printf_wrapper(&DAT_117640e0,s_Time__8lu_Module___s___Line__lu__10027464,time);
    }
    logEvent(&DAT_117640e0,(byte)DAT_10034618,log_type);
  }
  return;
}



// Setting prototype: void parseGzipHeader(void *strm)

void __cdecl zlib_parseGzipHeader(void *strm)

{
  uint32_t byte;
  uint32_t uVar1;
  uint32_t uVar2;
  int iVar3;
  uint32_t *puVar4;
  
                    // This function parses a GZIP header from the input stream. strm is a pointer
                    // to a z_stream structure.
  iVar3 = 0;
  puVar4 = &DAT_10027488;
  do {
    byte = zlib_getByte(strm);
    if (byte != *puVar4) {
      if (iVar3 != 0) {
                    // WARNING: Load size is inaccurate
        *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + 1;
        *(int *)strm = *strm + -1;
      }
      if (byte != 0xffffffff) {
                    // WARNING: Load size is inaccurate
        *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + 1;
        *(int *)strm = *strm + -1;
        *(undefined4 *)((int)strm + 0x58) = 1;
      }
      *(uint *)((int)strm + 0x38) = (uint)(*(int *)((int)strm + 4) == 0);
      return;
    }
    puVar4 = puVar4 + 1;
    iVar3 = iVar3 + 1;
  } while (puVar4 < g_zlib_version_string);
  byte = zlib_getByte(strm);
  uVar1 = zlib_getByte(strm);
  if ((byte != 8) || ((uVar1 & 0xe0) != 0)) {
    *(undefined4 *)((int)strm + 0x38) = 0xfffffffd;
    return;
  }
  iVar3 = 6;
  do {
    zlib_getByte(strm);
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  if ((uVar1 & 4) != 0) {
    byte = zlib_getByte(strm);
    uVar2 = zlib_getByte(strm);
    iVar3 = byte + uVar2 * 0x100;
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      byte = zlib_getByte(strm);
    } while (byte != 0xffffffff);
  }
  if ((uVar1 & 8) != 0) {
    byte = zlib_getByte(strm);
    while ((byte != 0 && (byte != 0xffffffff))) {
      byte = zlib_getByte(strm);
    }
  }
  if ((uVar1 & 0x10) != 0) {
    byte = zlib_getByte(strm);
    while ((byte != 0 && (byte != 0xffffffff))) {
      byte = zlib_getByte(strm);
    }
  }
  if ((uVar1 & 2) != 0) {
    iVar3 = 2;
    do {
      zlib_getByte(strm);
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
  }
  *(uint *)((int)strm + 0x38) = -(uint)(*(int *)((int)strm + 0x3c) != 0) & 0xfffffffd;
  return;
}



// Setting prototype: uint32_t getByte(void *strm)

uint32_t __cdecl zlib_getByte(void *strm)

{
  undefined4 *puVar1;
  uint32_t uVar2;
  byte byte;
  
                    // This function reads a single byte from the input stream.
  if (*(int *)((int)strm + 0x3c) != 0) {
    return 0xffffffff;
  }
  if (*(int *)((int)strm + 4) == 0) {
    puVar1 = (undefined4 *)get_last_error();
    *puVar1 = 0;
    uVar2 = file_read_3(*(void **)((int)strm + 0x44),1,0x4000,*(void **)((int)strm + 0x40));
    *(uint32_t *)((int)strm + 4) = uVar2;
    if (uVar2 == 0) {
      *(undefined4 *)((int)strm + 0x3c) = 1;
      if ((*(byte *)(*(int *)((int)strm + 0x40) + 0xc) & 0x20) == 0) {
        return 0xffffffff;
      }
      *(undefined4 *)((int)strm + 0x38) = 0xffffffff;
      return 0xffffffff;
    }
    *(undefined4 *)strm = *(undefined4 *)((int)strm + 0x44);
  }
  *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
                    // WARNING: Load size is inaccurate
  byte = **strm;
  *(byte **)strm = *strm + 1;
  return (uint)byte;
}



// Setting prototype: uint32_t closeFile(void *file_handle)

uint32_t __cdecl zlib_closeFile(void *file_handle)

{
  int close_result;
  int *piVar1;
  uint32_t uVar2;
  
                    // This function closes a file handle and frees associated memory, handling both
                    // compressed and uncompressed files.
  uVar2 = 0;
  if (file_handle != (void *)0x0) {
    if (*(void **)((int)file_handle + 0x50) != (void *)0x0) {
      free_memory(*(void **)((int)file_handle + 0x50));
    }
    if (*(int *)((int)file_handle + 0x1c) != 0) {
      if (*(char *)((int)file_handle + 0x5c) == 'w') {
        uVar2 = zlib_deflateEnd(file_handle);
      }
      else if (*(char *)((int)file_handle + 0x5c) == 'r') {
        uVar2 = zlib_inflate_blocks_free(file_handle);
      }
    }
    if (((*(void **)((int)file_handle + 0x40) != (void *)0x0) &&
        (close_result = fclose_wrapper(*(void **)((int)file_handle + 0x40)), close_result != 0)) &&
       (piVar1 = (int *)get_last_error(), *piVar1 != 0x1d)) {
      uVar2 = 0xffffffff;
    }
    if ((int)*(uint32_t *)((int)file_handle + 0x38) < 0) {
      uVar2 = *(uint32_t *)((int)file_handle + 0x38);
    }
    if (*(void **)((int)file_handle + 0x44) != (void *)0x0) {
      free_memory(*(void **)((int)file_handle + 0x44));
    }
    if (*(void **)((int)file_handle + 0x48) != (void *)0x0) {
      free_memory(*(void **)((int)file_handle + 0x48));
    }
    if (*(void **)((int)file_handle + 0x54) != (void *)0x0) {
      free_memory(*(void **)((int)file_handle + 0x54));
    }
    free_memory(file_handle);
    return uVar2;
  }
  return 0xfffffffe;
}



// Setting prototype: int readFromStream(void *strm, byte *buffer, int length)

int __cdecl zlib_readFromStream(void *strm,byte *buffer,int length)

{
  undefined4 uVar1;
  undefined4 *puVar2;
  uint32_t uVar3;
  int iVar4;
  uint uVar5;
  uint crc;
  byte *buf;
  undefined4 *puVar6;
  byte *start;
  undefined4 total_in;
  
                    // This function reads from a stream, handling both compressed and uncompressed
                    // data.
  if ((strm == (void *)0x0) || (*(char *)((int)strm + 0x5c) != 'r')) {
    return -2;
  }
  iVar4 = *(int *)((int)strm + 0x38);
  if ((iVar4 == -3) || (iVar4 == -1)) {
    return -1;
  }
  if (iVar4 == 1) {
    return 0;
  }
  start = buffer;
  *(byte **)((int)strm + 0xc) = buffer;
  *(int *)((int)strm + 0x10) = length;
  buf = buffer;
  if (length == 0) {
LAB_10003b58:
    uVar3 = zlib_crc32(*(uint32_t *)((int)strm + 0x4c),buf,*(int *)((int)strm + 0xc) - (int)buf);
    *(uint32_t *)((int)strm + 0x4c) = uVar3;
    return length - *(int *)((int)strm + 0x10);
  }
  do {
    uVar5 = *(uint *)((int)strm + 4);
    if (*(int *)((int)strm + 0x58) != 0) {
      if (*(uint *)((int)strm + 0x10) < uVar5) {
        uVar5 = *(uint *)((int)strm + 0x10);
      }
      if (uVar5 != 0) {
                    // WARNING: Load size is inaccurate
        puVar2 = *strm;
        puVar6 = *(undefined4 **)((int)strm + 0xc);
        for (crc = uVar5 >> 2; crc != 0; crc = crc - 1) {
          *puVar6 = *puVar2;
          puVar2 = puVar2 + 1;
          puVar6 = puVar6 + 1;
        }
        for (crc = uVar5 & 3; crc != 0; crc = crc - 1) {
          *(undefined1 *)puVar6 = *(undefined1 *)puVar2;
          puVar2 = (undefined4 *)((int)puVar2 + 1);
          puVar6 = (undefined4 *)((int)puVar6 + 1);
        }
                    // WARNING: Load size is inaccurate
        start = buffer + uVar5;
        *(byte **)((int)strm + 0xc) = start;
        *(uint *)strm = *strm + uVar5;
        *(uint *)((int)strm + 0x10) = *(int *)((int)strm + 0x10) - uVar5;
        *(uint *)((int)strm + 4) = *(int *)((int)strm + 4) - uVar5;
      }
      if (*(uint32_t *)((int)strm + 0x10) != 0) {
        uVar3 = file_read_3(start,1,*(uint32_t *)((int)strm + 0x10),*(void **)((int)strm + 0x40));
        *(uint32_t *)((int)strm + 0x10) = *(int *)((int)strm + 0x10) - uVar3;
      }
      iVar4 = length - *(int *)((int)strm + 0x10);
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + iVar4;
      *(int *)((int)strm + 0x14) = *(int *)((int)strm + 0x14) + iVar4;
      if (iVar4 == 0) {
        *(undefined4 *)((int)strm + 0x3c) = 1;
      }
      return iVar4;
    }
    if ((uVar5 == 0) && (*(int *)((int)strm + 0x3c) == 0)) {
      puVar2 = (undefined4 *)get_last_error();
      *puVar2 = 0;
      uVar3 = file_read_3(*(void **)((int)strm + 0x44),1,0x4000,*(void **)((int)strm + 0x40));
      *(uint32_t *)((int)strm + 4) = uVar3;
      if ((uVar3 == 0) &&
         (*(undefined4 *)((int)strm + 0x3c) = 1,
         (*(byte *)(*(int *)((int)strm + 0x40) + 0xc) & 0x20) != 0)) {
        *(undefined4 *)((int)strm + 0x38) = 0xffffffff;
        goto LAB_10003b58;
      }
      *(undefined4 *)strm = *(undefined4 *)((int)strm + 0x44);
    }
    iVar4 = zlib_inflate_blocks(strm,0);
    *(int *)((int)strm + 0x38) = iVar4;
    if (iVar4 == 1) {
      uVar3 = zlib_crc32(*(uint32_t *)((int)strm + 0x4c),buf,*(int *)((int)strm + 0xc) - (int)buf);
      *(uint32_t *)((int)strm + 0x4c) = uVar3;
      buf = *(byte **)((int)strm + 0xc);
      uVar3 = zlib_getLong(strm);
      if (uVar3 == *(uint32_t *)((int)strm + 0x4c)) {
        zlib_getLong(strm);
        zlib_parseGzipHeader(strm);
        if (*(int *)((int)strm + 0x38) == 0) {
          uVar1 = *(undefined4 *)((int)strm + 8);
          total_in = *(undefined4 *)((int)strm + 0x14);
          zlib_inflate_blocks_reset(strm);
          *(undefined4 *)((int)strm + 8) = uVar1;
          *(undefined4 *)((int)strm + 0x14) = total_in;
          uVar3 = zlib_crc32(0,(byte *)0x0,0);
          *(uint32_t *)((int)strm + 0x4c) = uVar3;
        }
      }
      else {
        *(undefined4 *)((int)strm + 0x38) = 0xfffffffd;
      }
    }
    if (((*(int *)((int)strm + 0x38) != 0) || (*(int *)((int)strm + 0x3c) != 0)) ||
       (*(int *)((int)strm + 0x10) == 0)) goto LAB_10003b58;
  } while( true );
}



// Setting prototype: uint32_t writeToStream(void *strm, int flush)

uint32_t __cdecl zlib_writeToStream(void *strm,int flush)

{
  uint32_t uVar1;
  int iVar2;
  uint32_t element_count;
  bool done;
  
                    // This function writes to a stream, handling compression.
  done = false;
  if ((strm == (void *)0x0) || (*(char *)((int)strm + 0x5c) != 'w')) {
    return 0xfffffffe;
  }
  *(undefined4 *)((int)strm + 4) = 0;
  do {
    element_count = 0x4000 - *(int *)((int)strm + 0x10);
    if (element_count != 0) {
      uVar1 = file_write(*(void **)((int)strm + 0x48),1,element_count,*(void **)((int)strm + 0x40));
      if (uVar1 != element_count) {
        *(undefined4 *)((int)strm + 0x38) = 0xffffffff;
        return 0xffffffff;
      }
      *(undefined4 *)((int)strm + 0x10) = 0x4000;
      *(undefined4 *)((int)strm + 0xc) = *(undefined4 *)((int)strm + 0x48);
    }
    if (done) break;
    iVar2 = zlib_deflate(strm,flush);
    *(int *)((int)strm + 0x38) = iVar2;
    if ((element_count == 0) && (iVar2 == -5)) {
      *(undefined4 *)((int)strm + 0x38) = 0;
    }
    if ((*(int *)((int)strm + 0x10) == 0) && (*(int *)((int)strm + 0x38) != 1)) {
      done = false;
    }
    else {
      done = true;
    }
  } while ((*(int *)((int)strm + 0x38) == 0) || (*(int *)((int)strm + 0x38) == 1));
  return -(uint)(*(uint *)((int)strm + 0x38) != 1) & *(uint *)((int)strm + 0x38);
}



// Setting prototype: uint32_t getLong(void *strm)

uint32_t __cdecl zlib_getLong(void *strm)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  
                    // This function reads a 32-bit little-endian integer from the stream.
  uVar1 = zlib_getByte(strm);
  uVar2 = zlib_getByte(strm);
  uVar3 = zlib_getByte(strm);
  uVar4 = zlib_getByte(strm);
  if (uVar4 == 0xffffffff) {
    *(undefined4 *)((int)strm + 0x38) = 0xfffffffd;
  }
  return uVar4 * 0x1000000 + uVar1 + uVar2 * 0x100 + uVar3 * 0x10000;
}



// Setting prototype: uint32_t closeStream(void *strm)

uint32_t __cdecl zlib_closeStream(void *strm)

{
  uint32_t uVar1;
  
                    // This function closes a stream, flushing any pending data.
  if (strm == (void *)0x0) {
    return 0xfffffffe;
  }
  if (*(char *)((int)strm + 0x5c) == 'w') {
    uVar1 = zlib_writeToStream(strm,4);
    if (uVar1 == 0) {
      zlib_putLong(*(void **)((int)strm + 0x40),*(uint32_t *)((int)strm + 0x4c));
      zlib_putLong(*(void **)((int)strm + 0x40),*(uint32_t *)((int)strm + 8));
    }
  }
  uVar1 = zlib_closeFile(strm);
  return uVar1;
}



// Setting prototype: void putLong(void *file_handle, uint32_t value)

void __cdecl zlib_putLong(void *file_handle,uint32_t value)

{
  int i;
  
                    // This function writes a 32-bit little-endian integer to a file.
  i = 4;
  do {
    file_putc(value & 0xff,file_handle);
    value = value >> 8;
    i = i + -1;
  } while (i != 0);
  return;
}



// Setting prototype: int inflateReset(void *strm)

int __cdecl zlib_inflateReset(void *strm)

{
  code *ret;
  void *in_stack_00000008;
  undefined4 *in_stack_0000000c;
  
                    // strm is a pointer to a z_stream structure.
  if (in_stack_0000000c != (undefined4 *)0x0) {
    *in_stack_0000000c = *(undefined4 *)((int)strm + 0x3c);
  }
                    // WARNING: Load size is inaccurate
  if ((*strm == 4) || (*strm == 5)) {
    (**(code **)((int)in_stack_00000008 + 0x24))
              (*(undefined4 *)((int)in_stack_00000008 + 0x28),*(undefined4 *)((int)strm + 0xc));
  }
                    // WARNING: Load size is inaccurate
  if (*strm == 6) {
    zlib_inflate_trees_free(*(void **)((int)strm + 4),in_stack_00000008);
  }
  *(undefined4 *)strm = 0;
  *(undefined4 *)((int)strm + 0x34) = *(undefined4 *)((int)strm + 0x28);
  *(undefined4 *)((int)strm + 0x30) = *(undefined4 *)((int)strm + 0x28);
  ret = *(code **)((int)strm + 0x38);
  *(undefined4 *)((int)strm + 0x1c) = 0;
  *(undefined4 *)((int)strm + 0x20) = 0;
  if (ret != (code *)0x0) {
    ret = (code *)(*ret)(0,0,0);
    *(code **)((int)strm + 0x3c) = ret;
    *(code **)((int)in_stack_00000008 + 0x30) = ret;
  }
  return (int)ret;
}



// Setting prototype: int inflateInit2_(void *strm, int windowBits, char *version, int stream_size)

int zlib_inflateInit2_(void *strm,int windowBits,char *version,int stream_size)

{
  undefined4 *strm_00;
  int iVar1;
  
                    // strm is a pointer to a z_stream structure.
  strm_00 = (undefined4 *)(**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),1,0x40);
  if (strm_00 == (undefined4 *)0x0) {
    return 0;
  }
  iVar1 = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),8,0x5a0);
  strm_00[9] = iVar1;
  if (iVar1 == 0) {
    (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),strm_00);
    return 0;
  }
  iVar1 = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),1,version);
  strm_00[10] = iVar1;
  if (iVar1 == 0) {
    (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),strm_00[9]);
    (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),strm_00);
    return 0;
  }
  strm_00[0xb] = version + iVar1;
  strm_00[0xe] = windowBits;
  *strm_00 = 0;
  zlib_inflateReset(strm_00);
  return (int)strm_00;
}



// Setting prototype: int inflate(void *strm, int flush)

int zlib_inflate(void *strm,int flush)

{
  byte bVar1;
  void *pvVar2;
  void *pvVar3;
  int iVar4;
  void *s;
  uint uVar5;
  uint32_t uVar6;
  int iVar7;
  undefined4 uVar8;
  void *pvVar9;
  byte *pbVar10;
  byte *pbVar11;
  uint uVar12;
  int in_stack_0000000c;
  byte *local_30;
  uint local_2c;
  uint local_28;
  uint32_t local_24;
  void *local_20;
  uint32_t local_1c;
  uint32_t local_18;
  uint32_t local_14;
  void *local_10;
  uint local_c;
  uint32_t local_8;
  uint32_t local_4;
  
                    // strm is a pointer to a z_stream structure.
  s = strm;
  local_30 = *(byte **)flush;
  local_2c = *(uint *)(flush + 4);
  local_28 = *(uint *)((int)strm + 0x20);
  pvVar9 = *(void **)((int)strm + 0x1c);
  pvVar2 = *(void **)((int)strm + 0x34);
  if (pvVar2 < *(void **)((int)strm + 0x30)) {
    local_24 = (int)*(void **)((int)strm + 0x30) + (-1 - (int)pvVar2);
    strm = pvVar2;
  }
  else {
    local_24 = *(int *)((int)strm + 0x2c) - (int)pvVar2;
    strm = pvVar2;
  }
switchD_10003ef1_default:
                    // WARNING: Load size is inaccurate
  uVar12 = local_28;
  switch(*s) {
  case 0:
    goto switchD_10003e8d_caseD_0;
  case 1:
    for (; pvVar9 < (void *)0x20; pvVar9 = (void *)((int)pvVar9 + 8)) {
      if (local_2c == 0) {
        *(uint *)((int)s + 0x20) = local_28;
        *(void **)((int)s + 0x1c) = pvVar9;
        iVar7 = *(int *)flush;
        *(undefined4 *)(flush + 4) = 0;
        *(byte **)flush = local_30;
        *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
        *(void **)((int)s + 0x34) = strm;
        iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
        return iVar7;
      }
      in_stack_0000000c = 0;
      local_2c = local_2c - 1;
      local_28 = local_28 | (uint)*local_30 << ((byte)pvVar9 & 0x1f);
      local_30 = local_30 + 1;
    }
    uVar12 = local_28 & 0xffff;
    if (~local_28 >> 0x10 != uVar12) {
      *(undefined4 *)s = 9;
      *(char **)(flush + 0x18) = s_invalid_stored_block_lengths_100274d0;
      *(uint *)((int)s + 0x20) = local_28;
      *(void **)((int)s + 0x1c) = pvVar9;
      iVar7 = *(int *)flush;
      *(byte **)flush = local_30;
      *(uint *)(flush + 4) = local_2c;
      *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,-3);
      return iVar7;
    }
    pvVar9 = (void *)0x0;
    *(uint *)((int)s + 4) = uVar12;
    local_28 = 0;
    if (uVar12 != 0) {
      *(undefined4 *)s = 2;
      goto switchD_10003ef1_default;
    }
    break;
  case 2:
    if (local_2c == 0) {
      *(uint *)((int)s + 0x20) = local_28;
      *(void **)((int)s + 0x1c) = pvVar9;
      iVar7 = *(int *)flush;
      *(byte **)flush = local_30;
      *(undefined4 *)(flush + 4) = 0;
      *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
      return iVar7;
    }
    if (local_24 == 0) {
      if (strm == *(void **)((int)s + 0x2c)) {
        pvVar2 = *(void **)((int)s + 0x30);
        pvVar3 = *(void **)((int)s + 0x28);
        if (pvVar2 != pvVar3) {
          if (pvVar3 < pvVar2) {
            local_24 = (int)pvVar2 + (-1 - (int)pvVar3);
          }
          else {
            local_24 = (int)*(void **)((int)s + 0x2c) - (int)pvVar3;
          }
          strm = pvVar3;
          if (local_24 != 0) goto LAB_100040b6;
        }
      }
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
      strm = *(void **)((int)s + 0x34);
      pvVar2 = *(void **)((int)s + 0x30);
      if (strm < pvVar2) {
        local_24 = (int)pvVar2 + (-1 - (int)strm);
      }
      else {
        local_24 = *(int *)((int)s + 0x2c) - (int)strm;
      }
      local_20 = *(void **)((int)s + 0x2c);
      if ((strm == local_20) && (pvVar3 = *(void **)((int)s + 0x28), pvVar2 != pvVar3)) {
        strm = pvVar3;
        if (pvVar3 < pvVar2) {
          local_24 = (int)pvVar2 + (-1 - (int)pvVar3);
        }
        else {
          local_24 = (int)local_20 - (int)pvVar3;
        }
      }
      if (local_24 == 0) {
        *(uint *)((int)s + 0x20) = local_28;
        *(void **)((int)s + 0x1c) = pvVar9;
        iVar4 = *(int *)flush;
        *(uint *)(flush + 4) = local_2c;
        *(byte **)flush = local_30;
        *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar4);
        *(void **)((int)s + 0x34) = strm;
        iVar7 = zlib_inflate_flush(s,(void *)flush,iVar7);
        return iVar7;
      }
    }
LAB_100040b6:
    in_stack_0000000c = 0;
    uVar12 = *(uint *)((int)s + 4);
    if (local_2c < *(uint *)((int)s + 4)) {
      uVar12 = local_2c;
    }
    if (local_24 < uVar12) {
      uVar12 = local_24;
    }
    pbVar10 = local_30;
    pbVar11 = (byte *)strm;
    for (uVar5 = uVar12 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
      *(undefined4 *)pbVar11 = *(undefined4 *)pbVar10;
      pbVar10 = pbVar10 + 4;
      pbVar11 = pbVar11 + 4;
    }
    local_24 = local_24 - uVar12;
    for (uVar5 = uVar12 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
      *pbVar11 = *pbVar10;
      pbVar10 = pbVar10 + 1;
      pbVar11 = pbVar11 + 1;
    }
    local_30 = local_30 + uVar12;
    local_2c = local_2c - uVar12;
    strm = (void *)((int)strm + uVar12);
    iVar7 = *(int *)((int)s + 4) - uVar12;
    *(int *)((int)s + 4) = iVar7;
    if (iVar7 != 0) goto switchD_10003ef1_default;
    break;
  case 3:
    for (; pvVar9 < (void *)0xe; pvVar9 = (void *)((int)pvVar9 + 8)) {
      if (local_2c == 0) {
        *(uint *)((int)s + 0x20) = local_28;
        *(void **)((int)s + 0x1c) = pvVar9;
        iVar7 = *(int *)flush;
        *(byte **)flush = local_30;
        *(undefined4 *)(flush + 4) = 0;
        *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
        *(void **)((int)s + 0x34) = strm;
        iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
        return iVar7;
      }
      local_2c = local_2c - 1;
      in_stack_0000000c = 0;
      local_28 = local_28 | (uint)*local_30 << ((byte)pvVar9 & 0x1f);
      local_30 = local_30 + 1;
    }
    *(uint *)((int)s + 4) = local_28 & 0x3fff;
    if ((0x1d < (local_28 & 0x1f)) || (0x3a0 < (local_28 & 0x3e0))) {
      *(undefined4 *)s = 9;
      *(char **)(flush + 0x18) = s_too_many_length_or_distance_symb_100274ac;
      *(uint *)((int)s + 0x20) = local_28;
      *(void **)((int)s + 0x1c) = pvVar9;
      iVar7 = *(int *)flush;
      *(uint *)(flush + 4) = local_2c;
      *(byte **)flush = local_30;
      *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,-3);
      return iVar7;
    }
    iVar7 = (**(code **)(flush + 0x20))
                      (*(undefined4 *)(flush + 0x28),
                       ((local_28 & 0x3fff) >> 5 & 0x1f) + 0x102 + (local_28 & 0x1f),4);
    *(int *)((int)s + 0xc) = iVar7;
    if (iVar7 == 0) {
      *(uint *)((int)s + 0x20) = local_28;
      *(void **)((int)s + 0x1c) = pvVar9;
      iVar7 = *(int *)flush;
      *(uint *)(flush + 4) = local_2c;
      *(byte **)flush = local_30;
      *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,-4);
      return iVar7;
    }
    local_28 = local_28 >> 0xe;
    pvVar9 = (void *)((int)pvVar9 - 0xe);
    *(undefined4 *)((int)s + 8) = 0;
    *(undefined4 *)s = 4;
    goto LAB_100041dd;
  case 4:
LAB_100041dd:
    if (*(uint *)((int)s + 8) < (*(uint *)((int)s + 4) >> 10) + 4) {
      do {
        for (; pvVar9 < (void *)0x3; pvVar9 = (void *)((int)pvVar9 + 8)) {
          if (local_2c == 0) {
            *(uint *)((int)s + 0x20) = local_28;
            *(void **)((int)s + 0x1c) = pvVar9;
            iVar7 = *(int *)flush;
            *(byte **)flush = local_30;
            *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
            *(undefined4 *)(flush + 4) = 0;
            *(void **)((int)s + 0x34) = strm;
            iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
            return iVar7;
          }
          local_2c = local_2c - 1;
          in_stack_0000000c = 0;
          local_28 = local_28 | (uint)*local_30 << ((byte)pvVar9 & 0x1f);
          local_30 = local_30 + 1;
        }
        uVar12 = local_28 & 7;
        pvVar9 = (void *)((int)pvVar9 - 3);
        local_28 = local_28 >> 3;
        *(uint *)(*(int *)((int)s + 0xc) + *(int *)(&DAT_10024650 + *(int *)((int)s + 8) * 4) * 4) =
             uVar12;
        uVar12 = *(int *)((int)s + 8) + 1;
        *(uint *)((int)s + 8) = uVar12;
      } while (uVar12 < (*(uint *)((int)s + 4) >> 10) + 4);
    }
    uVar12 = *(uint *)((int)s + 8);
    while (uVar12 < 0x13) {
      *(undefined4 *)
       (*(int *)((int)s + 0xc) + *(int *)(&DAT_10024650 + *(int *)((int)s + 8) * 4) * 4) = 0;
      uVar12 = *(int *)((int)s + 8) + 1;
      *(uint *)((int)s + 8) = uVar12;
    }
    *(void **)((int)s + 0x10) = (void *)0x7;
    iVar7 = zlib_inflate_trees_dynamic
                      (*(void **)((int)s + 0xc),(void **)((int)s + 0x10),(void **)((int)s + 0x14),
                       *(void ***)((int)s + 0x24),(void *)flush);
    uVar12 = local_28;
    if (iVar7 == 0) {
      *(undefined4 *)((int)s + 8) = 0;
      *(undefined4 *)s = 5;
LAB_100042c6:
      if (*(uint *)((int)s + 8) <
          (*(uint *)((int)s + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)s + 4) & 0x1f)) {
        do {
          for (; pvVar9 < *(void **)((int)s + 0x10); pvVar9 = (void *)((int)pvVar9 + 8)) {
            if (local_2c == 0) goto LAB_100048a9;
            local_2c = local_2c - 1;
            in_stack_0000000c = 0;
            uVar12 = uVar12 | (uint)*local_30 << ((byte)pvVar9 & 0x1f);
            local_30 = local_30 + 1;
          }
          bVar1 = *(byte *)(*(int *)((int)s + 0x14) + 1 +
                           (*(uint *)(&DAT_100287a0 + (int)*(void **)((int)s + 0x10) * 4) & uVar12)
                           * 8);
          uVar5 = (uint)bVar1;
          local_c = *(uint *)(*(int *)((int)s + 0x14) +
                              (*(uint *)(&DAT_100287a0 + (int)*(void **)((int)s + 0x10) * 4) &
                              uVar12) * 8 + 4);
          if (local_c < 0x10) {
            pvVar9 = (void *)((int)pvVar9 - uVar5);
            uVar12 = uVar12 >> (bVar1 & 0x1f);
            *(uint *)(*(int *)((int)s + 0xc) + *(int *)((int)s + 8) * 4) = local_c;
            uVar5 = *(int *)((int)s + 8) + 1;
          }
          else {
            local_24 = 7;
            if (local_c != 0x12) {
              local_24 = local_c - 0xe;
            }
            local_20 = (void *)(local_24 + uVar5);
            for (; pvVar9 < local_20; pvVar9 = (void *)((int)pvVar9 + 8)) {
              if (local_2c == 0) {
LAB_100048a9:
                *(uint *)((int)s + 0x20) = uVar12;
                *(void **)((int)s + 0x1c) = pvVar9;
                iVar7 = *(int *)flush;
                *(byte **)flush = local_30;
                *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
                *(undefined4 *)(flush + 4) = 0;
                *(void **)((int)s + 0x34) = strm;
                iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
                return iVar7;
              }
              local_2c = local_2c - 1;
              in_stack_0000000c = 0;
              uVar12 = uVar12 | (uint)*local_30 << ((byte)pvVar9 & 0x1f);
              local_30 = local_30 + 1;
            }
            uVar12 = uVar12 >> (bVar1 & 0x1f);
            local_28 = (-(uint)(local_c != 0x12) & 0xfffffff8) + 0xb +
                       (*(uint *)(&DAT_100287a0 + local_24 * 4) & uVar12);
            uVar12 = uVar12 >> ((byte)local_24 & 0x1f);
            pvVar9 = (void *)((int)pvVar9 - (local_24 + uVar5));
            local_24 = *(uint *)((int)s + 8);
            if ((*(uint *)((int)s + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)s + 4) & 0x1f) <
                local_28 + local_24) {
LAB_100048e8:
              (**(code **)(flush + 0x24))
                        (*(undefined4 *)(flush + 0x28),*(undefined4 *)((int)s + 0xc));
              *(undefined4 *)s = 9;
              *(char **)(flush + 0x18) = g_zlib_version_string;
              *(uint *)((int)s + 0x20) = uVar12;
              *(void **)((int)s + 0x1c) = pvVar9;
              iVar7 = *(int *)flush;
              *(uint *)(flush + 4) = local_2c;
              *(byte **)flush = local_30;
              *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
              *(void **)((int)s + 0x34) = strm;
              iVar7 = zlib_inflate_flush(s,(void *)flush,-3);
              return iVar7;
            }
            uVar5 = local_24;
            if (local_c == 0x10) {
              if (local_24 == 0) goto LAB_100048e8;
              uVar8 = *(undefined4 *)(*(int *)((int)s + 0xc) + -4 + local_24 * 4);
            }
            else {
              uVar8 = 0;
            }
            do {
              uVar5 = uVar5 + 1;
              *(undefined4 *)(*(int *)((int)s + 0xc) + -4 + uVar5 * 4) = uVar8;
              local_28 = local_28 + -1;
            } while (local_28 != 0);
          }
          *(uint *)((int)s + 8) = uVar5;
        } while (*(uint *)((int)s + 8) <
                 (*(uint *)((int)s + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)s + 4) & 0x1f));
      }
      *(undefined4 *)((int)s + 0x14) = 0;
      local_20 = (void *)0x9;
      local_24 = 6;
      local_28 = zlib_inflate_trees_bits
                           ((*(uint *)((int)s + 4) & 0x1f) + 0x101,
                            (*(uint *)((int)s + 4) >> 5 & 0x1f) + 1,*(int **)((int)s + 0xc),
                            (uint32_t *)&local_20,&local_24,&local_4,&local_8,
                            *(void **)((int)s + 0x24),(void *)flush);
      (**(code **)(flush + 0x24))(*(undefined4 *)(flush + 0x28),*(undefined4 *)((int)s + 0xc));
      if (local_28 == 0) {
        uVar6 = local_24;
        zlib_tr_init(local_20,(uint8_t)local_24,local_4,local_8,(void *)flush);
        if (uVar6 == 0) {
          *(uint *)((int)s + 0x20) = uVar12;
          *(void **)((int)s + 0x1c) = pvVar9;
          *(uint *)(flush + 4) = local_2c;
          *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - *(int *)flush);
          *(byte **)flush = local_30;
          *(void **)((int)s + 0x34) = strm;
          iVar7 = zlib_inflate_flush(s,(void *)flush,-4);
          return iVar7;
        }
        *(uint32_t *)((int)s + 4) = uVar6;
        *(undefined4 *)s = 6;
LAB_10004516:
        *(uint *)((int)s + 0x20) = uVar12;
        *(void **)((int)s + 0x1c) = pvVar9;
        iVar7 = *(int *)flush;
        *(uint *)(flush + 4) = local_2c;
        *(byte **)flush = local_30;
        *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
        *(void **)((int)s + 0x34) = strm;
        iVar7 = zlib_inflate_codes(s,(void *)flush,in_stack_0000000c);
        if (iVar7 == 1) {
          in_stack_0000000c = 0;
          zlib_inflate_trees_free(*(void **)((int)s + 4),(void *)flush);
          local_28 = *(uint *)((int)s + 0x20);
          strm = *(void **)((int)s + 0x34);
          local_30 = *(byte **)flush;
          local_2c = *(uint *)(flush + 4);
          pvVar9 = *(void **)((int)s + 0x1c);
          if (strm < *(void **)((int)s + 0x30)) {
            local_24 = (int)*(void **)((int)s + 0x30) + (-1 - (int)strm);
          }
          else {
            local_24 = *(int *)((int)s + 0x2c) - (int)strm;
          }
          if (*(int *)((int)s + 0x18) == 0) {
            *(undefined4 *)s = 0;
            goto switchD_10003ef1_default;
          }
          *(undefined4 *)s = 7;
LAB_100049d8:
          *(void **)((int)s + 0x34) = strm;
          iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
          strm = *(void **)((int)s + 0x34);
          if (*(void **)((int)s + 0x30) == strm) {
            *(undefined4 *)s = 8;
LAB_10004a3f:
            *(uint *)((int)s + 0x20) = local_28;
            *(void **)((int)s + 0x1c) = pvVar9;
            *(uint *)(flush + 4) = local_2c;
            *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - *(int *)flush);
            *(byte **)flush = local_30;
            *(void **)((int)s + 0x34) = strm;
            iVar7 = zlib_inflate_flush(s,(void *)flush,1);
            return iVar7;
          }
          *(void **)((int)s + 0x1c) = pvVar9;
          *(uint *)((int)s + 0x20) = local_28;
          iVar4 = *(int *)flush;
          *(uint *)(flush + 4) = local_2c;
          *(byte **)flush = local_30;
          *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar4);
          *(void **)((int)s + 0x34) = strm;
        }
        iVar7 = zlib_inflate_flush(s,(void *)flush,iVar7);
        return iVar7;
      }
    }
    else {
      (**(code **)(flush + 0x24))(*(undefined4 *)(flush + 0x28),*(undefined4 *)((int)s + 0xc));
      local_28 = iVar7;
    }
    if (local_28 == -3) {
      *(undefined4 *)s = 9;
    }
    *(uint *)((int)s + 0x20) = uVar12;
    *(void **)((int)s + 0x1c) = pvVar9;
    iVar7 = *(int *)flush;
    *(uint *)(flush + 4) = local_2c;
    *(byte **)flush = local_30;
    *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
    *(void **)((int)s + 0x34) = strm;
    iVar7 = zlib_inflate_flush(s,(void *)flush,local_28);
    return iVar7;
  case 5:
    goto LAB_100042c6;
  case 6:
    goto LAB_10004516;
  case 7:
    goto LAB_100049d8;
  case 8:
    goto LAB_10004a3f;
  case 9:
    *(uint *)((int)s + 0x20) = local_28;
    *(void **)((int)s + 0x1c) = pvVar9;
    iVar7 = *(int *)flush;
    *(uint *)(flush + 4) = local_2c;
    *(byte **)flush = local_30;
    *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
    *(void **)((int)s + 0x34) = strm;
    iVar7 = zlib_inflate_flush(s,(void *)flush,-3);
    return iVar7;
  default:
    *(uint *)((int)s + 0x20) = local_28;
    *(void **)((int)s + 0x1c) = pvVar9;
    iVar7 = *(int *)flush;
    *(uint *)(flush + 4) = local_2c;
    *(byte **)flush = local_30;
    *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - iVar7);
    *(void **)((int)s + 0x34) = strm;
    iVar7 = zlib_inflate_flush(s,(void *)flush,-2);
    return iVar7;
  }
  *(uint *)s = -(uint)(*(int *)((int)s + 0x18) != 0) & 7;
  goto switchD_10003ef1_default;
switchD_10003e8d_caseD_0:
  for (; pvVar9 < (void *)0x3; pvVar9 = (void *)((int)pvVar9 + 8)) {
    if (local_2c == 0) {
      *(uint *)((int)s + 0x20) = local_28;
      *(void **)((int)s + 0x1c) = pvVar9;
      *(undefined4 *)(flush + 4) = 0;
      *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - *(int *)flush);
      *(byte **)flush = local_30;
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,in_stack_0000000c);
      return iVar7;
    }
    local_2c = local_2c - 1;
    in_stack_0000000c = 0;
    local_28 = local_28 | (uint)*local_30 << ((byte)pvVar9 & 0x1f);
    local_30 = local_30 + 1;
  }
  *(uint *)((int)s + 0x18) = local_28 & 1;
  switch((local_28 & 7) >> 1) {
  case 0:
    *(undefined4 *)s = 1;
    uVar12 = (int)pvVar9 - 3U & 7;
    local_28 = (local_28 >> 3) >> (sbyte)uVar12;
    pvVar9 = (void *)(((int)pvVar9 - 3U) - uVar12);
    break;
  case 1:
    zlib_inflate_trees_fixed((uint32_t *)&local_10,&local_14,&local_18,&local_1c);
    uVar6 = local_18;
    zlib_tr_init(local_10,(uint8_t)local_14,local_18,local_1c,(void *)flush);
    *(uint32_t *)((int)s + 4) = uVar6;
    if (uVar6 == 0) {
      *(uint *)((int)s + 0x20) = local_28;
      *(void **)((int)s + 0x1c) = pvVar9;
      *(uint *)(flush + 4) = local_2c;
      *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - *(int *)flush);
      *(byte **)flush = local_30;
      *(void **)((int)s + 0x34) = strm;
      iVar7 = zlib_inflate_flush(s,(void *)flush,-4);
      return iVar7;
    }
    local_28 = local_28 >> 3;
    pvVar9 = (void *)((int)pvVar9 - 3);
    *(undefined4 *)s = 6;
    break;
  case 2:
    local_28 = local_28 >> 3;
    pvVar9 = (void *)((int)pvVar9 - 3);
    *(undefined4 *)s = 3;
    break;
  case 3:
    *(undefined4 *)s = 9;
    *(char **)(flush + 0x18) = s_invalid_block_type_100274f0;
    *(uint *)((int)s + 0x20) = local_28 >> 3;
    *(uint *)((int)s + 0x1c) = (int)pvVar9 - 3;
    *(uint *)(flush + 4) = local_2c;
    *(byte **)(flush + 8) = local_30 + (*(int *)(flush + 8) - *(int *)flush);
    *(byte **)flush = local_30;
    *(void **)((int)s + 0x34) = strm;
    iVar7 = zlib_inflate_flush(s,(void *)flush,-3);
    return iVar7;
  }
  goto switchD_10003ef1_default;
}



// Setting prototype: int inflateEnd(void *strm)

int zlib_inflateEnd(void *strm)

{
  int in_stack_00000008;
  
                    // strm is a pointer to a z_stream structure.
  zlib_inflateReset(strm);
  (**(code **)(in_stack_00000008 + 0x24))
            (*(undefined4 *)(in_stack_00000008 + 0x28),*(undefined4 *)((int)strm + 0x28));
  (**(code **)(in_stack_00000008 + 0x24))
            (*(undefined4 *)(in_stack_00000008 + 0x28),*(undefined4 *)((int)strm + 0x24));
  (**(code **)(in_stack_00000008 + 0x24))(*(undefined4 *)(in_stack_00000008 + 0x28),strm);
  return 0;
}



// Setting prototype: void huffman_table_init(void *s, uint8_t param_2, uint32_t param_3, uint32_t
// param_4, void *strm)

void zlib_tr_init(void *s,uint8_t param_2,uint32_t param_3,uint32_t param_4,void *strm)

{
  undefined4 *puVar1;
  
                    // 
                    // Initializes a Huffman table structure.
                    // 
                    // Parameters:
                    //   s: Pointer to the Huffman table structure to initialize.
                    //   param_2: Unknown parameter, possibly related to table type or size.
                    //   param_3: Unknown parameter.
                    //   param_4: Unknown parameter.
                    //   strm: Pointer to the z_stream structure for memory allocation.
                    // 
  puVar1 = (undefined4 *)(**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),1,0x1c);
  if (puVar1 != (undefined4 *)0x0) {
    *(undefined1 *)(puVar1 + 4) = s._0_1_;
    *(uint8_t *)((int)puVar1 + 0x11) = param_2;
    *puVar1 = 0;
    puVar1[5] = param_3;
    puVar1[6] = param_4;
  }
  return;
}



// Setting prototype: int huffman_decode(void *s, void *strm, int flush)

int zlib_inflate_codes(void *s,void *strm,int flush)

{
  byte bVar1;
  int *piVar2;
  undefined1 *puVar3;
  void *s_00;
  void *strm_00;
  int iVar4;
  uint uVar5;
  undefined1 *puVar6;
  undefined1 *puVar7;
  uint uVar8;
  byte *pbVar9;
  undefined1 *local_c;
  byte *local_8;
  undefined1 *local_4;
  
  strm_00 = strm;
                    // 
                    // Performs Huffman decoding for the inflate algorithm.
                    // This function handles different states of the decoding process, including
                    // literal/length and distance codes.
                    // 
                    // Parameters:
                    //   s: Pointer to the inflate_state structure.
                    //   strm: Pointer to the z_stream structure.
                    //   flush: The flush mode.
                    // 
                    // Return values:
                    //   A status code indicating success or failure.
                    // 
  s_00 = s;
  piVar2 = *(int **)((int)s + 4);
                    // WARNING: Load size is inaccurate
  pbVar9 = *strm;
  uVar8 = *(uint *)((int)s + 0x1c);
  puVar7 = *(undefined1 **)((int)s + 0x34);
  if (puVar7 < *(undefined1 **)((int)s + 0x30)) {
    local_c = *(undefined1 **)((int)s + 0x30) + (-1 - (int)puVar7);
    s = *(void **)((int)s + 0x20);
    strm = *(void **)((int)strm + 4);
  }
  else {
    local_c = (undefined1 *)(*(int *)((int)s + 0x2c) - (int)puVar7);
    s = *(void **)((int)s + 0x20);
    strm = *(void **)((int)strm + 4);
  }
  do {
    switch(*piVar2) {
    case 0:
      if (((undefined1 *)0x101 < local_c) && ((void *)0x9 < strm)) {
        *(void **)((int)s_00 + 0x20) = s;
        *(uint *)((int)s_00 + 0x1c) = uVar8;
                    // WARNING: Load size is inaccurate
        iVar4 = *strm_00;
        *(void **)((int)strm_00 + 4) = strm;
        *(byte **)strm_00 = pbVar9;
        *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - iVar4);
        *(undefined1 **)((int)s_00 + 0x34) = puVar7;
        flush = zlib_inflate_fast((uint)*(byte *)(piVar2 + 4),(uint)*(byte *)((int)piVar2 + 0x11),
                                  (void *)piVar2[5],(void *)piVar2[6],s_00,strm_00);
        strm = *(void **)((int)strm_00 + 4);
        s = *(void **)((int)s_00 + 0x20);
                    // WARNING: Load size is inaccurate
        pbVar9 = *strm_00;
        uVar8 = *(uint *)((int)s_00 + 0x1c);
        puVar7 = *(undefined1 **)((int)s_00 + 0x34);
        if (puVar7 < *(undefined1 **)((int)s_00 + 0x30)) {
          local_c = *(undefined1 **)((int)s_00 + 0x30) + (-1 - (int)puVar7);
        }
        else {
          local_c = (undefined1 *)(*(int *)((int)s_00 + 0x2c) - (int)puVar7);
        }
        if (flush != 0) {
          *piVar2 = (-(uint)(flush != 1) & 2) + 7;
          break;
        }
      }
      *piVar2 = 1;
      piVar2[3] = (uint)*(byte *)(piVar2 + 4);
      piVar2[2] = piVar2[5];
    case 1:
      for (; uVar8 < (uint)piVar2[3]; uVar8 = uVar8 + 8) {
        if (strm == (void *)0x0) {
LAB_10005169:
          *(uint *)((int)s_00 + 0x1c) = uVar8;
          *(void **)((int)s_00 + 0x20) = s;
                    // WARNING: Load size is inaccurate
          iVar4 = *strm_00;
          *(undefined4 *)((int)strm_00 + 4) = 0;
          *(byte **)strm_00 = pbVar9;
          *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - iVar4);
          *(undefined1 **)((int)s_00 + 0x34) = puVar7;
          iVar4 = zlib_inflate_flush(s_00,strm_00,flush);
          return iVar4;
        }
        strm = (void *)((int)strm + -1);
        flush = 0;
        s = (void *)((uint)s | (uint)*pbVar9 << ((byte)uVar8 & 0x1f));
        pbVar9 = pbVar9 + 1;
      }
      local_8 = (byte *)(piVar2[2] + (*(uint *)(&DAT_100287a0 + piVar2[3] * 4) & (uint)s) * 8);
      s = (void *)((uint)s >> (local_8[1] & 0x1f));
      uVar8 = uVar8 - local_8[1];
      bVar1 = *local_8;
      uVar5 = (uint)bVar1;
      if (uVar5 == 0) {
        piVar2[2] = *(int *)(local_8 + 4);
        *piVar2 = 6;
      }
      else if ((bVar1 & 0x10) == 0) {
        if ((bVar1 & 0x40) == 0) {
LAB_10004d94:
          piVar2[3] = uVar5;
          piVar2[2] = (int)(local_8 + *(int *)(local_8 + 4) * 8);
        }
        else {
          if ((bVar1 & 0x20) == 0) {
            *piVar2 = 9;
            *(char **)((int)strm_00 + 0x18) = s_invalid_literal_length_code_1002751c;
LAB_100051b5:
            *(void **)((int)s_00 + 0x20) = s;
            *(uint *)((int)s_00 + 0x1c) = uVar8;
                    // WARNING: Load size is inaccurate
            *(void **)((int)strm_00 + 4) = strm;
            *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - *strm_00);
            *(byte **)strm_00 = pbVar9;
            *(undefined1 **)((int)s_00 + 0x34) = puVar7;
            iVar4 = zlib_inflate_flush(s_00,strm_00,-3);
            return iVar4;
          }
          *piVar2 = 7;
        }
      }
      else {
        piVar2[2] = bVar1 & 0xf;
        iVar4 = *(int *)(local_8 + 4);
        *piVar2 = 2;
        piVar2[1] = iVar4;
      }
      break;
    case 2:
      uVar5 = piVar2[2];
      for (; uVar8 < uVar5; uVar8 = uVar8 + 8) {
        if (strm == (void *)0x0) goto LAB_10005169;
        strm = (void *)((int)strm + -1);
        flush = 0;
        s = (void *)((uint)s | (uint)*pbVar9 << ((byte)uVar8 & 0x1f));
        pbVar9 = pbVar9 + 1;
      }
      piVar2[1] = piVar2[1] + (*(uint *)(&DAT_100287a0 + uVar5 * 4) & (uint)s);
      s = (void *)((uint)s >> ((byte)uVar5 & 0x1f));
      uVar8 = uVar8 - uVar5;
      *piVar2 = 3;
      piVar2[3] = (uint)*(byte *)((int)piVar2 + 0x11);
      piVar2[2] = piVar2[6];
    case 3:
      for (; uVar8 < (uint)piVar2[3]; uVar8 = uVar8 + 8) {
        if (strm == (void *)0x0) goto LAB_10005169;
        strm = (void *)((int)strm + -1);
        flush = 0;
        s = (void *)((uint)s | (uint)*pbVar9 << ((byte)uVar8 & 0x1f));
        pbVar9 = pbVar9 + 1;
      }
      local_8 = (byte *)(piVar2[2] + (*(uint *)(&DAT_100287a0 + piVar2[3] * 4) & (uint)s) * 8);
      s = (void *)((uint)s >> (local_8[1] & 0x1f));
      uVar8 = uVar8 - local_8[1];
      bVar1 = *local_8;
      uVar5 = (uint)bVar1;
      if ((bVar1 & 0x10) == 0) {
        if ((bVar1 & 0x40) != 0) {
          *piVar2 = 9;
          *(char **)((int)strm_00 + 0x18) = s_invalid_distance_code_10027504;
          goto LAB_100051b5;
        }
        goto LAB_10004d94;
      }
      piVar2[2] = bVar1 & 0xf;
      iVar4 = *(int *)(local_8 + 4);
      *piVar2 = 4;
      piVar2[3] = iVar4;
      break;
    case 4:
      uVar5 = piVar2[2];
      for (; uVar8 < uVar5; uVar8 = uVar8 + 8) {
        if (strm == (void *)0x0) goto LAB_10005169;
        strm = (void *)((int)strm + -1);
        flush = 0;
        s = (void *)((uint)s | (uint)*pbVar9 << ((byte)uVar8 & 0x1f));
        pbVar9 = pbVar9 + 1;
      }
      piVar2[3] = piVar2[3] + (*(uint *)(&DAT_100287a0 + uVar5 * 4) & (uint)s);
      s = (void *)((uint)s >> ((byte)uVar5 & 0x1f));
      uVar8 = uVar8 - uVar5;
      *piVar2 = 5;
    case 5:
      if ((uint)((int)puVar7 - *(int *)((int)s_00 + 0x28)) < (uint)piVar2[3]) {
        iVar4 = (*(int *)((int)s_00 + 0x2c) - *(int *)((int)s_00 + 0x28)) - piVar2[3];
      }
      else {
        iVar4 = -piVar2[3];
      }
      local_4 = puVar7 + iVar4;
      iVar4 = piVar2[1];
      while (iVar4 != 0) {
        puVar6 = puVar7;
        if (local_c == (undefined1 *)0x0) {
          if (puVar7 == *(undefined1 **)((int)s_00 + 0x2c)) {
            local_c = *(undefined1 **)((int)s_00 + 0x30);
            puVar6 = *(undefined1 **)((int)s_00 + 0x28);
            if (local_c != puVar6) {
              if (puVar6 < local_c) {
                local_c = local_c + (-1 - (int)puVar6);
              }
              else {
                local_c = *(undefined1 **)((int)s_00 + 0x2c) + -(int)puVar6;
              }
              puVar7 = puVar6;
              if (local_c != (undefined1 *)0x0) goto LAB_1000504b;
            }
          }
          *(undefined1 **)((int)s_00 + 0x34) = puVar7;
          flush = zlib_inflate_flush(s_00,strm_00,flush);
          puVar6 = *(undefined1 **)((int)s_00 + 0x34);
          puVar7 = *(undefined1 **)((int)s_00 + 0x30);
          if (puVar6 < puVar7) {
            local_c = puVar7 + (-1 - (int)puVar6);
          }
          else {
            local_c = (undefined1 *)(*(int *)((int)s_00 + 0x2c) - (int)puVar6);
          }
          if ((puVar6 == *(undefined1 **)((int)s_00 + 0x2c)) &&
             (puVar3 = *(undefined1 **)((int)s_00 + 0x28), puVar7 != puVar3)) {
            puVar6 = puVar3;
            if (puVar3 < puVar7) {
              local_c = puVar7 + (-1 - (int)puVar3);
            }
            else {
              local_c = *(undefined1 **)((int)s_00 + 0x2c) + -(int)puVar3;
            }
          }
          if (local_c == (undefined1 *)0x0) goto LAB_100051ed;
        }
LAB_1000504b:
        puVar7 = puVar6 + 1;
        flush = 0;
        *puVar6 = *local_4;
        local_4 = local_4 + 1;
        local_c = local_c + -1;
        if (local_4 == *(undefined1 **)((int)s_00 + 0x2c)) {
          local_4 = *(undefined1 **)((int)s_00 + 0x28);
        }
        iVar4 = piVar2[1] + -1;
        piVar2[1] = iVar4;
      }
      *piVar2 = 0;
      break;
    case 6:
      puVar6 = puVar7;
      if (local_c == (undefined1 *)0x0) {
        if (puVar7 == *(undefined1 **)((int)s_00 + 0x2c)) {
          local_c = *(undefined1 **)((int)s_00 + 0x30);
          puVar6 = *(undefined1 **)((int)s_00 + 0x28);
          if (local_c != puVar6) {
            if (puVar6 < local_c) {
              local_c = local_c + (-1 - (int)puVar6);
            }
            else {
              local_c = *(undefined1 **)((int)s_00 + 0x2c) + -(int)puVar6;
            }
            puVar7 = puVar6;
            if (local_c != (undefined1 *)0x0) goto LAB_10005138;
          }
        }
        *(undefined1 **)((int)s_00 + 0x34) = puVar7;
        flush = zlib_inflate_flush(s_00,strm_00,flush);
        puVar6 = *(undefined1 **)((int)s_00 + 0x34);
        puVar7 = *(undefined1 **)((int)s_00 + 0x30);
        if (puVar6 < puVar7) {
          local_c = puVar7 + (-1 - (int)puVar6);
        }
        else {
          local_c = (undefined1 *)(*(int *)((int)s_00 + 0x2c) - (int)puVar6);
        }
        if ((puVar6 == *(undefined1 **)((int)s_00 + 0x2c)) &&
           (puVar3 = *(undefined1 **)((int)s_00 + 0x28), puVar7 != puVar3)) {
          puVar6 = puVar3;
          if (puVar3 < puVar7) {
            local_c = puVar7 + (-1 - (int)puVar3);
          }
          else {
            local_c = *(undefined1 **)((int)s_00 + 0x2c) + -(int)puVar3;
          }
        }
        if (local_c == (undefined1 *)0x0) {
LAB_100051ed:
          *(void **)((int)s_00 + 0x20) = s;
          *(uint *)((int)s_00 + 0x1c) = uVar8;
                    // WARNING: Load size is inaccurate
          iVar4 = *strm_00;
          *(void **)((int)strm_00 + 4) = strm;
          *(byte **)strm_00 = pbVar9;
          *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - iVar4);
          *(undefined1 **)((int)s_00 + 0x34) = puVar6;
          iVar4 = zlib_inflate_flush(s_00,strm_00,flush);
          return iVar4;
        }
      }
LAB_10005138:
      flush = 0;
      *puVar6 = (char)piVar2[2];
      puVar7 = puVar6 + 1;
      local_c = local_c + -1;
      *piVar2 = 0;
      break;
    case 7:
      if (7 < uVar8) {
        uVar8 = uVar8 - 8;
        strm = (void *)((int)strm + 1);
        pbVar9 = pbVar9 + -1;
      }
      *(undefined1 **)((int)s_00 + 0x34) = puVar7;
      iVar4 = zlib_inflate_flush(s_00,strm_00,flush);
      puVar7 = *(undefined1 **)((int)s_00 + 0x34);
      if (*(undefined1 **)((int)s_00 + 0x30) != puVar7) {
        *(uint *)((int)s_00 + 0x1c) = uVar8;
        *(void **)((int)s_00 + 0x20) = s;
                    // WARNING: Load size is inaccurate
        *(void **)((int)strm_00 + 4) = strm;
        *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - *strm_00);
        *(byte **)strm_00 = pbVar9;
        *(undefined1 **)((int)s_00 + 0x34) = puVar7;
        iVar4 = zlib_inflate_flush(s_00,strm_00,iVar4);
        return iVar4;
      }
      *piVar2 = 8;
    case 8:
      goto switchD_10004c0c_caseD_8;
    case 9:
      *(void **)((int)s_00 + 0x20) = s;
      *(uint *)((int)s_00 + 0x1c) = uVar8;
                    // WARNING: Load size is inaccurate
      *(void **)((int)strm_00 + 4) = strm;
      *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - *strm_00);
      *(byte **)strm_00 = pbVar9;
      *(undefined1 **)((int)s_00 + 0x34) = puVar7;
      iVar4 = zlib_inflate_flush(s_00,strm_00,-3);
      return iVar4;
    default:
      *(void **)((int)s_00 + 0x20) = s;
      *(uint *)((int)s_00 + 0x1c) = uVar8;
                    // WARNING: Load size is inaccurate
      *(void **)((int)strm_00 + 4) = strm;
      *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - *strm_00);
      *(byte **)strm_00 = pbVar9;
      *(undefined1 **)((int)s_00 + 0x34) = puVar7;
      iVar4 = zlib_inflate_flush(s_00,strm_00,-2);
      return iVar4;
    }
  } while( true );
switchD_10004c0c_caseD_8:
  *(void **)((int)s_00 + 0x20) = s;
  *(uint *)((int)s_00 + 0x1c) = uVar8;
                    // WARNING: Load size is inaccurate
  *(void **)((int)strm_00 + 4) = strm;
  *(byte **)((int)strm_00 + 8) = pbVar9 + (*(int *)((int)strm_00 + 8) - *strm_00);
  *(byte **)strm_00 = pbVar9;
  *(undefined1 **)((int)s_00 + 0x34) = puVar7;
  iVar4 = zlib_inflate_flush(s_00,strm_00,1);
  return iVar4;
}



// Setting prototype: void huffman_table_free(void *table, void *strm)

void zlib_inflate_trees_free(void *table,void *strm)

{
                    // 
                    // Frees the memory allocated for a Huffman table.
                    // 
                    // Parameters:
                    //   table: Pointer to the Huffman table structure to free.
                    //   strm: Pointer to the z_stream structure for memory deallocation.
                    // 
  (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),table);
  return;
}



// Setting prototype: int inflate(uint32_t lit_len_table_idx, uint32_t dist_table_idx, void
// *lit_len_table_ptr, void *dist_table_ptr, void *s, void *strm)

int zlib_inflate_fast(uint32_t lit_len_table_idx,uint32_t dist_table_idx,void *lit_len_table_ptr,
                     void *dist_table_ptr,void *s,void *strm)

{
  byte *pbVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  byte *pbVar10;
  undefined1 *puVar11;
  undefined1 *puVar12;
  void *pvVar13;
  uint local_14;
  undefined1 *local_10;
  undefined1 *local_c;
  
                    // 
                    // Main inflate (decompression) loop.
                    // This function processes literal, length, and distance codes to decompress
                    // data.
                    // 
                    // Parameters:
                    //   lit_len_table_idx: Index for the literal/length Huffman table.
                    //   dist_table_idx: Index for the distance Huffman table.
                    //   lit_len_table_ptr: Pointer to the literal/length Huffman table.
                    //   dist_table_ptr: Pointer to the distance Huffman table.
                    //   s: Pointer to the inflate_state structure.
                    //   strm: Pointer to the z_stream structure.
                    // 
                    // Return values:
                    //   A status code indicating success or failure.
                    // 
  local_10 = *(undefined1 **)((int)s + 0x34);
  uVar7 = *(uint *)((int)s + 0x20);
  local_14 = *(uint *)((int)strm + 4);
                    // WARNING: Load size is inaccurate
  pbVar10 = *strm;
  uVar3 = *(uint *)((int)s + 0x1c);
  if (local_10 < *(undefined1 **)((int)s + 0x30)) {
    local_c = *(undefined1 **)((int)s + 0x30) + (-1 - (int)local_10);
  }
  else {
    local_c = (undefined1 *)(*(int *)((int)s + 0x2c) - (int)local_10);
  }
  uVar6 = *(uint *)(&DAT_100287a0 + lit_len_table_idx * 4);
  uVar5 = *(uint *)(&DAT_100287a0 + dist_table_idx * 4);
  do {
    for (; uVar3 < 0x14; uVar3 = uVar3 + 8) {
      local_14 = local_14 - 1;
      uVar7 = uVar7 | (uint)*pbVar10 << ((byte)uVar3 & 0x1f);
      pbVar10 = pbVar10 + 1;
    }
    bVar2 = *(byte *)((int)lit_len_table_ptr + (uVar6 & uVar7) * 8);
    uVar9 = (uint)bVar2;
    pvVar13 = (void *)((int)lit_len_table_ptr + (uVar6 & uVar7) * 8);
    if (uVar9 == 0) {
LAB_100055c8:
      uVar7 = uVar7 >> (*(byte *)((int)pvVar13 + 1) & 0x1f);
      uVar3 = uVar3 - *(byte *)((int)pvVar13 + 1);
      *local_10 = *(undefined1 *)((int)pvVar13 + 4);
      local_10 = local_10 + 1;
      local_c = local_c + -1;
    }
    else {
      uVar7 = uVar7 >> (*(byte *)((int)pvVar13 + 1) & 0x1f);
      uVar3 = uVar3 - *(byte *)((int)pvVar13 + 1);
      while ((bVar2 & 0x10) == 0) {
        if ((uVar9 & 0x40) != 0) {
          if ((uVar9 & 0x20) != 0) {
            uVar6 = *(int *)((int)strm + 4) - local_14;
            if (uVar3 >> 3 < uVar6) {
              uVar6 = uVar3 >> 3;
            }
            *(uint *)((int)s + 0x20) = uVar7;
            *(uint *)((int)s + 0x1c) = uVar3 + uVar6 * -8;
                    // WARNING: Load size is inaccurate
            iVar4 = *strm;
            *(uint *)((int)strm + 4) = uVar6 + local_14;
            *(uint *)strm = (int)pbVar10 - uVar6;
            *(uint *)((int)strm + 8) = *(int *)((int)strm + 8) + (((int)pbVar10 - uVar6) - iVar4);
            *(undefined1 **)((int)s + 0x34) = local_10;
            return 1;
          }
          uVar5 = *(int *)((int)strm + 4) - local_14;
          *(char **)((int)strm + 0x18) = s_invalid_literal_length_code_1002751c;
          uVar6 = uVar3 >> 3;
          if (uVar3 >> 3 < uVar5) goto LAB_100056df;
          goto LAB_100056e1;
        }
        iVar4 = (*(uint *)(&DAT_100287a0 + uVar9 * 4) & uVar7) + *(int *)((int)pvVar13 + 4);
        bVar2 = *(byte *)((int)pvVar13 + iVar4 * 8);
        uVar9 = (uint)bVar2;
        pvVar13 = (void *)((int)pvVar13 + iVar4 * 8);
        if (uVar9 == 0) goto LAB_100055c8;
        uVar7 = uVar7 >> (*(byte *)((int)pvVar13 + 1) & 0x1f);
        uVar3 = uVar3 - *(byte *)((int)pvVar13 + 1);
      }
      uVar9 = uVar9 & 0xf;
      lit_len_table_idx =
           (*(uint *)(&DAT_100287a0 + uVar9 * 4) & uVar7) + *(int *)((int)pvVar13 + 4);
      uVar8 = uVar7 >> (sbyte)uVar9;
      for (uVar3 = uVar3 - uVar9; uVar3 < 0xf; uVar3 = uVar3 + 8) {
        local_14 = local_14 - 1;
        uVar8 = uVar8 | (uint)*pbVar10 << ((byte)uVar3 & 0x1f);
        pbVar10 = pbVar10 + 1;
      }
      pvVar13 = (void *)((int)dist_table_ptr + (uVar5 & uVar8) * 8);
      uVar7 = uVar8 >> (*(byte *)((int)pvVar13 + 1) & 0x1f);
      uVar3 = uVar3 - *(byte *)((int)pvVar13 + 1);
      bVar2 = *(byte *)((int)dist_table_ptr + (uVar5 & uVar8) * 8);
      while ((bVar2 & 0x10) == 0) {
        if ((bVar2 & 0x40) != 0) {
          uVar5 = *(int *)((int)strm + 4) - local_14;
          *(char **)((int)strm + 0x18) = s_invalid_distance_code_10027504;
          uVar6 = uVar3 >> 3;
          if (uVar3 >> 3 < uVar5) {
LAB_100056df:
            uVar5 = uVar6;
          }
LAB_100056e1:
          *(uint *)((int)s + 0x20) = uVar7;
          *(uint *)((int)s + 0x1c) = uVar3 + uVar5 * -8;
                    // WARNING: Load size is inaccurate
          iVar4 = *strm;
          *(uint *)((int)strm + 4) = uVar5 + local_14;
          *(uint *)strm = (int)pbVar10 - uVar5;
          *(uint *)((int)strm + 8) = *(int *)((int)strm + 8) + (((int)pbVar10 - uVar5) - iVar4);
          *(undefined1 **)((int)s + 0x34) = local_10;
          return -3;
        }
        iVar4 = (*(uint *)(&DAT_100287a0 + (uint)bVar2 * 4) & uVar7) + *(int *)((int)pvVar13 + 4);
        pbVar1 = (byte *)((int)pvVar13 + iVar4 * 8);
        pvVar13 = (void *)((int)pvVar13 + iVar4 * 8);
        uVar7 = uVar7 >> (*(byte *)((int)pvVar13 + 1) & 0x1f);
        uVar3 = uVar3 - *(byte *)((int)pvVar13 + 1);
        bVar2 = *pbVar1;
      }
      uVar9 = bVar2 & 0xf;
      for (; uVar3 < uVar9; uVar3 = uVar3 + 8) {
        local_14 = local_14 - 1;
        uVar7 = uVar7 | (uint)*pbVar10 << ((byte)uVar3 & 0x1f);
        pbVar10 = pbVar10 + 1;
      }
      uVar8 = (*(uint *)(&DAT_100287a0 + uVar9 * 4) & uVar7) + *(int *)((int)pvVar13 + 4);
      uVar7 = uVar7 >> (sbyte)uVar9;
      uVar3 = uVar3 - uVar9;
      local_c = local_c + -lit_len_table_idx;
      if ((uint)((int)local_10 - *(int *)((int)s + 0x28)) < uVar8) {
        uVar8 = (*(int *)((int)s + 0x28) - (int)local_10) + uVar8;
        puVar12 = (undefined1 *)(*(int *)((int)s + 0x2c) - uVar8);
        if (uVar8 < lit_len_table_idx) {
          lit_len_table_idx = lit_len_table_idx - uVar8;
          do {
            *local_10 = *puVar12;
            local_10 = local_10 + 1;
            puVar12 = puVar12 + 1;
            uVar8 = uVar8 - 1;
          } while (uVar8 != 0);
          puVar12 = *(undefined1 **)((int)s + 0x28);
        }
      }
      else {
        puVar11 = local_10 + -uVar8;
        *local_10 = *puVar11;
        puVar12 = puVar11 + 2;
        local_10[1] = puVar11[1];
        lit_len_table_idx = lit_len_table_idx - 2;
        local_10 = local_10 + 2;
      }
      do {
        *local_10 = *puVar12;
        local_10 = local_10 + 1;
        puVar12 = puVar12 + 1;
        lit_len_table_idx = lit_len_table_idx - 1;
      } while (lit_len_table_idx != 0);
    }
    if ((local_c < (undefined1 *)0x102) || (local_14 < 10)) {
      uVar6 = *(int *)((int)strm + 4) - local_14;
      if (uVar3 >> 3 < uVar6) {
        uVar6 = uVar3 >> 3;
      }
      *(uint *)((int)s + 0x20) = uVar7;
      *(uint *)((int)s + 0x1c) = uVar3 + uVar6 * -8;
                    // WARNING: Load size is inaccurate
      iVar4 = *strm;
      *(uint *)((int)strm + 4) = uVar6 + local_14;
      *(uint *)strm = (int)pbVar10 - uVar6;
      *(uint *)((int)strm + 8) = *(int *)((int)strm + 8) + (((int)pbVar10 - uVar6) - iVar4);
      *(undefined1 **)((int)s + 0x34) = local_10;
      return 0;
    }
  } while( true );
}



// Setting prototype: int inflateResetStream(void *strm)

int zlib_inflate_blocks_reset(void *strm)

{
  uint *puVar1;
  
                    // This function resets the inflate stream. strm is a pointer to a z_stream
                    // structure.
  if ((strm != (void *)0x0) && (puVar1 = *(uint **)((int)strm + 0x1c), puVar1 != (uint *)0x0)) {
    *(undefined4 *)((int)strm + 0x14) = 0;
    *(undefined4 *)((int)strm + 8) = 0;
    *(undefined4 *)((int)strm + 0x18) = 0;
    *puVar1 = -(uint)(puVar1[3] != 0) & 7;
    zlib_inflateReset(*(void **)(*(int *)((int)strm + 0x1c) + 0x14));
    return 0;
  }
  return -2;
}



// Setting prototype: int inflateEndStream(void *strm)

int zlib_inflate_blocks_free(void *strm)

{
  void *strm_00;
  
                    // This function ends the inflate stream and frees memory. strm is a pointer to
                    // a z_stream structure.
  if (((strm != (void *)0x0) && (*(int *)((int)strm + 0x1c) != 0)) &&
     (*(int *)((int)strm + 0x24) != 0)) {
    strm_00 = *(void **)(*(int *)((int)strm + 0x1c) + 0x14);
    if (strm_00 != (void *)0x0) {
      zlib_inflateEnd(strm_00);
    }
    (**(code **)((int)strm + 0x24))
              (*(undefined4 *)((int)strm + 0x28),*(undefined4 *)((int)strm + 0x1c));
    *(undefined4 *)((int)strm + 0x1c) = 0;
    return 0;
  }
  return -2;
}



// Setting prototype: int inflateInitStream(void *strm, int window_bits, char *version, int
// stream_size)

int zlib_inflate_blocks_new(void *strm,int window_bits,char *version,int stream_size)

{
  int iVar1;
  int unaff_EDI;
  
                    // This function initializes the inflate stream. strm is a pointer to a z_stream
                    // structure.
  if (((version == (char *)0x0) || (*version != s_1_1_3_1002706c[0])) || (stream_size != 0x38)) {
    return -6;
  }
  if (strm == (void *)0x0) {
    return -2;
  }
  *(undefined4 *)((int)strm + 0x18) = 0;
  if (*(int *)((int)strm + 0x20) == 0) {
    *(code **)((int)strm + 0x20) = zlib_zcalloc;
    *(undefined4 *)((int)strm + 0x28) = 0;
  }
  if (*(int *)((int)strm + 0x24) == 0) {
    *(undefined1 **)((int)strm + 0x24) = &LAB_10009300;
  }
  iVar1 = (**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),1,0x18);
  *(int *)((int)strm + 0x1c) = iVar1;
  if (iVar1 == 0) {
    return -4;
  }
  *(undefined4 *)(iVar1 + 0x14) = 0;
  *(undefined4 *)(*(int *)((int)strm + 0x1c) + 0xc) = 0;
  if (window_bits < 0) {
    window_bits = -window_bits;
    *(undefined4 *)(*(int *)((int)strm + 0x1c) + 0xc) = 1;
  }
  if ((7 < window_bits) && (window_bits < 0x10)) {
    *(int *)(*(int *)((int)strm + 0x1c) + 0x10) = window_bits;
    iVar1 = zlib_inflateInit2_(strm,~-(uint)(*(int *)(*(int *)((int)strm + 0x1c) + 0xc) != 0) &
                                    0x10001000,(char *)(1 << ((byte)window_bits & 0x1f)),unaff_EDI);
    *(int *)(*(int *)((int)strm + 0x1c) + 0x14) = iVar1;
    if (*(int *)(*(int *)((int)strm + 0x1c) + 0x14) == 0) {
      zlib_inflate_blocks_free(strm);
      return -4;
    }
    zlib_inflate_blocks_reset(strm);
    return 0;
  }
  zlib_inflate_blocks_free(strm);
  return -2;
}



// Setting prototype: int inflateLoop(void *strm, int flush)

int zlib_inflate_blocks(void *strm,int flush)

{
  byte bVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  uint uVar4;
  uint uVar5;
  
                    // This is the main loop for the inflate algorithm. strm is a pointer to a
                    // z_stream structure.
                    // WARNING: Load size is inaccurate
  if (((strm == (void *)0x0) || (*(int *)((int)strm + 0x1c) == 0)) || (*strm == 0)) {
switchD_10005920_default:
    return -2;
  }
  uVar5 = (flush != 4) - 1 & 0xfffffffb;
  uVar4 = 0xfffffffb;
  do {
    puVar2 = *(undefined4 **)((int)strm + 0x1c);
    switch(*puVar2) {
    case 0:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
                    // WARNING: Load size is inaccurate
      puVar2[1] = (uint)**strm;
      puVar2 = *(undefined4 **)((int)strm + 0x1c);
                    // WARNING: Load size is inaccurate
      uVar3 = puVar2[1];
      *(int *)strm = *strm + 1;
      if (((byte)uVar3 & 0xf) != 8) {
        *puVar2 = 0xd;
        *(char **)((int)strm + 0x18) = s_unknown_compression_method_1002758c;
        *(undefined4 *)(*(int *)((int)strm + 0x1c) + 4) = 5;
        uVar4 = uVar5;
        break;
      }
      if ((uint)puVar2[4] < ((uint)puVar2[1] >> 4) + 8) {
        *puVar2 = 0xd;
        *(char **)((int)strm + 0x18) = s_invalid_window_size_10027578;
        *(undefined4 *)(*(int *)((int)strm + 0x1c) + 4) = 5;
        uVar4 = uVar5;
        break;
      }
      *puVar2 = 1;
      uVar4 = uVar5;
    case 1:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      puVar2 = *(undefined4 **)((int)strm + 0x1c);
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
                    // WARNING: Load size is inaccurate
      bVar1 = **strm;
      *(byte **)strm = *strm + 1;
      if ((puVar2[1] * 0x100 + (uint)bVar1) % 0x1f == 0) {
        if ((bVar1 & 0x20) != 0) {
          **(undefined4 **)((int)strm + 0x1c) = 2;
          uVar4 = uVar5;
          goto switchD_10005920_caseD_2;
        }
        *puVar2 = 7;
        uVar4 = uVar5;
      }
      else {
        *puVar2 = 0xd;
        *(char **)((int)strm + 0x18) = s_incorrect_header_check_10027560;
        *(undefined4 *)(*(int *)((int)strm + 0x1c) + 4) = 5;
        uVar4 = uVar5;
      }
      break;
    case 2:
switchD_10005920_caseD_2:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) = (uint)**strm << 0x18;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      **(undefined4 **)((int)strm + 0x1c) = 3;
      uVar4 = uVar5;
switchD_10005920_caseD_3:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) =
           *(int *)(*(int *)((int)strm + 0x1c) + 8) + (uint)**strm * 0x10000;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      **(undefined4 **)((int)strm + 0x1c) = 4;
      uVar4 = uVar5;
switchD_10005920_caseD_4:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) =
           *(int *)(*(int *)((int)strm + 0x1c) + 8) + (uint)**strm * 0x100;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      **(undefined4 **)((int)strm + 0x1c) = 5;
      uVar4 = uVar5;
switchD_10005920_caseD_5:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) =
           *(int *)(*(int *)((int)strm + 0x1c) + 8) + (uint)**strm;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      *(undefined4 *)((int)strm + 0x30) = (*(undefined4 **)((int)strm + 0x1c))[2];
      **(undefined4 **)((int)strm + 0x1c) = 6;
      return 2;
    case 3:
      goto switchD_10005920_caseD_3;
    case 4:
      goto switchD_10005920_caseD_4;
    case 5:
      goto switchD_10005920_caseD_5;
    case 6:
      **(undefined4 **)((int)strm + 0x1c) = 0xd;
      *(char **)((int)strm + 0x18) = s_need_dictionary_10027538;
      *(undefined4 *)(*(int *)((int)strm + 0x1c) + 4) = 0;
      return -2;
    case 7:
      uVar4 = zlib_inflate((void *)puVar2[5],(int)strm);
      if (uVar4 == 0xfffffffd) {
        **(undefined4 **)((int)strm + 0x1c) = 0xd;
        *(undefined4 *)(*(int *)((int)strm + 0x1c) + 4) = 0;
        uVar4 = 0xfffffffd;
      }
      else {
        if (uVar4 == 0) {
          uVar4 = uVar5;
        }
        if (uVar4 != 1) {
          return uVar4;
        }
        zlib_inflateReset(*(void **)(*(int *)((int)strm + 0x1c) + 0x14));
        puVar2 = *(undefined4 **)((int)strm + 0x1c);
        if (puVar2[3] == 0) {
          *puVar2 = 8;
          uVar4 = uVar5;
          goto switchD_10005920_caseD_8;
        }
        *puVar2 = 0xc;
        uVar4 = uVar5;
      }
      break;
    case 8:
switchD_10005920_caseD_8:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
                    // WARNING: Load size is inaccurate
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) = (uint)**strm << 0x18;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      **(undefined4 **)((int)strm + 0x1c) = 9;
      uVar4 = uVar5;
switchD_10005920_caseD_9:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) =
           *(int *)(*(int *)((int)strm + 0x1c) + 8) + (uint)**strm * 0x10000;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      **(undefined4 **)((int)strm + 0x1c) = 10;
      uVar4 = uVar5;
switchD_10005920_caseD_a:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) =
           *(int *)(*(int *)((int)strm + 0x1c) + 8) + (uint)**strm * 0x100;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      **(undefined4 **)((int)strm + 0x1c) = 0xb;
      uVar4 = uVar5;
switchD_10005920_caseD_b:
      if (*(int *)((int)strm + 4) == 0) {
        return uVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int *)((int)strm + 4) = *(int *)((int)strm + 4) + -1;
      *(int *)((int)strm + 8) = *(int *)((int)strm + 8) + 1;
      *(uint *)(*(int *)((int)strm + 0x1c) + 8) =
           *(int *)(*(int *)((int)strm + 0x1c) + 8) + (uint)**strm;
                    // WARNING: Load size is inaccurate
      *(int *)strm = *strm + 1;
      puVar2 = *(undefined4 **)((int)strm + 0x1c);
      if (puVar2[1] == puVar2[2]) {
        **(undefined4 **)((int)strm + 0x1c) = 0xc;
switchD_10005920_caseD_c:
        return 1;
      }
      *puVar2 = 0xd;
      *(char **)((int)strm + 0x18) = s_incorrect_data_check_10027548;
      *(undefined4 *)(*(int *)((int)strm + 0x1c) + 4) = 5;
      uVar4 = uVar5;
      break;
    case 9:
      goto switchD_10005920_caseD_9;
    case 10:
      goto switchD_10005920_caseD_a;
    case 0xb:
      goto switchD_10005920_caseD_b;
    case 0xc:
      goto switchD_10005920_caseD_c;
    case 0xd:
      return -3;
    default:
      goto switchD_10005920_default;
    }
  } while( true );
}



// Setting prototype: int buildDynamicTables(void *s, void **lit_len_table, void **dist_table, void
// **code_len_table, void *strm)

int zlib_inflate_trees_dynamic
              (void *s,void **lit_len_table,void **dist_table,void **code_len_table,void *strm)

{
  uint32_t *codes;
  int iVar1;
  uint32_t local_4;
  
                    // This function builds dynamic Huffman tables for literal/length and distance
                    // codes.
  local_4 = 0;
  codes = (uint32_t *)(**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),0x13,4);
  if (codes == (uint32_t *)0x0) {
    return -4;
  }
  iVar1 = zlib_huft_build((int *)s,0x13,0x13,(void *)0x0,(void *)0x0,(uint32_t *)dist_table,
                          (uint32_t *)lit_len_table,code_len_table,&local_4,codes);
  if (iVar1 == -3) {
    *(char **)((int)strm + 0x18) = s_oversubscribed_dynamic_bit_lengt_100286d4;
    (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
    return -3;
  }
  if ((iVar1 == -5) || (*lit_len_table == (void *)0x0)) {
    *(char **)((int)strm + 0x18) = s_incomplete_dynamic_bit_lengths_t_100286b0;
    iVar1 = -3;
  }
  (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
  return iVar1;
}



// WARNING: Type propagation algorithm not settling
// Setting prototype: int huffmanTableBuildHelper(int *lengths, uint32_t num_codes, uint32_t
// max_codes, void *base_table, void *extra_bits_table, uint32_t *table_ptr, uint32_t
// *max_length_ptr, void *work_space, uint32_t *table_size_ptr, uint32_t *codes)

int zlib_huft_build(int *lengths,uint32_t num_codes,uint32_t max_codes,void *base_table,
                   void *extra_bits_table,uint32_t *table_ptr,uint32_t *max_length_ptr,
                   void *work_space,uint32_t *table_size_ptr,uint32_t *codes)

{
  undefined4 uVar1;
  undefined2 uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint *puVar7;
  int *piVar8;
  uint uVar9;
  int iVar10;
  uint uVar11;
  undefined4 *puVar12;
  uint32_t uVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  byte bVar17;
  int iVar18;
  uint uVar19;
  uint local_100;
  uint local_fc;
  int local_f8;
  uint *local_f4;
  int local_f0;
  uint *local_e8;
  undefined4 local_e0;
  uint local_dc;
  uint local_d8;
  uint local_d4;
  void *local_d0;
  uint local_bc [31];
  uint32_t auStack_40 [16];
  
                    // This is a helper function for building Huffman decoding tables.
  uVar19 = 0;
  local_bc[0] = 0;
  local_bc[1] = 0;
  local_bc[2] = 0;
  local_bc[3] = 0;
  local_bc[4] = 0;
  local_bc[5] = 0;
  local_bc[6] = 0;
  local_bc[7] = 0;
  local_bc[8] = 0;
  local_bc[9] = 0;
  local_bc[10] = 0;
  local_bc[0xb] = 0;
  local_bc[0xc] = 0;
  local_bc[0xd] = 0;
  local_bc[0xe] = 0;
  local_bc[0xf] = 0;
  piVar8 = lengths;
  uVar13 = num_codes;
  do {
    iVar18 = *piVar8;
    piVar8 = piVar8 + 1;
    uVar13 = uVar13 - 1;
    local_bc[iVar18] = local_bc[iVar18] + 1;
  } while (uVar13 != 0);
  if (local_bc[0] == num_codes) {
    *table_ptr = 0;
    *max_length_ptr = 0;
  }
  else {
    local_fc = 1;
    puVar7 = local_bc;
    do {
      puVar7 = puVar7 + 1;
      if (*puVar7 != 0) break;
      local_fc = local_fc + 1;
    } while (local_fc < 0x10);
    local_100 = *max_length_ptr;
    if (*max_length_ptr < local_fc) {
      local_100 = local_fc;
    }
    uVar14 = 0xf;
    puVar7 = local_bc + 0xf;
    do {
      if (*puVar7 != 0) break;
      uVar14 = uVar14 - 1;
      puVar7 = puVar7 + -1;
    } while (uVar14 != 0);
    if (uVar14 < local_100) {
      local_100 = uVar14;
    }
    *max_length_ptr = local_100;
    iVar18 = 1 << ((byte)local_fc & 0x1f);
    if (local_fc < uVar14) {
      puVar7 = local_bc + local_fc;
      uVar9 = local_fc;
      do {
        uVar6 = *puVar7;
        if ((int)(iVar18 - uVar6) < 0) {
          return -3;
        }
        uVar9 = uVar9 + 1;
        puVar7 = puVar7 + 1;
        iVar18 = (iVar18 - uVar6) * 2;
      } while (uVar9 < uVar14);
    }
    iVar18 = iVar18 - local_bc[uVar14];
    if (iVar18 < 0) {
      return -3;
    }
    local_bc[0x11] = 0;
    local_bc[uVar14] = local_bc[uVar14] + iVar18;
    iVar10 = 0;
    iVar15 = uVar14 - 1;
    if (iVar15 != 0) {
      iVar4 = 0;
      do {
        iVar10 = iVar10 + *(int *)((int)local_bc + iVar4 + 4);
        iVar15 = iVar15 + -1;
        *(int *)((int)local_bc + iVar4 + 0x48) = iVar10;
        iVar4 = iVar4 + 4;
      } while (iVar15 != 0);
    }
    uVar9 = 0;
    do {
      iVar10 = *lengths;
      lengths = lengths + 1;
      if (iVar10 != 0) {
        uVar6 = local_bc[iVar10 + 0x10];
        codes[uVar6] = uVar9;
        local_bc[iVar10 + 0x10] = uVar6 + 1;
      }
      uVar9 = uVar9 + 1;
    } while (uVar9 < num_codes);
    iVar10 = -local_100;
    uVar9 = local_bc[uVar14 + 0x10];
    local_f4 = codes;
    local_d8 = 0;
    local_bc[0x10] = 0;
    local_f8 = -1;
    auStack_40[1] = 0;
    local_d0 = (void *)0x0;
    local_d4 = 0;
    if ((int)local_fc <= (int)uVar14) {
      local_f0 = local_fc - 1;
      local_e8 = local_bc + local_fc;
      do {
        uVar6 = *local_e8;
        uVar1 = local_e0;
        while (uVar6 != 0) {
          uVar16 = uVar6 - 1;
          local_e0._2_2_ = (undefined2)((uint)uVar1 >> 0x10);
          uVar2 = local_e0._2_2_;
          iVar15 = iVar10;
          while (local_e0 = uVar1, iVar15 = iVar15 + local_100, iVar15 < (int)local_fc) {
            iVar10 = iVar10 + local_100;
            uVar19 = uVar14 - iVar10;
            if (local_100 < uVar14 - iVar10) {
              uVar19 = local_100;
            }
            uVar11 = local_fc - iVar10;
            uVar3 = 1 << ((byte)uVar11 & 0x1f);
            if ((uVar6 < uVar3) &&
               (iVar4 = uVar3 + (-1 - uVar16), puVar7 = local_e8, uVar11 < uVar19)) {
              while (uVar11 = uVar11 + 1, uVar11 < uVar19) {
                uVar3 = puVar7[1];
                uVar5 = iVar4 * 2;
                if (uVar5 < uVar3 || uVar5 - uVar3 == 0) break;
                iVar4 = uVar5 - uVar3;
                puVar7 = puVar7 + 1;
              }
            }
            local_d4 = 1 << ((byte)uVar11 & 0x1f);
            uVar13 = *table_size_ptr;
            uVar19 = local_d4 + uVar13;
            if (0x5a0 < uVar19) {
              return -4;
            }
            *table_size_ptr = uVar19;
            local_d0 = (void *)((int)work_space + uVar13 * 8);
            auStack_40[local_f8 + 2] = (uint32_t)local_d0;
            if (local_f8 + 1 == 0) {
              *table_ptr = (uint32_t)local_d0;
            }
            else {
              local_bc[local_f8 + 0x11] = local_d8;
              local_e0._2_2_ = (undefined2)((uint)local_e0 >> 0x10);
              local_e0._0_2_ = CONCAT11((char)local_100,(byte)uVar11);
              uVar19 = local_d8 >> ((char)iVar10 - (char)local_100 & 0x1fU);
              uVar13 = auStack_40[local_f8 + 1];
              local_dc = ((int)((int)local_d0 - uVar13) >> 3) - uVar19;
              *(undefined4 *)(uVar13 + uVar19 * 8) = local_e0;
              *(uint *)(uVar13 + 4 + uVar19 * 8) = local_dc;
            }
            uVar19 = local_d8;
            local_f8 = local_f8 + 1;
            uVar1 = local_e0;
            uVar2 = local_e0._2_2_;
          }
          bVar17 = (byte)iVar10;
          if (local_f4 < codes + uVar9) {
            local_dc = *local_f4;
            if (local_dc < max_codes) {
              local_e0._0_1_ = (-(local_dc < 0x100) & 0xa0U) + 0x60;
            }
            else {
              iVar15 = (local_dc - max_codes) * 4;
              local_e0._0_1_ = *(char *)(iVar15 + (int)extra_bits_table) + 'P';
              local_dc = *(uint *)(iVar15 + (int)base_table);
            }
            local_f4 = local_f4 + 1;
          }
          else {
            local_e0._0_1_ = -0x40;
          }
          local_e0 = CONCAT31(CONCAT21(uVar2,(char)local_fc - bVar17),(char)local_e0);
          iVar15 = 1 << ((char)local_fc - bVar17 & 0x1f);
          uVar6 = uVar19 >> (bVar17 & 0x1f);
          if (uVar6 < local_d4) {
            puVar12 = (undefined4 *)((int)local_d0 + uVar6 * 8);
            do {
              uVar6 = uVar6 + iVar15;
              *puVar12 = local_e0;
              puVar12[1] = local_dc;
              puVar12 = puVar12 + iVar15 * 2;
            } while (uVar6 < local_d4);
          }
          uVar11 = 1 << ((byte)local_f0 & 0x1f);
          uVar6 = uVar19 & uVar11;
          while (uVar6 != 0) {
            uVar19 = uVar19 ^ uVar11;
            uVar11 = uVar11 >> 1;
            uVar6 = uVar19 & uVar11;
          }
          uVar19 = uVar19 ^ uVar11;
          puVar7 = local_bc + local_f8 + 0x10;
          uVar6 = uVar16;
          uVar1 = local_e0;
          local_d8 = uVar19;
          if (((1 << (bVar17 & 0x1f)) - 1U & uVar19) != local_bc[local_f8 + 0x10]) {
            do {
              local_f8 = local_f8 + -1;
              iVar10 = iVar10 - local_100;
              puVar7 = puVar7 + -1;
            } while (((1 << ((byte)iVar10 & 0x1f)) - 1U & uVar19) != *puVar7);
          }
        }
        local_e8 = local_e8 + 1;
        local_fc = local_fc + 1;
        local_f0 = local_f0 + 1;
        local_e0 = uVar1;
      } while ((int)local_fc <= (int)uVar14);
    }
    if ((iVar18 != 0) && (uVar14 != 1)) {
      return -5;
    }
  }
  return 0;
}



// Setting prototype: int buildLiteralDistTables(uint32_t num_lit_len_codes, uint32_t
// num_dist_codes, int *code_lengths, uint32_t *max_lit_len_bits, uint32_t *max_dist_bits, uint32_t
// *lit_len_table, uint32_t *dist_table, void *work_space, void *strm)

int zlib_inflate_trees_bits
              (uint32_t num_lit_len_codes,uint32_t num_dist_codes,int *code_lengths,
              uint32_t *max_lit_len_bits,uint32_t *max_dist_bits,uint32_t *lit_len_table,
              uint32_t *dist_table,void *work_space,void *strm)

{
  uint32_t *codes;
  int iVar1;
  uint32_t local_4;
  
                    // This function builds the literal/length and distance Huffman tables.
  local_4 = 0;
  codes = (uint32_t *)(**(code **)((int)strm + 0x20))(*(undefined4 *)((int)strm + 0x28),0x120,4);
  if (codes == (uint32_t *)0x0) {
    return -4;
  }
  iVar1 = zlib_huft_build(code_lengths,num_lit_len_codes,0x101,&DAT_100246d0,&DAT_1002474c,
                          lit_len_table,max_lit_len_bits,work_space,&local_4,codes);
  if (iVar1 == 0) {
    if (*max_lit_len_bits != 0) {
      iVar1 = zlib_huft_build(code_lengths + num_lit_len_codes,num_dist_codes,0,&DAT_100247c8,
                              &DAT_10024840,dist_table,max_dist_bits,work_space,&local_4,codes);
      if (iVar1 == 0) {
        if ((*max_dist_bits != 0) || (num_lit_len_codes < 0x102)) {
          (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
          return 0;
        }
      }
      else {
        if (iVar1 == -3) {
          *(char **)((int)strm + 0x18) = s_oversubscribed_distance_tree_10028780;
          (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
          return -3;
        }
        if (iVar1 == -5) {
          *(char **)((int)strm + 0x18) = s_incomplete_distance_tree_10028764;
          (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
          return -3;
        }
        if (iVar1 == -4) goto LAB_100063b3;
      }
      *(char **)((int)strm + 0x18) = s_empty_distance_tree_with_lengths_10028740;
      iVar1 = -3;
LAB_100063b3:
      (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
      return iVar1;
    }
  }
  else {
    if (iVar1 == -3) {
      *(char **)((int)strm + 0x18) = s_oversubscribed_literal_length_tr_1002871c;
      (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
      return -3;
    }
    if (iVar1 == -4) goto LAB_100063f6;
  }
  *(char **)((int)strm + 0x18) = s_incomplete_literal_length_tree_100286fc;
  iVar1 = -3;
LAB_100063f6:
  (**(code **)((int)strm + 0x24))(*(undefined4 *)((int)strm + 0x28),codes);
  return iVar1;
}



// Setting prototype: int getStaticTables(uint32_t *lit_len_table_ptr, uint32_t *dist_table_ptr,
// uint32_t *lit_len_codes_ptr, uint32_t *dist_codes_ptr)

int zlib_inflate_trees_fixed
              (uint32_t *lit_len_table_ptr,uint32_t *dist_table_ptr,uint32_t *lit_len_codes_ptr,
              uint32_t *dist_codes_ptr)

{
                    // This function retrieves pointers to the static Huffman tables.
  *lit_len_table_ptr = DAT_100275a8;
  *dist_table_ptr = DAT_100275ac;
  *lit_len_codes_ptr = (uint32_t)&DAT_100275b0;
  *dist_codes_ptr = (uint32_t)&DAT_100285b0;
  return 0;
}



// Setting prototype: int copyFromWindow(void *s, void *strm, int status)

int zlib_inflate_flush(void *s,void *strm,int status)

{
  undefined4 uVar1;
  undefined1 *puVar2;
  uint uVar3;
  undefined4 *puVar4;
  uint uVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  undefined4 *local_4;
  
                    // This function copies data from the inflate window to the output buffer.
  puVar4 = *(undefined4 **)((int)s + 0x34);
  puVar6 = *(undefined4 **)((int)s + 0x30);
  local_4 = *(undefined4 **)((int)strm + 0xc);
  if (puVar4 < puVar6) {
    puVar4 = *(undefined4 **)((int)s + 0x2c);
  }
  uVar3 = *(uint *)((int)strm + 0x10);
  uVar5 = (int)puVar4 - (int)puVar6;
  if (uVar3 < (uint)((int)puVar4 - (int)puVar6)) {
    uVar5 = uVar3;
  }
  if ((uVar5 != 0) && (status == -5)) {
    status = 0;
  }
  *(uint *)((int)strm + 0x10) = uVar3 - uVar5;
  *(uint *)((int)strm + 0x14) = *(int *)((int)strm + 0x14) + uVar5;
  if (*(code **)((int)s + 0x38) != (code *)0x0) {
    uVar1 = (**(code **)((int)s + 0x38))(*(undefined4 *)((int)s + 0x3c),puVar6,uVar5);
    *(undefined4 *)((int)s + 0x3c) = uVar1;
    *(undefined4 *)((int)strm + 0x30) = uVar1;
  }
  puVar4 = puVar6;
  puVar7 = local_4;
  for (uVar3 = uVar5 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
    *puVar7 = *puVar4;
    puVar4 = puVar4 + 1;
    puVar7 = puVar7 + 1;
  }
  puVar2 = (undefined1 *)((int)puVar6 + uVar5);
  for (uVar3 = uVar5 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
    *(undefined1 *)puVar7 = *(undefined1 *)puVar4;
    puVar4 = (undefined4 *)((int)puVar4 + 1);
    puVar7 = (undefined4 *)((int)puVar7 + 1);
  }
  local_4 = (undefined4 *)((int)local_4 + uVar5);
  if (puVar2 == *(undefined1 **)((int)s + 0x2c)) {
    puVar4 = *(undefined4 **)((int)s + 0x28);
    if (*(undefined1 **)((int)s + 0x34) == *(undefined1 **)((int)s + 0x2c)) {
      *(undefined4 **)((int)s + 0x34) = puVar4;
    }
    uVar5 = *(int *)((int)s + 0x34) - (int)puVar4;
    uVar3 = *(uint *)((int)strm + 0x10);
    if (uVar3 < uVar5) {
      uVar5 = uVar3;
    }
    if ((uVar5 != 0) && (status == -5)) {
      status = 0;
    }
    *(uint *)((int)strm + 0x10) = uVar3 - uVar5;
    *(uint *)((int)strm + 0x14) = *(int *)((int)strm + 0x14) + uVar5;
    if (*(code **)((int)s + 0x38) != (code *)0x0) {
      uVar1 = (**(code **)((int)s + 0x38))(*(undefined4 *)((int)s + 0x3c),puVar4,uVar5);
      *(undefined4 *)((int)s + 0x3c) = uVar1;
      *(undefined4 *)((int)strm + 0x30) = uVar1;
    }
    puVar6 = puVar4;
    puVar7 = local_4;
    for (uVar3 = uVar5 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
      *puVar7 = *puVar6;
      puVar6 = puVar6 + 1;
      puVar7 = puVar7 + 1;
    }
    local_4 = (undefined4 *)((int)local_4 + uVar5);
    puVar2 = (undefined1 *)((int)puVar4 + uVar5);
    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
      *(undefined1 *)puVar7 = *(undefined1 *)puVar6;
      puVar6 = (undefined4 *)((int)puVar6 + 1);
      puVar7 = (undefined4 *)((int)puVar7 + 1);
    }
  }
  *(undefined4 **)((int)strm + 0xc) = local_4;
  *(undefined1 **)((int)s + 0x30) = puVar2;
  return status;
}



// Setting prototype: void *mAlloc(size_t size, const char *tag)

undefined4 * mAlloc(size_t size,char *tag)

{
  byte bVar1;
  char *pcVar2;
  byte *pbVar3;
  int iVar4;
  undefined4 *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  byte *pbVar9;
  bool bVar10;
  CHAR local_11c [256];
  byte local_1c [16];
  byte *local_c;
  byte *local_8;
  
                    // This is a custom memory allocation function that tracks memory usage.
  if (DAT_10034640 == (undefined4 *)0x0) {
    fatalError(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x93,
               s_m_alloc___called_without_prior_c_100288ac);
    return (undefined4 *)0x0;
  }
  if (size == 0) {
    return (undefined4 *)0x0;
  }
  DAT_10034638 = DAT_10034638 + 1;
  pbVar3 = &DAT_117640a0;
  if ((tag != (char *)0x0) && (pcVar2 = _strchr(tag,0x3a), pcVar2 != (char *)0x0)) {
    pcVar2 = pcVar2 + (1 - (int)tag);
    if (0xf < (int)pcVar2) {
      printf_wrapper(local_11c,s_m_alloc_debug__GroupInformation_t_10028858,tag);
      showMessage(local_11c);
    }
    _strncpy((char *)local_1c,tag,(size_t)pcVar2);
    local_1c[(int)pcVar2] = 0;
    local_8 = &DAT_117640a0;
    do {
      pbVar3 = local_1c;
      pbVar9 = local_8;
      do {
        bVar1 = *pbVar3;
        bVar10 = bVar1 < *pbVar9;
        if (bVar1 != *pbVar9) {
LAB_1000666e:
          iVar4 = (1 - (uint)bVar10) - (uint)(bVar10 != 0);
          goto LAB_10006673;
        }
        if (bVar1 == 0) break;
        bVar1 = pbVar3[1];
        bVar10 = bVar1 < pbVar9[1];
        if (bVar1 != pbVar9[1]) goto LAB_1000666e;
        pbVar3 = pbVar3 + 2;
        pbVar9 = pbVar9 + 2;
      } while (bVar1 != 0);
      iVar4 = 0;
LAB_10006673:
      if (iVar4 == 0) {
        pbVar3 = local_8;
        if (local_8 != (byte *)0x0) goto LAB_100066d7;
        break;
      }
      pbVar3 = local_8 + 0x24;
      local_c = local_8;
      local_8 = *(byte **)pbVar3;
    } while (*(byte **)pbVar3 != (byte *)0x0);
    local_8 = (byte *)_malloc(0x28);
    uVar6 = 0xffffffff;
    pbVar3 = local_1c;
    do {
      pbVar9 = pbVar3;
      if (uVar6 == 0) break;
      uVar6 = uVar6 - 1;
      pbVar9 = pbVar3 + 1;
      bVar1 = *pbVar3;
      pbVar3 = pbVar9;
    } while (bVar1 != 0);
    uVar6 = ~uVar6;
    pbVar3 = pbVar9 + -uVar6;
    pbVar9 = local_8;
    for (uVar7 = uVar6 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
      *(undefined4 *)pbVar9 = *(undefined4 *)pbVar3;
      pbVar3 = pbVar3 + 4;
      pbVar9 = pbVar9 + 4;
    }
    for (uVar6 = uVar6 & 3; uVar6 != 0; uVar6 = uVar6 - 1) {
      *pbVar9 = *pbVar3;
      pbVar3 = pbVar3 + 1;
      pbVar9 = pbVar9 + 1;
    }
    local_8[0x14] = 0;
    local_8[0x15] = 0;
    local_8[0x16] = 0;
    local_8[0x17] = 0;
    local_8[0x10] = 0;
    local_8[0x11] = 0;
    local_8[0x12] = 0;
    local_8[0x13] = 0;
    local_8[0x1c] = 0;
    local_8[0x1d] = 0;
    local_8[0x1e] = 0;
    local_8[0x1f] = 0;
    local_8[0x18] = 0;
    local_8[0x19] = 0;
    local_8[0x1a] = 0;
    local_8[0x1b] = 0;
    local_8[0x20] = 0;
    local_8[0x21] = 0;
    local_8[0x22] = 0;
    local_8[0x23] = 0;
    local_8[0x24] = 0;
    local_8[0x25] = 0;
    local_8[0x26] = 0;
    local_8[0x27] = 0;
    *(byte **)(local_c + 0x24) = local_8;
    pbVar3 = local_8;
  }
LAB_100066d7:
  *(int *)(pbVar3 + 0x20) = *(int *)(pbVar3 + 0x20) + 1;
  local_c = (byte *)size;
  local_8 = (byte *)_malloc(size);
  if (local_8 == (byte *)0x0) {
    printf_wrapper(local_1c,s_Out_of_Memory_Error__Malloc___Fa_10028820,tag,size);
    fatalError(s_D__Develop_Units_m_alloc_m_alloc_10028888,0xcd,(LPCSTR)local_1c);
    return (undefined4 *)0x0;
  }
  uVar7 = (int)local_8 * 3 & 3;
  uVar8 = (int)local_c - uVar7;
  uVar6 = uVar8;
  puVar5 = (undefined4 *)local_8;
  if (uVar8 != 0 && (int)uVar7 <= (int)local_c) {
    for (; uVar7 != 0; uVar7 = uVar7 - 1) {
      *(undefined1 *)puVar5 = 0;
      puVar5 = (undefined4 *)((int)puVar5 + 1);
    }
    uVar6 = uVar8 & 3;
    for (uVar7 = uVar8 >> 2; uVar7 != 0; uVar7 = uVar7 - 1) {
      *puVar5 = 0;
      puVar5 = puVar5 + 1;
    }
  }
  for (iVar4 = uVar7 + uVar6; iVar4 != 0; iVar4 = iVar4 + -1) {
    *(undefined1 *)puVar5 = 0;
    puVar5 = (undefined4 *)((int)puVar5 + 1);
  }
  if (DAT_1003462c < DAT_10034624) {
    iVar4 = 0;
    puVar5 = DAT_10034640;
    if (0 < DAT_10034624) {
      do {
        if (puVar5[2] == 0) break;
        puVar5 = puVar5 + 4;
        iVar4 = iVar4 + 1;
      } while (iVar4 < DAT_10034624);
    }
    puVar5[2] = local_8;
    puVar5[1] = tag;
    puVar5[3] = size;
    *puVar5 = pbVar3;
    DAT_10034628 = DAT_10034628 + size;
    if (DAT_10034630 < DAT_10034628) {
      DAT_10034630 = DAT_10034628;
    }
    iVar4 = *(int *)(pbVar3 + 0x10) + size;
    *(int *)(pbVar3 + 0x10) = iVar4;
    if (*(int *)(pbVar3 + 0x18) < iVar4) {
      *(int *)(pbVar3 + 0x18) = iVar4;
    }
    DAT_1003462c = DAT_1003462c + 1;
    if (DAT_10034634 < DAT_1003462c) {
      DAT_10034634 = DAT_1003462c;
    }
    iVar4 = *(int *)(pbVar3 + 0x14) + 1;
    *(int *)(pbVar3 + 0x14) = iVar4;
    if (*(int *)(pbVar3 + 0x1c) < iVar4) {
      *(int *)(pbVar3 + 0x1c) = iVar4;
      return (undefined4 *)local_8;
    }
  }
  else {
    fatalError(s_D__Develop_Units_m_alloc_m_alloc_10028888,0xf0,
               s_No_more_free_memory_slots____Cal_100287e4);
  }
  return (undefined4 *)local_8;
}



// Setting prototype: void m_free(void *ptr)

void m_free(void *ptr)

{
  int iVar1;
  int *piVar2;
  
                    // 
                    // Custom memory deallocation function.
                    // It tracks allocated blocks and checks for double-free attempts or memory
                    // underflow.
                    // 
                    // Parameters:
                    //   ptr: A pointer to the memory block to free.
                    // 
  if (ptr != (void *)0x0) {
    DAT_10034638 = DAT_10034638 + -1;
    iVar1 = 0;
    piVar2 = DAT_10034640;
    if (0 < DAT_10034624) {
      do {
        if ((void *)piVar2[2] == ptr) break;
        piVar2 = piVar2 + 4;
        iVar1 = iVar1 + 1;
      } while (iVar1 < DAT_10034624);
    }
    if (iVar1 == DAT_10034624) {
      logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x149,
                 s_Memory_freed_more_than_once_or_t_100288f8,1);
      return;
    }
    iVar1 = piVar2[3];
    piVar2[2] = 0;
    free_memory(ptr);
    DAT_1003462c = DAT_1003462c + -1;
    *(int *)(*piVar2 + 0x14) = *(int *)(*piVar2 + 0x14) + -1;
    DAT_10034628 = DAT_10034628 - iVar1;
    *(int *)(*piVar2 + 0x10) = *(int *)(*piVar2 + 0x10) - iVar1;
    if (DAT_10034628 < 0) {
      fatalError(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x17a,s_Memory_Underflow_Error_100288e0
                );
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: void m_alloc_init(int max_allocations)

void m_alloc_init(int max_allocations)

{
  size_t size;
  undefined4 *puVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
                    // 
                    // Initializes the custom memory allocator.
                    // 
                    // Parameters:
                    //   max_allocations: The maximum number of memory allocations that can be
                    // tracked.
                    // 
  DAT_10034624 = max_allocations;
  size = max_allocations * 0x10;
  DAT_10034628 = 0;
  DAT_10034630 = 0;
  DAT_1003462c = 0;
  DAT_10034634 = 0;
  puVar1 = (undefined4 *)_malloc(size);
  uVar2 = (int)puVar1 * 3 & 3;
  uVar4 = size - uVar2;
  uVar5 = uVar4;
  DAT_10034640 = puVar1;
  if (uVar4 != 0 && (int)uVar2 <= (int)size) {
    for (; uVar2 != 0; uVar2 = uVar2 - 1) {
      *(undefined1 *)puVar1 = 0;
      puVar1 = (undefined4 *)((int)puVar1 + 1);
    }
    uVar5 = uVar4 & 3;
    for (uVar2 = uVar4 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      *puVar1 = 0;
      puVar1 = puVar1 + 1;
    }
  }
  for (iVar3 = uVar2 + uVar5; iVar3 != 0; iVar3 = iVar3 + -1) {
    *(undefined1 *)puVar1 = 0;
    puVar1 = (undefined4 *)((int)puVar1 + 1);
  }
  DAT_117640b4 = 0;
  DAT_117640b0 = 0;
  DAT_117640bc = 0;
  DAT_117640b8 = 0;
  DAT_117640c0 = 0;
  DAT_117640c4 = 0;
  _DAT_117640a0 = DAT_10028938;
  _DAT_117640a4 = DAT_1002893c;
  return;
}



// Setting prototype: void m_alloc_dump(char *filter_tag)

void m_alloc_dump(char *filter_tag)

{
  char cVar1;
  bool bVar2;
  char *pcVar3;
  uint uVar4;
  uint uVar5;
  char *str;
  int *piVar6;
  char *pcVar7;
  int iVar8;
  char local_410 [16];
  CHAR local_400 [1024];
  
                    // 
                    // Dumps memory allocation statistics to the log.
                    // 
                    // Parameters:
                    //   filter_tag: Optional. If provided, only allocations with this tag will be
                    // dumped.
                    // 
  if ((DAT_10034628 == 0) && (DAT_1003462c == 0)) {
    printf_wrapper(local_400,s_____Memory_Subsystem_Information_10028aa0,DAT_10034634,DAT_10034630,
                   DAT_10034630 >> 10);
  }
  else {
    printf_wrapper(local_400,s_____Memory_Subsystem_Information_10028a2c,DAT_10034634,DAT_10034630,
                   DAT_10034630 >> 10,DAT_1003462c,DAT_10034628,DAT_10034628 >> 10);
  }
  logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x1b5,local_400,1);
  logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x1b6,
             s____g_r_o_u_p___i_n_f_o_s____10028a10,1);
  str = &DAT_117640a0;
  do {
    if (filter_tag == (char *)0x0) {
LAB_10006a5c:
      bVar2 = false;
    }
    else {
      pcVar3 = _strstr(str,filter_tag);
      if (pcVar3 == (char *)0x0) goto LAB_10006a5c;
      bVar2 = true;
    }
    if ((0 < *(int *)(str + 0x1c)) &&
       ((((*str != '!' || (*(int *)(str + 0x14) != 0)) || (bVar2)) &&
        ((filter_tag == (char *)0x0 || (bVar2)))))) {
      uVar4 = 0xffffffff;
      pcVar3 = str;
      do {
        pcVar7 = pcVar3;
        if (uVar4 == 0) break;
        uVar4 = uVar4 - 1;
        pcVar7 = pcVar3 + 1;
        cVar1 = *pcVar3;
        pcVar3 = pcVar7;
      } while (cVar1 != '\0');
      uVar4 = ~uVar4;
      pcVar3 = pcVar7 + -uVar4;
      pcVar7 = local_410;
      for (uVar5 = uVar4 >> 2; uVar5 != 0; uVar5 = uVar5 - 1) {
        *(undefined4 *)pcVar7 = *(undefined4 *)pcVar3;
        pcVar3 = pcVar3 + 4;
        pcVar7 = pcVar7 + 4;
      }
      for (uVar4 = uVar4 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
        *pcVar7 = *pcVar3;
        pcVar3 = pcVar3 + 1;
        pcVar7 = pcVar7 + 1;
      }
      pcVar3 = _strrchr(local_410,0x3a);
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = '\0';
      }
      iVar8 = *(int *)(str + 0x10);
      if ((iVar8 == 0) && (*(int *)(str + 0x14) == 0)) {
        printf_wrapper(local_400,s___s__w___i___ik__bytes_in__i_blo_100289d4,local_410,
                       *(int *)(str + 0x18),*(int *)(str + 0x18) >> 10,*(undefined4 *)(str + 0x1c),
                       *(undefined4 *)(str + 0x20));
      }
      else {
        printf_wrapper(local_400,s___s___>_w___i__i___ik__ik__bytes_1002898c,local_410,iVar8,
                       *(int *)(str + 0x18),iVar8 >> 10,*(int *)(str + 0x18) >> 10,
                       *(undefined4 *)(str + 0x14),*(undefined4 *)(str + 0x1c),
                       *(undefined4 *)(str + 0x20));
      }
      logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x1cc,local_400,1);
      if (bVar2) {
        iVar8 = 0;
        piVar6 = DAT_10034640;
        if (0 < DAT_10034624) {
          do {
            if ((piVar6[2] != 0) && ((char *)*piVar6 == str)) {
              printf_wrapper(local_400,s___s__w___i_bytes___ik___10028974,piVar6[1],piVar6[3],
                             piVar6[3] >> 10);
              logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x1d5,local_400,1);
            }
            iVar8 = iVar8 + 1;
            piVar6 = piVar6 + 4;
          } while (iVar8 < DAT_10034624);
        }
        logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x1d8,
                   s____g_r_o_u_p___d_o_n_e____10028958,1);
      }
    }
    str = *(char **)(str + 0x24);
    if (str == (char *)0x0) {
      logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x1dc,
                 s____d_u_m_p___d_o_n_e____10028940,1);
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void m_alloc_cleanup(void)

void m_alloc_cleanup(void)

{
  void *pvVar1;
  void *ptr;
  int *piVar2;
  int iVar3;
  CHAR local_400 [1024];
  
                    // 
                    // Cleans up the custom memory allocator, freeing all tracked memory blocks.
                    // It also reports any memory leaks or anomalies detected during shutdown.
                    // 
  if ((DAT_1003462c == 0) && (DAT_10034628 == 0)) {
    if (DAT_1003463c == 0) goto LAB_10006cc4;
LAB_10006c60:
    m_alloc_dump((char *)0x0);
  }
  else {
    printf_wrapper(local_400,s_____Memory_Shutdown_Anomaly______10028b04,DAT_10034634,DAT_10034630,
                   DAT_1003462c,DAT_10034628);
    showMessage(local_400);
    if (DAT_1003463c != 0) goto LAB_10006c60;
  }
  iVar3 = 0;
  if (0 < DAT_10034624) {
    piVar2 = (int *)((int)DAT_10034640 + 8);
    do {
      if (*piVar2 != 0) {
        printf_wrapper(local_400,s__>_Pointer_not_freed__s_10028aec,piVar2[-1]);
        logMessage(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x203,local_400,1);
        free_memory((void *)*piVar2);
        *piVar2 = 0;
      }
      iVar3 = iVar3 + 1;
      piVar2 = piVar2 + 4;
    } while (iVar3 < DAT_10034624);
  }
LAB_10006cc4:
  DAT_10034634 = 0;
  DAT_1003462c = 0;
  DAT_10034630 = 0;
  DAT_10034628 = 0;
  DAT_10034624 = 0;
  ptr = DAT_117640c4;
  while (ptr != (void *)0x0) {
    pvVar1 = *(void **)((int)ptr + 0x24);
    free_memory(ptr);
    ptr = pvVar1;
  }
  free_memory(DAT_10034640);
  DAT_10034640 = (void *)0x0;
  return;
}



// Setting prototype: void *m_pool_alloc(void **pool_handle, uint32_t size, int count)

int * m_pool_alloc(int *pool_handle,uint size,int count)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  int *piVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  
                    // 
                    // Allocates a block of memory from a memory pool.
                    // If no suitable block is found, a new pool is allocated.
                    // 
                    // Parameters:
                    //   pool_handle: Pointer to the memory pool handle.
                    //   size: The size of each element to allocate.
                    //   count: The number of elements to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL if allocation fails.
                    // 
  if (((pool_handle != (int *)0x0) && (size != 0)) && (0 < count)) {
    iVar8 = size + 4;
    if ((size & 3) != 0) {
      iVar8 = iVar8 + (4 - (size & 3));
    }
    piVar1 = (int *)*pool_handle;
    if (piVar1 == (int *)0x0) {
      piVar1 = (int *)mAlloc(iVar8 * count + 0x10,s_m_pool_get_free_tp_m_pool__10028b78);
      *pool_handle = (int)piVar1;
      *piVar1 = 0;
      piVar1[1] = count;
      piVar1[2] = iVar8;
      piVar1[3] = 0;
    }
    else {
      do {
        if ((*piVar1 < piVar1[1]) && (piVar1[2] == iVar8)) {
          if (piVar1 != (int *)0x0) goto LAB_10006dcf;
          break;
        }
        piVar1 = (int *)piVar1[3];
      } while (piVar1 != (int *)0x0);
      piVar1 = (int *)mAlloc(iVar8 * count + 0x10,s_m_pool_alloc_tp_m_pool__10028b60);
      *piVar1 = 0;
      piVar1[1] = count;
      piVar1[2] = iVar8;
      piVar1[3] = *pool_handle;
      *pool_handle = (int)piVar1;
    }
LAB_10006dcf:
    iVar2 = 0;
    piVar4 = piVar1 + 4;
    if (0 < piVar1[1]) {
      do {
        if (*piVar4 == 0) {
          piVar5 = piVar4 + 1;
          *piVar1 = *piVar1 + 1;
          *piVar4 = (int)piVar1;
          uVar3 = (int)piVar5 * 3 & 3;
          uVar6 = (iVar8 + -4) - uVar3;
          uVar7 = uVar6;
          piVar1 = piVar5;
          if (uVar6 != 0 && (int)uVar3 <= iVar8 + -4) {
            for (; uVar3 != 0; uVar3 = uVar3 - 1) {
              *(undefined1 *)piVar1 = 0;
              piVar1 = (int *)((int)piVar1 + 1);
            }
            uVar7 = uVar6 & 3;
            for (uVar3 = uVar6 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
              *piVar1 = 0;
              piVar1 = piVar1 + 1;
            }
          }
          for (iVar8 = uVar3 + uVar7; iVar8 != 0; iVar8 = iVar8 + -1) {
            *(undefined1 *)piVar1 = 0;
            piVar1 = (int *)((int)piVar1 + 1);
          }
          return piVar5;
        }
        iVar2 = iVar2 + 1;
        piVar4 = (int *)((int)piVar4 + piVar1[2]);
      } while (iVar2 < piVar1[1]);
    }
  }
  return (int *)0x0;
}



// Setting prototype: void m_pool_free(void **pool_handle, void *ptr)

void m_pool_free(void **pool_handle,void *ptr)

{
  undefined4 *puVar1;
  int *ptr_00;
  int iVar2;
  int *piVar3;
  int *piVar4;
  
                    // 
                    // Frees a block of memory previously allocated from a memory pool.
                    // 
                    // Parameters:
                    //   pool_handle: Pointer to the memory pool handle.
                    //   ptr: Pointer to the memory block to free.
                    // 
  puVar1 = (undefined4 *)((int)ptr + -4);
  if ((((puVar1 == (undefined4 *)0x0) || (ptr_00 = (int *)*puVar1, ptr_00 == (int *)0x0)) ||
      (ptr < ptr_00 + 4)) || ((void *)(ptr_00[2] * ptr_00[1] + 0x10 + (int)ptr_00) <= ptr)) {
    fatalError(s_D__Develop_Units_m_alloc_m_alloc_10028888,0x279,
               s_m_pool_free__tried_to_free_inval_10028b94);
  }
  else {
    *puVar1 = 0;
    iVar2 = *ptr_00;
    *ptr_00 = iVar2 + -1;
    if (iVar2 + -1 == 0) {
      piVar3 = (int *)*pool_handle;
      if (ptr_00 != piVar3) {
        for (piVar4 = (int *)piVar3[3]; piVar4 != ptr_00; piVar4 = (int *)piVar4[3]) {
          piVar3 = piVar4;
        }
        piVar3[3] = ptr_00[3];
        m_free(ptr_00);
        return;
      }
      *pool_handle = (void *)ptr_00[3];
      m_free(ptr_00);
      return;
    }
  }
  return;
}



// Setting prototype: void reset_huffman_trees(void *s)

void zlib_ct_init(void *s)

{
                    // 
                    // Resets the Huffman trees and related state within the deflate stream.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  noop();
  *(int *)((int)s + 0xb10) = (int)s + 0x8c;
  *(int *)((int)s + 0xb28) = (int)s + 0xa74;
  *(undefined ***)((int)s + 0xb18) = &PTR_DAT_10029408;
  *(int *)((int)s + 0xb1c) = (int)s + 0x980;
  *(undefined ***)((int)s + 0xb24) = &PTR_DAT_10029420;
  *(undefined **)((int)s + 0xb30) = &DAT_10029438;
  *(undefined2 *)((int)s + 0x16b0) = 0;
  *(undefined4 *)((int)s + 0x16b4) = 0;
  *(undefined4 *)((int)s + 0x16ac) = 8;
  zlib_tr_tally(s);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void noop(void)

void noop(void)

{
                    // 
                    // This is a no-operation function, it does nothing.
                    // 
  return;
}



// Setting prototype: void huffman_trees_reset(void *s)

void zlib_tr_tally(void *s)

{
  undefined2 *puVar1;
  int iVar2;
  
                    // 
                    // Resets the Huffman trees by zeroing out their data structures.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  iVar2 = 0x11e;
  puVar1 = (undefined2 *)((int)s + 0x8c);
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 2;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  puVar1 = (undefined2 *)((int)s + 0x980);
  iVar2 = 0x1e;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 2;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  puVar1 = (undefined2 *)((int)s + 0xa74);
  iVar2 = 0x13;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 2;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  *(undefined4 *)((int)s + 0x16a4) = 0;
  *(undefined4 *)((int)s + 0x16a0) = 0;
  *(undefined4 *)((int)s + 0x16a8) = 0;
  *(undefined4 *)((int)s + 0x1698) = 0;
  *(undefined2 *)((int)s + 0x48c) = 1;
  return;
}



// Setting prototype: void huffman_block(void *s, uint32_t param_2, uint32_t param_3, int param_4)

void zlib_tr_flush_block(void *s,uint32_t param_2,uint32_t param_3,int param_4)

{
  int iVar1;
  
                    // 
                    // Processes a Huffman block, writing bits to the output buffer.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   param_2: Unknown parameter.
                    //   param_3: Unknown parameter.
                    //   param_4: The value to write.
                    // 
  iVar1 = *(int *)((int)s + 0x16b4);
  if (iVar1 < 0xe) {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(param_4 << ((byte)iVar1 & 0x1f));
    *(int *)((int)s + 0x16b4) = iVar1 + 3;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(param_4 << ((byte)iVar1 & 0x1f));
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar1 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar1;
    *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
    iVar1 = *(int *)((int)s + 0x16b4);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x16b4) = iVar1 + -0xd;
    *(ushort *)((int)s + 0x16b0) = (ushort)param_4 >> (0x10U - (char)iVar1 & 0x1f);
  }
  zlib_tr_stored_block(s,(uint8_t *)param_2,param_3,1);
  return;
}



// Setting prototype: void build_huffman_trees(void *s)

void zlib_ct_tally(void *s)

{
  int iVar1;
  
                    // 
                    // Builds the Huffman trees for literal/length and distance codes.
                    // This function writes the tree descriptions to the output stream.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  iVar1 = *(int *)((int)s + 0x16b4);
  if (iVar1 < 0xe) {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(2 << ((byte)iVar1 & 0x1f));
    *(int *)((int)s + 0x16b4) = iVar1 + 3;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(2 << ((byte)iVar1 & 0x1f));
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar1 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar1;
    *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    iVar1 = *(int *)((int)s + 0x16b4);
    *(int *)((int)s + 0x16b4) = iVar1 + -0xd;
    *(ushort *)((int)s + 0x16b0) = 2 >> (0x10U - (char)iVar1 & 0x1f);
  }
  iVar1 = *(int *)((int)s + 0x16b4);
  if (iVar1 < 10) {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(0x70000 << ((byte)iVar1 & 0x1f));
    *(int *)((int)s + 0x16b4) = iVar1 + 7;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(0 << ((byte)iVar1 & 0x1f));
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar1 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar1;
    *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
    iVar1 = *(int *)((int)s + 0x16b4);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x16b4) = iVar1 + -9;
    *(ushort *)((int)s + 0x16b0) = 0 >> (0x10U - (char)iVar1 & 0x1f);
  }
  zlib_bi_windup(s);
  iVar1 = *(int *)((int)s + 0x16b4);
  if ((*(int *)((int)s + 0x16ac) - iVar1) + 0xb < 9) {
    if (iVar1 < 0xe) {
      *(ushort *)((int)s + 0x16b0) =
           *(ushort *)((int)s + 0x16b0) | (ushort)(2 << ((byte)iVar1 & 0x1f));
      *(int *)((int)s + 0x16b4) = iVar1 + 3;
    }
    else {
      *(ushort *)((int)s + 0x16b0) =
           *(ushort *)((int)s + 0x16b0) | (ushort)(2 << ((byte)iVar1 & 0x1f));
      *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
           *(undefined1 *)((int)s + 0x16b0);
      iVar1 = *(int *)((int)s + 0x14) + 1;
      *(int *)((int)s + 0x14) = iVar1;
      *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
      *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
      iVar1 = *(int *)((int)s + 0x16b4);
      *(int *)((int)s + 0x16b4) = iVar1 + -0xd;
      *(ushort *)((int)s + 0x16b0) = 2 >> (0x10U - (char)iVar1 & 0x1f);
    }
    iVar1 = *(int *)((int)s + 0x16b4);
    if (iVar1 < 10) {
      *(ushort *)((int)s + 0x16b0) =
           *(ushort *)((int)s + 0x16b0) | (ushort)(0x70000 << ((byte)iVar1 & 0x1f));
      *(int *)((int)s + 0x16b4) = iVar1 + 7;
    }
    else {
      *(ushort *)((int)s + 0x16b0) =
           *(ushort *)((int)s + 0x16b0) | (ushort)(0 << ((byte)iVar1 & 0x1f));
      *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
           *(undefined1 *)((int)s + 0x16b0);
      iVar1 = *(int *)((int)s + 0x14) + 1;
      *(int *)((int)s + 0x14) = iVar1;
      *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
      iVar1 = *(int *)((int)s + 0x16b4);
      *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
      *(int *)((int)s + 0x16b4) = iVar1 + -9;
      *(ushort *)((int)s + 0x16b0) = 0 >> (0x10U - (char)iVar1 & 0x1f);
    }
    zlib_bi_windup(s);
  }
  *(undefined4 *)((int)s + 0x16ac) = 7;
  return;
}



// Setting prototype: void huffman_encode(void *s, uint32_t block_start, uint32_t block_len, int
// last_block)

void zlib_bi_flush(void *s,uint32_t block_start,uint32_t block_len,int last_block)

{
  int iVar1;
  void *tree_desc;
  byte bVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  
                    // 
                    // Encodes a block of data using Huffman coding.
                    // This function determines whether to use static or dynamic Huffman trees based
                    // on optimality.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   block_start: Starting offset of the block in the input buffer.
                    //   block_len: Length of the block to encode.
                    //   last_block: Flag indicating if this is the last block.
                    // 
  tree_desc = (void *)0x0;
  if (*(int *)((int)s + 0x7c) < 1) {
    uVar3 = block_len + 5;
  }
  else {
    if (*(char *)((int)s + 0x1c) == '\x02') {
      zlib_build_bl_tree(s);
    }
    tree_desc = (void *)((int)s + 0xb10);
    zlib_build_tree(s,tree_desc);
    zlib_build_tree(s,(void *)((int)s + 0xb1c));
    zlib_zlib_build_static_trees(s);
    uVar4 = *(int *)((int)s + 0x16a0) + 10U >> 3;
    uVar3 = *(int *)((int)s + 0x16a4) + 10U >> 3;
    if (uVar4 < uVar3) goto LAB_1000731a;
  }
  uVar4 = uVar3;
LAB_1000731a:
  if ((uVar4 < block_len + 4) || (block_start == 0)) {
    iVar5 = *(int *)((int)s + 0x16b4);
    bVar2 = (byte)iVar5;
    if (uVar3 == uVar4) {
      iVar1 = last_block + 2;
      if (iVar5 < 0xe) {
        *(ushort *)((int)s + 0x16b0) =
             *(ushort *)((int)s + 0x16b0) | (ushort)(iVar1 << (bVar2 & 0x1f));
        *(int *)((int)s + 0x16b4) = iVar5 + 3;
      }
      else {
        *(ushort *)((int)s + 0x16b0) =
             *(ushort *)((int)s + 0x16b0) | (ushort)(iVar1 << (bVar2 & 0x1f));
        *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
             *(undefined1 *)((int)s + 0x16b0);
        iVar5 = *(int *)((int)s + 0x14) + 1;
        *(int *)((int)s + 0x14) = iVar5;
        *(undefined1 *)(*(int *)((int)s + 8) + iVar5) = *(undefined1 *)((int)s + 0x16b1);
        iVar5 = *(int *)((int)s + 0x16b4);
        *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
        *(int *)((int)s + 0x16b4) = iVar5 + -0xd;
        *(ushort *)((int)s + 0x16b0) = (ushort)iVar1 >> (0x10U - (char)iVar5 & 0x1f);
      }
      zlib_send_all_trees(s,&DAT_10024a04,&DAT_10024e84);
    }
    else {
      iVar1 = last_block + 4;
      if (iVar5 < 0xe) {
        *(ushort *)((int)s + 0x16b0) =
             *(ushort *)((int)s + 0x16b0) | (ushort)(iVar1 << (bVar2 & 0x1f));
        *(int *)((int)s + 0x16b4) = iVar5 + 3;
      }
      else {
        *(ushort *)((int)s + 0x16b0) =
             *(ushort *)((int)s + 0x16b0) | (ushort)(iVar1 << (bVar2 & 0x1f));
        *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
             *(undefined1 *)((int)s + 0x16b0);
        iVar5 = *(int *)((int)s + 0x14) + 1;
        *(int *)((int)s + 0x14) = iVar5;
        *(undefined1 *)(iVar5 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
        iVar5 = *(int *)((int)s + 0x16b4);
        *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
        *(int *)((int)s + 0x16b4) = iVar5 + -0xd;
        *(ushort *)((int)s + 0x16b0) = (ushort)iVar1 >> (0x10U - (char)iVar5 & 0x1f);
      }
      zlib_send_tree(s,*(int *)((int)s + 0xb14) + 1,*(int *)((int)s + 0xb20) + 1,(int)tree_desc + 1)
      ;
      zlib_send_all_trees(s,(void *)((int)s + 0x8c),(void *)((int)s + 0x980));
    }
  }
  else {
    zlib_tr_flush_block(s,block_start,block_len,last_block);
  }
  zlib_tr_tally(s);
  if (last_block != 0) {
    zlib_bi_align(s);
  }
  return;
}



// Setting prototype: void huffman_build_tree(void *s, void *tree_desc)

void zlib_build_tree(void *s,void *tree_desc)

{
  byte bVar1;
  short *tree;
  void *s_00;
  byte bVar2;
  int iVar3;
  short *psVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int local_8;
  int local_4;
  
                    // 
                    // Builds a Huffman tree from a set of frequencies.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   tree_desc: Pointer to the Huffman tree description structure.
                    // 
  s_00 = s;
                    // WARNING: Load size is inaccurate
  tree = *tree_desc;
  iVar6 = -1;
  iVar5 = **(int **)((int)tree_desc + 8);
  local_4 = (*(int **)((int)tree_desc + 8))[3];
  iVar3 = 0;
  local_8 = -1;
  *(undefined4 *)((int)s + 0x1448) = 0;
  *(undefined4 *)((int)s + 0x144c) = 0x23d;
  psVar4 = tree;
  if (0 < local_4) {
    do {
      if (*psVar4 == 0) {
        psVar4[1] = 0;
      }
      else {
        iVar6 = *(int *)((int)s + 0x1448) + 1;
        *(int *)((int)s + 0x1448) = iVar6;
        *(int *)((int)s + iVar6 * 4 + 0xb54) = iVar3;
        *(undefined1 *)(iVar3 + 0x1450 + (int)s) = 0;
        iVar6 = iVar3;
        local_8 = iVar3;
      }
      iVar3 = iVar3 + 1;
      psVar4 = psVar4 + 2;
    } while (iVar3 < local_4);
  }
  iVar3 = *(int *)((int)s + 0x1448);
  while (iVar3 < 2) {
    if (iVar6 < 2) {
      iVar7 = iVar6 + 1;
      iVar6 = iVar7;
    }
    else {
      iVar7 = 0;
    }
    *(int *)((int)s + 0x1448) = iVar3 + 1;
    *(int *)((int)s + (iVar3 + 1) * 4 + 0xb54) = iVar7;
    tree[iVar7 * 2] = 1;
    *(undefined1 *)((int)s + iVar7 + 0x1450) = 0;
    *(int *)((int)s + 0x16a0) = *(int *)((int)s + 0x16a0) + -1;
    if (iVar5 != 0) {
      *(uint *)((int)s + 0x16a4) =
           *(int *)((int)s + 0x16a4) - (uint)*(ushort *)(iVar5 + 2 + iVar7 * 4);
    }
    local_8 = iVar6;
    iVar3 = *(int *)((int)s + 0x1448);
  }
  *(int *)((int)tree_desc + 4) = iVar6;
  for (iVar5 = *(int *)((int)s + 0x1448) / 2; 0 < iVar5; iVar5 = iVar5 + -1) {
    zlib_pqdownheap(s,tree,iVar5);
  }
  s = tree + local_4 * 2;
  do {
    iVar5 = *(int *)((int)s_00 + 0xb58);
    *(undefined4 *)((int)s_00 + 0xb58) =
         *(undefined4 *)((int)s_00 + *(int *)((int)s_00 + 0x1448) * 4 + 0xb54);
    *(int *)((int)s_00 + 0x1448) = *(int *)((int)s_00 + 0x1448) + -1;
    zlib_pqdownheap(s_00,tree,1);
    iVar6 = *(int *)((int)s_00 + 0xb58);
    iVar3 = *(int *)((int)s_00 + 0x144c) + -1;
    *(int *)((int)s_00 + 0x144c) = iVar3;
    *(int *)((int)s_00 + iVar3 * 4 + 0xb54) = iVar5;
    iVar3 = *(int *)((int)s_00 + 0x144c) + -1;
    *(int *)((int)s_00 + 0x144c) = iVar3;
    *(int *)((int)s_00 + iVar3 * 4 + 0xb54) = iVar6;
    *(short *)s = tree[iVar6 * 2] + tree[iVar5 * 2];
    bVar1 = *(byte *)((int)s_00 + iVar5 + 0x1450);
    bVar2 = *(byte *)((int)s_00 + iVar6 + 0x1450);
    if (bVar2 <= bVar1) {
      bVar2 = bVar1;
    }
    *(byte *)((int)s_00 + local_4 + 0x1450) = bVar2 + 1;
    tree[iVar6 * 2 + 1] = (short)local_4;
    tree[iVar5 * 2 + 1] = (short)local_4;
    *(int *)((int)s_00 + 0xb58) = local_4;
    local_4 = local_4 + 1;
    s = (void *)((int)s + 4);
    zlib_pqdownheap(s_00,tree,1);
  } while (1 < *(int *)((int)s_00 + 0x1448));
  iVar5 = *(int *)((int)s_00 + 0x144c) + -1;
  *(int *)((int)s_00 + 0x144c) = iVar5;
  *(undefined4 *)((int)s_00 + iVar5 * 4 + 0xb54) = *(undefined4 *)((int)s_00 + 0xb58);
  zlib_gen_codes(s_00,tree_desc);
  zlib_gen_bitlen(tree,local_8,(void *)((int)s_00 + 0xb34));
  return;
}



// Setting prototype: void huffman_downheap(void *s, void *tree, int k)

void zlib_pqdownheap(void *s,void *tree,int k)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  bool bVar8;
  
                    // 
                    // Performs a downheap operation on a Huffman tree.
                    // This is part of the heap-based tree construction algorithm.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   tree: Pointer to the Huffman tree array.
                    //   k: Index of the node to downheap.
                    // 
  iVar6 = *(int *)((int)s + 0x1448);
  iVar3 = *(int *)((int)s + k * 4 + 0xb54);
  iVar7 = k * 2;
  bVar8 = SBORROW4(iVar7,iVar6);
  iVar5 = iVar7 - iVar6;
  if (iVar6 < iVar7) {
    *(int *)((int)s + k * 4 + 0xb54) = iVar3;
    return;
  }
  do {
    iVar6 = iVar7;
    if (bVar8 != iVar5 < 0) {
      iVar5 = *(int *)((int)s + iVar7 * 4 + 0xb58);
      iVar4 = *(int *)((int)s + iVar7 * 4 + 0xb54);
      uVar1 = *(ushort *)((int)tree + iVar5 * 4);
      uVar2 = *(ushort *)((int)tree + iVar4 * 4);
      if ((uVar1 < uVar2) ||
         ((uVar1 == uVar2 &&
          (*(byte *)(iVar5 + 0x1450 + (int)s) <= *(byte *)((int)s + iVar4 + 0x1450))))) {
        iVar6 = iVar7 + 1;
      }
    }
    iVar5 = *(int *)((int)s + iVar6 * 4 + 0xb54);
    uVar1 = *(ushort *)((int)tree + iVar3 * 4);
    uVar2 = *(ushort *)((int)tree + iVar5 * 4);
    if (uVar1 < uVar2) break;
    if ((uVar1 == uVar2) &&
       (*(byte *)((int)s + iVar3 + 0x1450) <= *(byte *)(iVar5 + 0x1450 + (int)s))) {
      *(int *)((int)s + k * 4 + 0xb54) = iVar3;
      return;
    }
    iVar7 = iVar6 * 2;
    *(int *)((int)s + k * 4 + 0xb54) = iVar5;
    iVar4 = *(int *)((int)s + 0x1448);
    bVar8 = SBORROW4(iVar7,iVar4);
    iVar5 = iVar7 - iVar4;
    k = iVar6;
  } while (iVar5 == 0 || iVar7 < iVar4);
  *(int *)((int)s + k * 4 + 0xb54) = iVar3;
  return;
}



// Setting prototype: void huffman_gen_codes(void *s, void *tree_desc)

void zlib_gen_codes(void *s,void *tree_desc)

{
  ushort *puVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int *piVar5;
  int iVar6;
  int iVar7;
  void *pvVar8;
  uint uVar9;
  int iVar10;
  void *pvVar11;
  int iVar12;
  short *psVar13;
  ushort *puVar14;
  void *pvVar15;
  uint uVar16;
  undefined4 *puVar17;
  int iVar18;
  uint uVar19;
  int local_1c;
  int local_14;
  
                    // 
                    // Generates Huffman codes based on the code lengths in the tree description.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   tree_desc: Pointer to the Huffman tree description structure.
                    // 
  pvVar8 = s;
                    // WARNING: Load size is inaccurate
  iVar3 = *tree_desc;
  iVar4 = *(int *)((int)tree_desc + 4);
  piVar5 = *(int **)((int)tree_desc + 8);
  iVar10 = *piVar5;
  iVar6 = piVar5[1];
  uVar19 = piVar5[4];
  iVar7 = piVar5[2];
  local_1c = 0;
  puVar17 = (undefined4 *)((int)s + 0xb34);
  for (iVar12 = 8; iVar12 != 0; iVar12 = iVar12 + -1) {
    *puVar17 = 0;
    puVar17 = puVar17 + 1;
  }
  *(undefined2 *)(iVar3 + 2 + *(int *)((int)s + *(int *)((int)s + 0x144c) * 4 + 0xb54) * 4) = 0;
  iVar12 = *(int *)((int)s + 0x144c) + 1;
  if (iVar12 < 0x23d) {
    s = (void *)((int)s + iVar12 * 4 + 0xb54);
    local_14 = 0x23d - iVar12;
    pvVar15 = (void *)(iVar12 + local_14);
    do {
                    // WARNING: Load size is inaccurate
      iVar12 = *s;
      uVar9 = *(ushort *)(iVar3 + 2 + (uint)*(ushort *)(iVar3 + 2 + iVar12 * 4) * 4) + 1;
      if ((int)uVar19 < (int)uVar9) {
        local_1c = local_1c + 1;
        uVar9 = uVar19;
      }
      *(short *)(iVar3 + 2 + iVar12 * 4) = (short)uVar9;
      if (iVar12 <= iVar4) {
        psVar13 = (short *)((int)pvVar8 + uVar9 * 2 + 0xb34);
        *psVar13 = *psVar13 + 1;
        iVar18 = 0;
        if (iVar7 <= iVar12) {
          iVar18 = *(int *)(iVar6 + (iVar12 - iVar7) * 4);
        }
        uVar16 = (uint)*(ushort *)(iVar3 + iVar12 * 4);
        *(int *)((int)pvVar8 + 0x16a0) = *(int *)((int)pvVar8 + 0x16a0) + (uVar9 + iVar18) * uVar16;
        if (iVar10 != 0) {
          *(uint *)((int)pvVar8 + 0x16a4) =
               *(int *)((int)pvVar8 + 0x16a4) +
               ((uint)*(ushort *)(iVar10 + 2 + iVar12 * 4) + iVar18) * uVar16;
        }
      }
      s = (void *)((int)s + 4);
      local_14 = local_14 + -1;
    } while (local_14 != 0);
    if (local_1c != 0) {
      do {
        iVar10 = uVar19 - 1;
        psVar13 = (short *)((int)pvVar8 + iVar10 * 2 + 0xb34);
        sVar2 = *(short *)((int)pvVar8 + iVar10 * 2 + 0xb34);
        while (sVar2 == 0) {
          psVar13 = psVar13 + -1;
          iVar10 = iVar10 + -1;
          sVar2 = *psVar13;
        }
        psVar13 = (short *)((int)pvVar8 + iVar10 * 2 + 0xb34);
        *psVar13 = *psVar13 + -1;
        psVar13 = (short *)((int)pvVar8 + iVar10 * 2 + 0xb36);
        *psVar13 = *psVar13 + 2;
        psVar13 = (short *)((int)pvVar8 + uVar19 * 2 + 0xb34);
        *psVar13 = *psVar13 + -1;
        local_1c = local_1c + -2;
      } while (0 < local_1c);
      if (uVar19 != 0) {
        puVar14 = (ushort *)((int)pvVar8 + uVar19 * 2 + 0xb34);
        tree_desc = pvVar15;
        do {
          pvVar11 = (void *)(uint)*puVar14;
          if (pvVar11 != (void *)0x0) {
            iVar10 = (int)pvVar8 + (int)pvVar15 * 4 + 0xb54;
            s = pvVar11;
            do {
              iVar6 = *(int *)(iVar10 + -4);
              pvVar15 = (void *)((int)tree_desc + -1);
              iVar10 = iVar10 + -4;
              if (iVar6 <= iVar4) {
                puVar1 = (ushort *)(iVar3 + 2 + iVar6 * 4);
                uVar9 = (uint)*puVar1;
                if (uVar9 != uVar19) {
                  *(uint *)((int)pvVar8 + 0x16a0) =
                       *(int *)((int)pvVar8 + 0x16a0) +
                       (uVar19 - uVar9) * (uint)*(ushort *)(iVar3 + iVar6 * 4);
                  *puVar1 = (ushort)uVar19;
                }
                pvVar11 = (void *)((int)s - 1);
                s = pvVar11;
              }
              tree_desc = pvVar15;
            } while (pvVar11 != (void *)0x0);
          }
          uVar19 = uVar19 - 1;
          puVar14 = puVar14 + -1;
        } while (uVar19 != 0);
      }
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// Setting prototype: void huffman_gen_bit_reversed_codes(void *tree, int max_code, void *bl_count)

void zlib_gen_bitlen(void *tree,int max_code,void *bl_count)

{
  ushort uVar1;
  int iVar2;
  uint32_t uVar3;
  ushort *puVar4;
  uint num_bits;
  int iVar5;
  ushort auStack_20 [16];
  
                    // 
                    // Generates bit-reversed Huffman codes.
                    // This is used to optimize the decoding process by allowing direct lookup of
                    // codes.
                    // 
                    // Parameters:
                    //   tree: Pointer to the Huffman tree array.
                    //   max_code: Maximum code value.
                    //   bl_count: Array of bit length counts.
                    // 
  iVar2 = 0;
  puVar4 = auStack_20;
  iVar5 = 0xf;
  do {
    puVar4 = (ushort *)((int)puVar4 + 2);
    iVar2 = (uint)(ushort)(*(short *)(((int)bl_count - (int)(auStack_20 + 1)) + (int)puVar4) +
                          (short)iVar2) << 1;
    iVar5 = iVar5 + -1;
    *puVar4 = (ushort)iVar2;
  } while (iVar5 != 0);
  if (-1 < max_code) {
    iVar2 = max_code + 1;
    do {
      num_bits = (uint)*(ushort *)((int)tree + 2);
      if (num_bits != 0) {
        uVar1 = auStack_20[num_bits];
        auStack_20[num_bits] = uVar1 + 1;
        uVar3 = zlib_bi_reverse((uint)uVar1,num_bits);
        *(short *)tree = (short)uVar3;
      }
      tree = (void *)((int)tree + 4);
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
  }
  return;
}



// Setting prototype: void build_static_trees(void *s)

void zlib_zlib_build_static_trees(void *s)

{
  int iVar1;
  
                    // 
                    // Builds the static Huffman trees used in the deflate algorithm.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  zlib_scan_tree(s,(void *)((int)s + 0x8c),*(int *)((int)s + 0xb14));
  zlib_scan_tree(s,(void *)((int)s + 0x980),*(int *)((int)s + 0xb20));
  zlib_build_tree(s,(void *)((int)s + 0xb28));
  iVar1 = 0x12;
  do {
    if (*(short *)((int)s + (uint)(byte)(&DAT_100249f0)[iVar1] * 4 + 0xa76) != 0) break;
    iVar1 = iVar1 + -1;
  } while (2 < iVar1);
  *(int *)((int)s + 0x16a0) = *(int *)((int)s + 0x16a0) + iVar1 * 3 + 0x11;
  return;
}



// Setting prototype: void scan_tree(void *s, void *tree, int max_code)

void zlib_scan_tree(void *s,void *tree,int max_code)

{
  short *psVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  ushort *puVar6;
  int iVar7;
  int iVar8;
  uint local_4;
  
                    // 
                    // Scans a Huffman tree to count the occurrences of different code lengths.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   tree: Pointer to the Huffman tree array.
                    //   max_code: Maximum code value.
                    // 
  uVar2 = *(ushort *)((int)tree + 2);
  iVar8 = 0;
  local_4 = 0xffffffff;
  iVar5 = 7;
  iVar7 = 4;
  if (uVar2 == 0) {
    iVar5 = 0x8a;
    iVar7 = 3;
  }
  *(undefined2 *)((int)tree + max_code * 4 + 6) = 0xffff;
  if (-1 < max_code) {
    puVar6 = (ushort *)((int)tree + 6);
    uVar3 = (uint)uVar2;
    tree = (void *)(max_code + 1);
    do {
      uVar4 = (uint)*puVar6;
      iVar8 = iVar8 + 1;
      if ((iVar5 <= iVar8) || (uVar3 != uVar4)) {
        if (iVar8 < iVar7) {
          psVar1 = (short *)((int)s + uVar3 * 4 + 0xa74);
          *psVar1 = *psVar1 + (short)iVar8;
        }
        else if (uVar3 == 0) {
          if (iVar8 < 0xb) {
            *(short *)((int)s + 0xab8) = *(short *)((int)s + 0xab8) + 1;
          }
          else {
            *(short *)((int)s + 0xabc) = *(short *)((int)s + 0xabc) + 1;
          }
        }
        else {
          if (uVar3 != local_4) {
            psVar1 = (short *)((int)s + uVar3 * 4 + 0xa74);
            *psVar1 = *psVar1 + 1;
          }
          *(short *)((int)s + 0xab4) = *(short *)((int)s + 0xab4) + 1;
        }
        iVar8 = 0;
        local_4 = uVar3;
        if (uVar4 == 0) {
          iVar5 = 0x8a;
          iVar7 = 3;
        }
        else if (uVar3 == uVar4) {
          iVar5 = 6;
          iVar7 = 3;
        }
        else {
          iVar5 = 7;
          iVar7 = 4;
        }
      }
      puVar6 = puVar6 + 2;
      tree = (void *)((int)tree + -1);
      uVar3 = uVar4;
    } while (tree != (void *)0x0);
  }
  return;
}



// Setting prototype: void send_dynamic_tree(void *s, int num_lit_len_codes, int num_dist_codes, int
// num_code_len_codes)

void zlib_send_tree(void *s,int num_lit_len_codes,int num_dist_codes,int num_code_len_codes)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  
                    // 
                    // Sends a dynamic Huffman tree to the output stream.
                    // This includes the number of literal/length codes, distance codes, and code
                    // length codes,
                    // followed by the code lengths themselves.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   num_lit_len_codes: Number of literal/length codes.
                    //   num_dist_codes: Number of distance codes.
                    //   num_code_len_codes: Number of code length codes.
                    // 
  iVar2 = *(int *)((int)s + 0x16b4);
  if (iVar2 < 0xc) {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(num_lit_len_codes + -0x101 << ((byte)iVar2 & 0x1f))
    ;
    *(int *)((int)s + 0x16b4) = iVar2 + 5;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(num_lit_len_codes + -0x101 << ((byte)iVar2 & 0x1f))
    ;
    *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar2 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar2;
    *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
    iVar2 = *(int *)((int)s + 0x16b4);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x16b4) = iVar2 + -0xb;
    *(ushort *)((int)s + 0x16b0) =
         (ushort)(num_lit_len_codes + -0x101) >> (0x10U - (char)iVar2 & 0x1f);
  }
  iVar2 = *(int *)((int)s + 0x16b4);
  if (iVar2 < 0xc) {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(num_dist_codes + -1 << ((byte)iVar2 & 0x1f));
    *(int *)((int)s + 0x16b4) = iVar2 + 5;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(num_dist_codes + -1 << ((byte)iVar2 & 0x1f));
    *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar2 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar2;
    *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
    iVar2 = *(int *)((int)s + 0x16b4);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x16b4) = iVar2 + -0xb;
    *(ushort *)((int)s + 0x16b0) = (ushort)(num_dist_codes + -1) >> (0x10U - (char)iVar2 & 0x1f);
  }
  iVar3 = *(int *)((int)s + 0x16b4);
  iVar2 = num_code_len_codes + -4;
  if (iVar3 < 0xd) {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(iVar2 << ((byte)iVar3 & 0x1f));
    *(int *)((int)s + 0x16b4) = iVar3 + 4;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) | (ushort)(iVar2 << ((byte)iVar3 & 0x1f));
    *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar3 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar3;
    *(undefined1 *)(iVar3 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
    iVar3 = *(int *)((int)s + 0x16b4);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x16b4) = iVar3 + -0xc;
    *(ushort *)((int)s + 0x16b0) = (ushort)iVar2 >> (0x10U - (char)iVar3 & 0x1f);
  }
  iVar2 = 0;
  if (0 < num_code_len_codes) {
    do {
      iVar3 = *(int *)((int)s + 0x16b4);
      if (iVar3 < 0xe) {
        *(ushort *)((int)s + 0x16b0) =
             *(ushort *)((int)s + 0x16b0) |
             *(short *)((int)s + (uint)(byte)(&DAT_100249f0)[iVar2] * 4 + 0xa76) <<
             ((byte)iVar3 & 0x1f);
        *(int *)((int)s + 0x16b4) = iVar3 + 3;
      }
      else {
        uVar1 = *(ushort *)((int)s + (uint)(byte)(&DAT_100249f0)[iVar2] * 4 + 0xa76);
        *(ushort *)((int)s + 0x16b0) = *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar3 & 0x1f);
        *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
             *(undefined1 *)((int)s + 0x16b0);
        iVar3 = *(int *)((int)s + 0x14) + 1;
        *(int *)((int)s + 0x14) = iVar3;
        *(undefined1 *)(iVar3 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
        iVar3 = *(int *)((int)s + 0x16b4);
        *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
        *(int *)((int)s + 0x16b4) = iVar3 + -0xd;
        *(ushort *)((int)s + 0x16b0) = uVar1 >> (0x10U - (char)iVar3 & 0x1f);
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < num_code_len_codes);
  }
  zlib_send_codes(s,(void *)((int)s + 0x8c),(short)num_lit_len_codes - 1);
  zlib_send_codes(s,(void *)((int)s + 0x980),(short)num_dist_codes - 1);
  return;
}



// Setting prototype: void send_codes(void *s, void *tree, uint16_t max_code)

void zlib_send_codes(void *s,void *tree,uint16_t max_code)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  short in_stack_0000000e;
  uint local_8;
  int local_4;
  
                    // 
                    // Sends Huffman codes to the output stream based on the provided tree.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   tree: Pointer to the Huffman tree array.
                    //   max_code: Maximum code value to send.
                    // 
  local_8 = 0xffffffff;
  iVar2 = 7;
  iVar7 = 4;
  if (*(ushort *)((int)tree + 2) == 0) {
    iVar2 = 0x8a;
    iVar7 = 3;
  }
  if (-1 < in_stack_0000000e) {
    local_4 = (int)_max_code + 1;
    iVar3 = 0;
    uVar5 = (uint)*(ushort *)((int)tree + 2);
    _max_code = (ushort *)((int)tree + 6);
    do {
      iVar4 = iVar3 + 1;
      uVar6 = (uint)*_max_code;
      if ((iVar2 <= iVar4) || (uVar5 != uVar6)) {
        if (iVar4 < iVar7) {
          do {
            iVar2 = *(int *)((int)s + 0x16b4);
            uVar8 = (uint)*(ushort *)((int)s + uVar5 * 4 + 0xa76);
            if ((int)(0x10 - uVar8) < iVar2) {
              uVar1 = *(ushort *)((int)s + uVar5 * 4 + 0xa74);
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
              *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                   *(undefined1 *)((int)s + 0x16b0);
              iVar2 = *(int *)((int)s + 0x14) + 1;
              *(int *)((int)s + 0x14) = iVar2;
              *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
              *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
              *(ushort *)((int)s + 0x16b0) =
                   uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
              *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar8;
            }
            else {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) |
                   *(short *)((int)s + uVar5 * 4 + 0xa74) << ((byte)iVar2 & 0x1f);
              *(uint *)((int)s + 0x16b4) = iVar2 + uVar8;
            }
            iVar4 = iVar4 + -1;
          } while (iVar4 != 0);
        }
        else if (uVar5 == 0) {
          if (iVar4 < 0xb) {
            iVar2 = *(int *)((int)s + 0x16b4);
            uVar8 = (uint)*(ushort *)((int)s + 0xaba);
            if ((int)(0x10 - uVar8) < iVar2) {
              uVar1 = *(ushort *)((int)s + 0xab8);
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
              *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                   *(undefined1 *)((int)s + 0x16b0);
              iVar2 = *(int *)((int)s + 0x14) + 1;
              *(int *)((int)s + 0x14) = iVar2;
              *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
              *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
              *(ushort *)((int)s + 0x16b0) =
                   uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
              *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar8;
            }
            else {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | *(short *)((int)s + 0xab8) << ((byte)iVar2 & 0x1f)
              ;
              *(uint *)((int)s + 0x16b4) = iVar2 + uVar8;
            }
            iVar2 = *(int *)((int)s + 0x16b4);
            if (iVar2 < 0xe) {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | (ushort)(iVar3 + -2 << ((byte)iVar2 & 0x1f));
              iVar2 = iVar2 + 3;
LAB_10008359:
              *(int *)((int)s + 0x16b4) = iVar2;
            }
            else {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | (ushort)(iVar3 + -2 << ((byte)iVar2 & 0x1f));
              *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                   *(undefined1 *)((int)s + 0x16b0);
              iVar2 = *(int *)((int)s + 0x14) + 1;
              *(int *)((int)s + 0x14) = iVar2;
              *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
              iVar2 = *(int *)((int)s + 0x16b4);
              *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
              *(int *)((int)s + 0x16b4) = iVar2 + -0xd;
              *(ushort *)((int)s + 0x16b0) = (ushort)(iVar3 + -2) >> (0x10U - (char)iVar2 & 0x1f);
            }
          }
          else {
            iVar2 = *(int *)((int)s + 0x16b4);
            uVar8 = (uint)*(ushort *)((int)s + 0xabe);
            if ((int)(0x10 - uVar8) < iVar2) {
              uVar1 = *(ushort *)((int)s + 0xabc);
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
              *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                   *(undefined1 *)((int)s + 0x16b0);
              iVar2 = *(int *)((int)s + 0x14) + 1;
              *(int *)((int)s + 0x14) = iVar2;
              *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
              *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
              *(ushort *)((int)s + 0x16b0) =
                   uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
              *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar8;
            }
            else {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | *(short *)((int)s + 0xabc) << ((byte)iVar2 & 0x1f)
              ;
              *(uint *)((int)s + 0x16b4) = iVar2 + uVar8;
            }
            iVar2 = *(int *)((int)s + 0x16b4);
            if (iVar2 < 10) {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | (ushort)(iVar3 + -10 << ((byte)iVar2 & 0x1f));
              iVar2 = iVar2 + 7;
              goto LAB_10008359;
            }
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | (ushort)(iVar3 + -10 << ((byte)iVar2 & 0x1f));
            *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                 *(undefined1 *)((int)s + 0x16b0);
            iVar2 = *(int *)((int)s + 0x14) + 1;
            *(int *)((int)s + 0x14) = iVar2;
            *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
            iVar2 = *(int *)((int)s + 0x16b4);
            *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
            *(int *)((int)s + 0x16b4) = iVar2 + -9;
            *(ushort *)((int)s + 0x16b0) = (ushort)(iVar3 + -10) >> (0x10U - (char)iVar2 & 0x1f);
          }
        }
        else {
          if (uVar5 != local_8) {
            iVar2 = *(int *)((int)s + 0x16b4);
            uVar8 = (uint)*(ushort *)((int)s + uVar5 * 4 + 0xa76);
            iVar4 = iVar3;
            if ((int)(0x10 - uVar8) < iVar2) {
              uVar1 = *(ushort *)((int)s + uVar5 * 4 + 0xa74);
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
              *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                   *(undefined1 *)((int)s + 0x16b0);
              iVar2 = *(int *)((int)s + 0x14) + 1;
              *(int *)((int)s + 0x14) = iVar2;
              *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
              *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
              *(ushort *)((int)s + 0x16b0) =
                   uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
              *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar8;
            }
            else {
              *(ushort *)((int)s + 0x16b0) =
                   *(ushort *)((int)s + 0x16b0) |
                   *(short *)((int)s + uVar5 * 4 + 0xa74) << ((byte)iVar2 & 0x1f);
              *(uint *)((int)s + 0x16b4) = iVar2 + uVar8;
            }
          }
          iVar2 = *(int *)((int)s + 0x16b4);
          uVar8 = (uint)*(ushort *)((int)s + 0xab6);
          if ((int)(0x10 - uVar8) < iVar2) {
            uVar1 = *(ushort *)((int)s + 0xab4);
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
            *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
                 *(undefined1 *)((int)s + 0x16b0);
            iVar2 = *(int *)((int)s + 0x14) + 1;
            *(int *)((int)s + 0x14) = iVar2;
            *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
            *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
            *(ushort *)((int)s + 0x16b0) = uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f)
            ;
            *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar8;
          }
          else {
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | *(short *)((int)s + 0xab4) << ((byte)iVar2 & 0x1f);
            *(uint *)((int)s + 0x16b4) = iVar2 + uVar8;
          }
          iVar2 = *(int *)((int)s + 0x16b4);
          if (iVar2 < 0xf) {
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | (ushort)(iVar4 + -3 << ((byte)iVar2 & 0x1f));
            iVar2 = iVar2 + 2;
            goto LAB_10008359;
          }
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) | (ushort)(iVar4 + -3 << ((byte)iVar2 & 0x1f));
          *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
               *(undefined1 *)((int)s + 0x16b0);
          iVar2 = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x14) = iVar2;
          *(undefined1 *)(iVar2 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
          iVar2 = *(int *)((int)s + 0x16b4);
          *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x16b4) = iVar2 + -0xe;
          *(ushort *)((int)s + 0x16b0) = (ushort)(iVar4 + -3) >> (0x10U - (char)iVar2 & 0x1f);
        }
        iVar4 = 0;
        local_8 = uVar5;
        if (uVar6 == 0) {
          iVar2 = 0x8a;
          iVar7 = 3;
        }
        else if (uVar5 == uVar6) {
          iVar2 = 6;
          iVar7 = 3;
        }
        else {
          iVar2 = 7;
          iVar7 = 4;
        }
      }
      _max_code = _max_code + 2;
      local_4 = local_4 + -1;
      iVar3 = iVar4;
      uVar5 = uVar6;
    } while (local_4 != 0);
  }
  return;
}



// Setting prototype: void send_literal_dist_trees(void *s, void *lit_len_tree, void *dist_tree)

void zlib_send_all_trees(void *s,void *lit_len_tree,void *dist_tree)

{
  ushort uVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  
                    // 
                    // Sends literal/length and distance Huffman trees to the output stream.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   lit_len_tree: Pointer to the literal/length Huffman tree.
                    //   dist_tree: Pointer to the distance Huffman tree.
                    // 
  uVar3 = 0;
  if (*(int *)((int)s + 0x1698) != 0) {
    do {
      uVar8 = (uint)*(ushort *)(*(int *)((int)s + 0x169c) + uVar3 * 2);
      uVar10 = (uint)*(byte *)(uVar3 + *(int *)((int)s + 0x1690));
      uVar3 = uVar3 + 1;
      if (uVar8 == 0) {
        uVar8 = (uint)*(ushort *)((int)lit_len_tree + uVar10 * 4 + 2);
        iVar4 = *(int *)((int)s + 0x16b4);
        if ((int)(0x10 - uVar8) < iVar4) {
          uVar1 = *(ushort *)((int)lit_len_tree + uVar10 * 4);
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar4 & 0x1f);
          *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
               *(undefined1 *)((int)s + 0x16b0);
          iVar5 = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x14) = iVar5;
          *(undefined1 *)(iVar5 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
          *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
          iVar4 = *(int *)((int)s + 0x16b4) + -0x10 + uVar8;
          *(ushort *)((int)s + 0x16b0) = uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
        }
        else {
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) |
               *(short *)((int)lit_len_tree + uVar10 * 4) << ((byte)iVar4 & 0x1f);
          iVar4 = iVar4 + uVar8;
        }
LAB_10008737:
        *(int *)((int)s + 0x16b4) = iVar4;
      }
      else {
        uVar7 = (uint)(byte)(&DAT_100250fc)[uVar10];
        uVar9 = (uint)*(ushort *)((int)lit_len_tree + uVar7 * 4 + 0x406);
        bVar2 = (byte)*(int *)((int)s + 0x16b4);
        if ((int)(0x10 - uVar9) < *(int *)((int)s + 0x16b4)) {
          uVar1 = *(ushort *)((int)lit_len_tree + uVar7 * 4 + 0x404);
          *(ushort *)((int)s + 0x16b0) = *(ushort *)((int)s + 0x16b0) | uVar1 << (bVar2 & 0x1f);
          *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
               *(undefined1 *)((int)s + 0x16b0);
          iVar5 = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x14) = iVar5;
          *(undefined1 *)(*(int *)((int)s + 8) + iVar5) = *(undefined1 *)((int)s + 0x16b1);
          *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
          *(ushort *)((int)s + 0x16b0) = uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
          *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar9;
        }
        else {
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) |
               *(short *)((int)lit_len_tree + uVar7 * 4 + 0x404) << (bVar2 & 0x1f);
          *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + uVar9;
        }
        iVar5 = *(int *)(&DAT_100248b8 + uVar7 * 4);
        if (iVar5 != 0) {
          iVar6 = uVar10 - *(int *)(&DAT_100251fc + uVar7 * 4);
          iVar4 = *(int *)((int)s + 0x16b4);
          if (0x10 - iVar5 < iVar4) {
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | (ushort)(iVar6 << ((byte)iVar4 & 0x1f));
            *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
                 *(undefined1 *)((int)s + 0x16b0);
            iVar4 = *(int *)((int)s + 0x14) + 1;
            *(int *)((int)s + 0x14) = iVar4;
            *(undefined1 *)(*(int *)((int)s + 8) + iVar4) = *(undefined1 *)((int)s + 0x16b1);
            *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
            *(ushort *)((int)s + 0x16b0) =
                 (ushort)iVar6 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
            *(int *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + iVar5;
          }
          else {
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | (ushort)(iVar6 << ((byte)iVar4 & 0x1f));
            *(int *)((int)s + 0x16b4) = iVar4 + iVar5;
          }
        }
        uVar10 = uVar8 - 1;
        if (uVar10 < 0x100) {
          bVar2 = (&DAT_10024efb)[uVar8];
        }
        else {
          bVar2 = (&DAT_10024ffc)[uVar10 >> 7];
        }
        uVar8 = (uint)bVar2;
        iVar5 = *(int *)((int)s + 0x16b4);
        uVar7 = (uint)*(ushort *)((int)dist_tree + uVar8 * 4 + 2);
        if ((int)(0x10 - uVar7) < iVar5) {
          uVar1 = *(ushort *)((int)dist_tree + uVar8 * 4);
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar5 & 0x1f);
          *(undefined1 *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) =
               *(undefined1 *)((int)s + 0x16b0);
          iVar5 = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x14) = iVar5;
          *(undefined1 *)(*(int *)((int)s + 8) + iVar5) = *(undefined1 *)((int)s + 0x16b1);
          *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
          *(ushort *)((int)s + 0x16b0) = uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
          *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar7;
        }
        else {
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) |
               *(short *)((int)dist_tree + uVar8 * 4) << ((byte)iVar5 & 0x1f);
          *(uint *)((int)s + 0x16b4) = iVar5 + uVar7;
        }
        iVar5 = *(int *)(&DAT_1002492c + uVar8 * 4);
        if (iVar5 != 0) {
          iVar6 = uVar10 - *(int *)(&DAT_10025270 + uVar8 * 4);
          iVar4 = *(int *)((int)s + 0x16b4);
          if (iVar4 <= 0x10 - iVar5) {
            *(ushort *)((int)s + 0x16b0) =
                 *(ushort *)((int)s + 0x16b0) | (ushort)(iVar6 << ((byte)iVar4 & 0x1f));
            iVar4 = iVar4 + iVar5;
            goto LAB_10008737;
          }
          *(ushort *)((int)s + 0x16b0) =
               *(ushort *)((int)s + 0x16b0) | (ushort)(iVar6 << ((byte)iVar4 & 0x1f));
          *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
               *(undefined1 *)((int)s + 0x16b0);
          iVar4 = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x14) = iVar4;
          *(undefined1 *)(iVar4 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
          iVar4 = *(int *)((int)s + 0x16b4);
          *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
          *(int *)((int)s + 0x16b4) = iVar4 + -0x10 + iVar5;
          *(ushort *)((int)s + 0x16b0) = (ushort)iVar6 >> (0x10U - (char)iVar4 & 0x1f);
        }
      }
    } while (uVar3 < *(uint *)((int)s + 0x1698));
  }
  iVar5 = *(int *)((int)s + 0x16b4);
  uVar3 = (uint)*(ushort *)((int)lit_len_tree + 0x402);
  if ((int)(0x10 - uVar3) < iVar5) {
    uVar1 = *(ushort *)((int)lit_len_tree + 0x400);
    *(ushort *)((int)s + 0x16b0) = *(ushort *)((int)s + 0x16b0) | uVar1 << ((byte)iVar5 & 0x1f);
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar5 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar5;
    *(undefined1 *)(iVar5 + *(int *)((int)s + 8)) = *(undefined1 *)((int)s + 0x16b1);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(ushort *)((int)s + 0x16b0) = uVar1 >> (0x10U - (char)*(int *)((int)s + 0x16b4) & 0x1f);
    *(uint *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -0x10 + uVar3;
  }
  else {
    *(ushort *)((int)s + 0x16b0) =
         *(ushort *)((int)s + 0x16b0) |
         *(short *)((int)lit_len_tree + 0x400) << ((byte)iVar5 & 0x1f);
    *(uint *)((int)s + 0x16b4) = iVar5 + uVar3;
  }
  *(uint *)((int)s + 0x16ac) = (uint)*(ushort *)((int)lit_len_tree + 0x402);
  return;
}



// Setting prototype: void check_dynamic_tree_optimality(void *s)

void zlib_build_bl_tree(void *s)

{
  ushort uVar1;
  ushort *puVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
                    // 
                    // Checks the optimality of dynamic Huffman trees by comparing their encoded
                    // size.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  uVar5 = 0;
  uVar4 = 0;
  puVar2 = (ushort *)((int)s + 0x8c);
  iVar3 = 7;
  do {
    uVar1 = *puVar2;
    puVar2 = puVar2 + 2;
    uVar4 = uVar4 + uVar1;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  puVar2 = (ushort *)((int)s + 0xa8);
  iVar3 = 0x79;
  do {
    uVar1 = *puVar2;
    puVar2 = puVar2 + 2;
    uVar5 = uVar5 + uVar1;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  puVar2 = (ushort *)((int)s + 0x28c);
  iVar3 = 0x80;
  do {
    uVar1 = *puVar2;
    puVar2 = puVar2 + 2;
    uVar4 = uVar4 + uVar1;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  *(bool *)((int)s + 0x1c) = uVar4 <= uVar5 >> 2;
  return;
}



// Setting prototype: uint32_t reverse_bits(uint32_t value, int num_bits)

uint32_t zlib_bi_reverse(uint32_t value,int num_bits)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
                    // 
                    // Reverses the order of the lower `num_bits` bits of `value`.
                    // 
                    // Parameters:
                    //   value: The input value.
                    //   num_bits: The number of bits to reverse.
                    // 
                    // Return values:
                    //   The value with the specified bits reversed.
                    // 
  uVar1 = 0;
  do {
    uVar2 = uVar1;
    uVar3 = value & 1;
    value = value >> 1;
    num_bits = num_bits + -1;
    uVar1 = (uVar2 | uVar3) << 1;
  } while (0 < num_bits);
  return uVar2 & 0x7fffffff | uVar3;
}



// Setting prototype: void flush_bits(void *s)

void zlib_bi_windup(void *s)

{
  int iVar1;
  
                    // 
                    // Flushes pending bits to the output buffer.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  if (*(int *)((int)s + 0x16b4) == 0x10) {
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar1 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar1;
    *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(undefined2 *)((int)s + 0x16b0) = 0;
    *(undefined4 *)((int)s + 0x16b4) = 0;
    return;
  }
  if (7 < *(int *)((int)s + 0x16b4)) {
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(ushort *)((int)s + 0x16b0) = (ushort)*(byte *)((int)s + 0x16b1);
    *(int *)((int)s + 0x16b4) = *(int *)((int)s + 0x16b4) + -8;
  }
  return;
}



// Setting prototype: void align_bits(void *s)

void zlib_bi_align(void *s)

{
  int iVar1;
  
                    // 
                    // Aligns the bit stream to a byte boundary by flushing any remaining bits.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    // 
  if (8 < *(int *)((int)s + 0x16b4)) {
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    iVar1 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar1;
    *(undefined1 *)(*(int *)((int)s + 8) + iVar1) = *(undefined1 *)((int)s + 0x16b1);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    *(undefined2 *)((int)s + 0x16b0) = 0;
    *(undefined4 *)((int)s + 0x16b4) = 0;
    return;
  }
  if (0 < *(int *)((int)s + 0x16b4)) {
    *(undefined1 *)(*(int *)((int)s + 8) + *(int *)((int)s + 0x14)) =
         *(undefined1 *)((int)s + 0x16b0);
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
  }
  *(undefined2 *)((int)s + 0x16b0) = 0;
  *(undefined4 *)((int)s + 0x16b4) = 0;
  return;
}



// Setting prototype: void send_stored_block(void *s, uint8_t *buf, uint32_t len, int last_block)

void zlib_tr_stored_block(void *s,uint8_t *buf,uint32_t len,int last_block)

{
  byte bVar1;
  int iVar2;
  
                    // 
                    // Sends a stored (uncompressed) block to the output stream.
                    // 
                    // Parameters:
                    //   s: Pointer to the deflate_state structure.
                    //   buf: Pointer to the input buffer containing the data.
                    //   len: Length of the data to send.
                    //   last_block: Flag indicating if this is the last block.
                    // 
  zlib_bi_align(s);
  *(undefined4 *)((int)s + 0x16ac) = 8;
  if (last_block != 0) {
    *(byte *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) = (byte)len;
    iVar2 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar2;
    bVar1 = (byte)(len >> 8);
    *(byte *)(iVar2 + *(int *)((int)s + 8)) = bVar1;
    iVar2 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar2;
    *(byte *)(iVar2 + *(int *)((int)s + 8)) = ~(byte)len;
    iVar2 = *(int *)((int)s + 0x14) + 1;
    *(int *)((int)s + 0x14) = iVar2;
    *(byte *)(iVar2 + *(int *)((int)s + 8)) = ~bVar1;
    *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
  }
  if (len != 0) {
    do {
      *(uint8_t *)(*(int *)((int)s + 0x14) + *(int *)((int)s + 8)) = *buf;
      buf = buf + 1;
      len = len - 1;
      *(int *)((int)s + 0x14) = *(int *)((int)s + 0x14) + 1;
    } while (len != 0);
  }
  return;
}



// Setting prototype: int file_close(void *file_ptr)

int file_close(void *file_ptr)

{
                    // 
                    // Closes a file and frees its associated memory.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the file structure.
                    // 
                    // Return values:
                    //   Z_OK (0) if successful, or an error code.
                    // 
  if (file_ptr == (void *)0x0) {
    return -0x66;
  }
  if (*(int *)((int)file_ptr + 0x7c) != 0) {
    file_close_and_free(file_ptr);
  }
                    // WARNING: Load size is inaccurate
  fclose_wrapper(*file_ptr);
  free_memory(file_ptr);
  return 0;
}



// Setting prototype: int file_read(void *file_ptr, void *buffer, uint32_t length)

int file_read(void *file_ptr,void *buffer,uint32_t length)

{
  int *piVar1;
  byte *buf;
  int iVar2;
  uint32_t uVar3;
  uint uVar4;
  uint32_t uVar5;
  uint uVar6;
  int local_8;
  int local_4;
  
                    // 
                    // Reads data from a file, handling both compressed (Zlib) and uncompressed
                    // data.
                    // It manages internal buffers, performs CRC32 checks, and interacts with the
                    // inflate process.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the file structure.
                    //   buffer: Pointer to the destination buffer.
                    //   length: The number of bytes to read.
                    // 
                    // Return values:
                    //   The number of bytes read, or an error code.
                    // 
  local_4 = 0;
  local_8 = 0;
  if (file_ptr == (void *)0x0) {
    return -0x66;
  }
  piVar1 = *(int **)((int)file_ptr + 0x7c);
  if (piVar1 == (int *)0x0) {
    return -0x66;
  }
  if (*piVar1 == 0) {
    return -100;
  }
  if (length != 0) {
    piVar1[5] = length;
    piVar1[4] = (int)buffer;
    if ((uint)piVar1[0x17] < length) {
      piVar1[5] = piVar1[0x17];
    }
    if (piVar1[5] != 0) {
      do {
        if ((piVar1[2] == 0) && (uVar6 = piVar1[0x16], uVar6 != 0)) {
          uVar5 = 0x4000;
          if ((uVar6 < 0x4000) && (uVar5 = uVar6, uVar6 == 0)) {
            return 0;
          }
          iVar2 = file_seek((void *)piVar1[0x18],piVar1[0x1a] + piVar1[0xf],0);
          if (iVar2 != 0) {
            return -1;
          }
          uVar3 = file_read_3((void *)*piVar1,uVar5,1,(void *)piVar1[0x18]);
          if (uVar3 != 1) {
            return -1;
          }
          piVar1[0xf] = piVar1[0xf] + uVar5;
          piVar1[0x16] = piVar1[0x16] - uVar5;
          piVar1[1] = *piVar1;
          piVar1[2] = uVar5;
        }
        if (piVar1[0x19] == 0) {
          uVar6 = piVar1[2];
          if ((uint)piVar1[5] < (uint)piVar1[2]) {
            uVar6 = piVar1[5];
          }
          uVar4 = 0;
          if (uVar6 != 0) {
            do {
              *(undefined1 *)(piVar1[4] + uVar4) = *(undefined1 *)(piVar1[1] + uVar4);
              uVar4 = uVar4 + 1;
            } while (uVar4 < uVar6);
          }
          uVar5 = zlib_crc32(piVar1[0x14],(byte *)piVar1[4],uVar6);
          piVar1[0x14] = uVar5;
          piVar1[0x17] = piVar1[0x17] - uVar6;
          piVar1[2] = piVar1[2] - uVar6;
          local_8 = local_8 + uVar6;
          piVar1[5] = piVar1[5] - uVar6;
          piVar1[4] = piVar1[4] + uVar6;
          piVar1[1] = piVar1[1] + uVar6;
          piVar1[6] = piVar1[6] + uVar6;
        }
        else {
          iVar2 = piVar1[6];
          buf = (byte *)piVar1[4];
          local_4 = zlib_inflate_blocks(piVar1 + 1,2);
          uVar3 = piVar1[6] - iVar2;
          uVar5 = zlib_crc32(piVar1[0x14],buf,uVar3);
          piVar1[0x14] = uVar5;
          local_8 = local_8 + uVar3;
          piVar1[0x17] = piVar1[0x17] - uVar3;
          if (local_4 == 1) {
            return local_8;
          }
          if (local_4 != 0) {
            return local_4;
          }
        }
      } while (piVar1[5] != 0);
      if (local_4 != 0) {
        return local_4;
      }
    }
    return local_8;
  }
  return 0;
}



// Setting prototype: int file_close_and_free(void *file_ptr)

int file_close_and_free(void *file_ptr)

{
  undefined4 *ptr;
  int iVar1;
  
                    // 
                    // Closes a file and frees its associated memory, including any inflate stream
                    // data.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the file structure.
                    // 
                    // Return values:
                    //   Z_OK (0) if successful, or an error code.
                    // 
  iVar1 = 0;
  if (file_ptr == (void *)0x0) {
    return -0x66;
  }
  ptr = *(undefined4 **)((int)file_ptr + 0x7c);
  if (ptr == (undefined4 *)0x0) {
    return -0x66;
  }
  if ((ptr[0x17] == 0) && (ptr[0x14] != ptr[0x15])) {
    iVar1 = -0x69;
  }
  if ((void *)*ptr != (void *)0x0) {
    free_memory((void *)*ptr);
  }
  *ptr = 0;
  if (ptr[0x10] != 0) {
    zlib_inflate_blocks_free(ptr + 1);
  }
  ptr[0x10] = 0;
  free_memory(ptr);
  *(undefined4 *)((int)file_ptr + 0x7c) = 0;
  return iVar1;
}



// Setting prototype: uint32_t file_read_data(void *file_data)

uint32_t file_read_data(void *file_data)

{
  byte bVar1;
  void *file_handle;
  undefined1 *puVar2;
  uint uVar3;
  int iVar4;
  uint32_t uVar5;
  
                    // 
                    // Reads data from a file, handling different file types and compression
                    // methods.
                    // It also performs cleanup based on the file properties.
                    // 
                    // Parameters:
                    //   file_data: Pointer to the file data structure.
                    // 
                    // Return values:
                    //   A status code or relevant data from the file operation.
                    // 
  uVar5 = 0;
  if (file_data == (void *)0x0) {
    return 0;
  }
  bVar1 = *(byte *)((int)file_data + 0x13c);
  if ((bVar1 & 0x20) == 0) {
    file_handle = *(void **)((int)file_data + 0x100);
    if (file_handle != (void *)0x0) {
      if (((bVar1 & 1) == 0) || ((bVar1 & 0x10) == 0)) {
        if ((bVar1 & 8) == 0) {
          fclose_wrapper(file_handle);
        }
        else {
          zlib_closeStream(file_handle);
        }
      }
      else {
        file_close_and_free(file_handle);
        file_close(*(void **)((int)file_data + 0x100));
      }
    }
  }
  else {
    if ((bVar1 & 8) != 0) {
      if ((bVar1 & 1) == 0) {
        zlib_deflate((void *)((int)file_data + 0x100),4);
        zlib_deflateEnd((void *)((int)file_data + 0x100));
        if (7 < *(uint *)((int)file_data + 0x110)) {
          puVar2 = *(undefined1 **)((int)file_data + 0x10c);
          uVar3 = *(uint *)((int)file_data + 0x138);
          iVar4 = 4;
          do {
            *puVar2 = (char)uVar3;
            uVar3 = uVar3 >> 8;
            puVar2 = puVar2 + 1;
            iVar4 = iVar4 + -1;
          } while (iVar4 != 0);
          uVar3 = *(uint *)((int)file_data + 0x108);
          iVar4 = 4;
          do {
            *puVar2 = (char)uVar3;
            uVar3 = uVar3 >> 8;
            puVar2 = puVar2 + 1;
            iVar4 = iVar4 + -1;
          } while (iVar4 != 0);
          *(int *)((int)file_data + 0x114) = *(int *)((int)file_data + 0x114) + 8;
          *(int *)((int)file_data + 0x10c) = *(int *)((int)file_data + 0x10c) + 8;
          *(int *)((int)file_data + 0x110) = *(int *)((int)file_data + 0x110) + -8;
        }
      }
      else {
        zlib_inflate_blocks_free((void *)((int)file_data + 0x100));
      }
    }
    if ((*(byte *)((int)file_data + 0x13c) & 1) == 0) {
      uVar5 = *(uint32_t *)((int)file_data + 0x114);
    }
  }
  DAT_10034678 = DAT_10034678 + -1;
  m_pool_free((void **)&DAT_10034670,file_data);
  return uVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: uint32_t vfs_read(void *buffer, int element_size, int element_count, void
// *file_data)

uint32_t vfs_read(void *buffer,int element_size,int element_count,void *file_data)

{
  byte bVar1;
  uint32_t uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  undefined4 *file_handle;
  CHAR local_110 [256];
  int *local_10;
  uint32_t local_c;
  uint local_8;
  
                    // 
                    // Reads data from a virtual file system (VFS) entry.
                    // This function handles different file types, including compressed and
                    // uncompressed data,
                    // and manages the internal state of the VFS entry.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the destination buffer.
                    //   element_size: The size of each element to read.
                    //   element_count: The number of elements to read.
                    //   file_data: Pointer to the VFS file data structure.
                    // 
                    // Return values:
                    //   The number of bytes read, or an error code.
                    // 
  local_8 = 0xffffffff;
  if ((file_data != (void *)0x0) && (bVar1 = *(byte *)((int)file_data + 0x13c), (bVar1 & 1) != 0)) {
    local_10 = (int *)((int)file_data + 0x100);
    file_handle = (undefined4 *)*local_10;
    if ((file_handle != (undefined4 *)0x0) || ((bVar1 & 0x20) != 0)) {
      local_c = element_size * element_count;
      if ((((bVar1 & 0x20) != 0) && ((bVar1 & 8) == 0)) &&
         (*(uint *)((int)file_data + 0x104) < local_c)) {
        local_c = *(uint *)((int)file_data + 0x104);
      }
      uVar2 = local_c;
      if (local_c == 0) {
        return 0;
      }
      if (buffer != (void *)0x0) {
        if ((bVar1 & 0x20) != 0) {
          if ((bVar1 & 8) != 0) {
            *(void **)((int)file_data + 0x10c) = buffer;
            *(uint32_t *)((int)file_data + 0x110) = local_c;
            zlib_inflate_blocks(local_10,2);
            return uVar2 - *(int *)((int)file_data + 0x110);
          }
          uVar3 = (int)buffer * 3 & 3;
          uVar5 = local_c - uVar3;
          uVar6 = uVar5;
          if (uVar5 != 0 && (int)uVar3 <= (int)local_c) {
            for (; uVar3 != 0; uVar3 = uVar3 - 1) {
              *(undefined1 *)buffer = *(undefined1 *)file_handle;
              file_handle = (undefined4 *)((int)file_handle + 1);
              buffer = (undefined4 *)((int)buffer + 1);
            }
            uVar6 = uVar5 & 3;
            for (uVar3 = uVar5 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
              *(undefined4 *)buffer = *file_handle;
              file_handle = file_handle + 1;
              buffer = (undefined4 *)((int)buffer + 4);
            }
          }
          for (iVar4 = uVar3 + uVar6; iVar4 != 0; iVar4 = iVar4 + -1) {
            *(undefined1 *)buffer = *(undefined1 *)file_handle;
            file_handle = (undefined4 *)((int)file_handle + 1);
            buffer = (undefined4 *)((int)buffer + 1);
          }
          *local_10 = *local_10 + local_c;
          *(uint32_t *)((int)file_data + 0x104) = *(int *)((int)file_data + 0x104) - local_c;
          *(uint32_t *)((int)file_data + 0x108) = *(int *)((int)file_data + 0x108) + local_c;
          return local_c;
        }
        if ((bVar1 & 0x10) == 0) {
          if ((bVar1 & 8) != 0) {
            uVar2 = zlib_readFromStream(file_handle,(byte *)buffer,local_c);
            return uVar2;
          }
          local_8 = file_read_3(buffer,element_size,element_count,file_handle);
        }
        else {
          local_8 = file_read(file_handle,buffer,local_c);
                    // WARNING: Load size is inaccurate
          if ((((*(byte *)((int)file_data + 0x13c) & 4) != 0) && (1 < local_8)) &&
             ((*(byte *)((int)file_data + 0x13c) = *(byte *)((int)file_data + 0x13c) & 0xfb,
              *buffer == _DAT_10029450 && (*(byte *)((int)buffer + 1) == _DAT_10029454)))) {
            printf_wrapper(local_110,s_vfs__gz_compressed_file____s___i_10029474,file_data);
            logMessage(s_D__Develop_Units_vfs_vfs_c_10029458,0x5b4,local_110,1);
            return local_8;
          }
        }
      }
    }
  }
  return local_8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: void *vfs_open(void *data, uint32_t data_len, const char *mode)

undefined1 * vfs_open(byte *data,uint data_len,char *mode)

{
  char *pcVar1;
  char cVar2;
  byte bVar3;
  bool bVar4;
  int iVar5;
  undefined1 *buffer;
  uint32_t uVar6;
  char cVar7;
  
                    // 
                    // Opens a virtual file system (VFS) entry for reading or writing.
                    // This function supports compressed (Zlib) and uncompressed data.
                    // 
                    // Parameters:
                    //   data: Pointer to the file data.
                    //   data_len: The length of the file data.
                    //   mode: The opening mode string (e.g., 'r', 'w', 'rz', 'wz').
                    // 
                    // Return values:
                    //   A pointer to the VFS file data structure, or NULL if opening fails.
                    // 
  cVar7 = '\x01';
  bVar3 = 1;
  bVar4 = true;
  if (data == (byte *)0x0) {
    return (undefined1 *)0x0;
  }
  if (data_len == 0) {
    return (undefined1 *)0x0;
  }
  cVar2 = *mode;
  while (cVar2 != '\0') {
    iVar5 = char_to_upper((int)*mode);
    switch(iVar5) {
    case 0x4e:
      cVar7 = '\0';
      goto LAB_10009092;
    case 0x52:
      bVar3 = 1;
      break;
    case 0x57:
      bVar3 = 0;
      break;
    case 0x5a:
      cVar7 = '\x01';
LAB_10009092:
      bVar4 = false;
    }
    pcVar1 = mode + 1;
    mode = mode + 1;
    cVar2 = *pcVar1;
  }
  buffer = (undefined1 *)m_pool_alloc(&DAT_10034670,0x140,0x10);
  buffer[0x13c] = buffer[0x13c] & 0xeb | 0x22;
  if (bVar3 == 0) {
    if (cVar7 != '\0') {
      if (0x11 < data_len) {
        *data = DAT_10029450;
        data[1] = DAT_10029454;
        data[2] = 8;
        data[8] = 0;
        data[7] = 0;
        data[6] = 0;
        data[5] = 0;
        data[4] = 0;
        data[3] = 0;
        data[9] = 0xb;
        *(undefined4 *)(buffer + 0x100) = 0;
        *(undefined4 *)(buffer + 0x104) = 0;
        *(byte **)(buffer + 0x10c) = data + 10;
        *(uint *)(buffer + 0x110) = data_len - 10;
        *(undefined4 *)(buffer + 0x120) = 0;
        *(undefined4 *)(buffer + 0x124) = 0;
        uVar6 = zlib_crc32(0,(byte *)0x0,0);
        *(uint32_t *)(buffer + 0x138) = uVar6;
        iVar5 = zlib_deflateInit2_(buffer + 0x100,-1,8,-0xf,8,0,s_1_1_3_1002706c,0x38);
        if (iVar5 == 0) {
          *(undefined4 *)(buffer + 0x114) = 10;
          goto LAB_10009262;
        }
      }
      goto LAB_1000921a;
    }
    *(byte **)(buffer + 0x10c) = data;
    *(uint *)(buffer + 0x110) = data_len;
    *(undefined4 *)(buffer + 0x114) = 0;
    goto LAB_10009262;
  }
  if (bVar4) {
    if (((10 < data_len) && (*data == _DAT_10029450)) && (data[1] == _DAT_10029454)) {
      cVar7 = '\x01';
LAB_1000912d:
      *(byte **)(buffer + 0x100) = data + 10;
      *(uint *)(buffer + 0x104) = data_len - 10;
      *(undefined4 *)(buffer + 0x10c) = 0;
      *(undefined4 *)(buffer + 0x110) = 0;
      *(undefined4 *)(buffer + 0x120) = 0;
      *(undefined4 *)(buffer + 0x124) = 0;
      iVar5 = zlib_inflate_blocks_new(buffer + 0x100,-0xf,s_1_1_3_1002706c,0x38);
      if (iVar5 != 0) {
LAB_1000921a:
        m_pool_free((void **)&DAT_10034670,buffer);
        return (undefined1 *)0x0;
      }
      goto LAB_10009262;
    }
    cVar7 = '\0';
  }
  else if (cVar7 != '\0') goto LAB_1000912d;
  *(byte **)(buffer + 0x100) = data;
  *(uint *)(buffer + 0x104) = data_len;
  *(undefined4 *)(buffer + 0x108) = 0;
LAB_10009262:
  if (buffer != (undefined1 *)0x0) {
    DAT_10034678 = DAT_10034678 + 1;
    buffer[0x13c] = buffer[0x13c] & 0xf6 ^ bVar3 | cVar7 << 3;
    printf_wrapper(buffer,s_0x_08X__>_length___u__read___u_c_100294a4,data,data_len,(uint)bVar3,
                   cVar7);
  }
  return buffer;
}



// Setting prototype: void *zalloc(void *opaque, uint32_t items, uint32_t size)

void zlib_zcalloc(undefined4 opaque,int items,int size)

{
                    // 
                    // Custom allocation function used by Zlib.
                    // 
                    // Parameters:
                    //   opaque: A pointer to opaque data (unused in this implementation).
                    //   items: The number of items to allocate.
                    //   size: The size of each item.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block.
                    // 
  _malloc(items * size);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int DllMain_Internal(void)

int DllMain_Internal(void)

{
                    // 
                    // Internal DllMain function.
                    // 
                    // Return values:
                    //   Always returns 1.
                    // 
  return 1;
}



// Setting prototype: BOOL Init(LPVOID params)

BOOL Init(LPVOID pServerInitParams)

{
                    // 
                    // Initializes the server by creating a new thread for the game server loop.
                    // 
                    // Parameters:
                    //   params: Pointer to server initialization parameters.
                    // 
                    // Return values:
                    //   True if the thread was created successfully, false otherwise.
                    // 
  hGameServerThread =
       CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,srv_GameLoop,pServerInitParams,0,
                    (LPDWORD)&pServerInitParams);
  return (uint)(hGameServerThread != (HANDLE)0x0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void Exit(void)

void Exit(void)

{
                    // 
                    // Handles the server exit process.
                    // It signals the game server loop to terminate, waits for its completion, and
                    // then cleans up the thread.
                    // 
  if (hGameServerThread != (HANDLE)0x0) {
    g_shutdown_flag = 1;
    do {
      Sleep(10);
    } while (g_shutdown_flag != 0);
    TerminateThread(hGameServerThread,0);
    CloseHandle(hGameServerThread);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: uint32_t gameServerLoop(void *server_params)

uint32_t srv_GameLoop(void *p_server_params)

{
  bool bVar1;
  bool bVar2;
  char *path_ptr;
  DWORD last_broadcast_time;
  int *piVar3;
  uint *puVar4;
  DWORD DVar5;
  int iVar6;
  byte *pbVar7;
  int iVar8;
  uint uVar9;
  uint *client;
  uint *puVar10;
  void *unaff_EDI;
  undefined4 *puVar11;
  uint *puVar12;
  undefined1 auStack_1e4 [3];
  undefined1 uStack_1e1;
  uint uStack_1e0;
  undefined4 uStack_1d8;
  uint uStack_1d4;
  undefined4 uStack_1d0;
  undefined4 uStack_1cc;
  undefined2 uStack_1c8;
  undefined1 auStack_148 [3];
  undefined1 uStack_145;
  undefined4 uStack_144;
  undefined4 uStack_13c;
  undefined1 uStack_138;
  uint uStack_137;
  undefined4 uStack_ac;
  undefined4 uStack_86;
  CHAR aCStack_40 [64];
  
                    // Main game server loop. This function handles client connections, processes
                    // incoming commands, sends outgoing data, and manages the overall game state
                    // and timing.
  GetModuleFileNameA((HMODULE)0x0,&DAT_101de9a0,0x104);
  path_ptr = _strrchr(&DAT_101de9a0,0x5c);
  *(undefined4 *)path_ptr = s__game_ini_1002993c._0_4_;
  *(undefined4 *)(path_ptr + 4) = s__game_ini_1002993c._4_4_;
  *(undefined2 *)(path_ptr + 8) = s__game_ini_1002993c._8_2_;
  g_server_port = GetPrivateProfileIntA(s_Config_1002992c,&DAT_10029934,0x1d6b,&DAT_101de9a0);
  g_max_players = 2;
  GetPrivateProfileStringA
            (s_General_100298f8,s_GamePath_10029900,s__project_diegildeaddon_game__1002990c,
             s__project_DieGilde_game__10029594,0x104,&DAT_101de9a0);
  puVar11 = &uStack_ac;
                    // WARNING: Load size is inaccurate
  for (iVar8 = 0x1a; iVar8 != 0; iVar8 = iVar8 + -1) {
    *puVar11 = *p_server_params;
    p_server_params = (undefined4 *)((int)p_server_params + 4);
    puVar11 = puVar11 + 1;
  }
                    // WARNING: Load size is inaccurate
  *(undefined2 *)puVar11 = *p_server_params;
  if (uStack_ac._2_2_ == 1) {
    uStack_86._0_2_ = (ushort)(byte)uStack_86;
                    // last_broadcast_time: Stores the time of the last broadcast message.
    g_max_players = (uint)(ushort)uStack_86;
  }
  else if (uStack_ac._2_2_ == 4) {
    uStack_86._0_2_ = (ushort)(byte)uStack_86;
    g_max_players = (uint)(ushort)uStack_86;
  }
  srv_InitServer();
                    // connected_players_count: Counts the number of connected players.
  printf_wrapper(aCStack_40,s_Waiting_for__li_Connection_s__100298d8,g_max_players);
                    // client_slot_ptr: Pointer to a client slot.
  logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x131,aCStack_40,1);
  last_broadcast_time = timeGetTime();
  seed_random_2(last_broadcast_time);
  last_broadcast_time = 0;
  bVar1 = false;
  do {
    if (g_shutdown_flag != 0) break;
    uVar9 = 0;
    piVar3 = &g_client_slots;
    do {
      if (*piVar3 != 0) {
        uVar9 = uVar9 + 1;
      }
      piVar3 = piVar3 + 0x99099;
    } while ((int)piVar3 < 0x114ffe20);
    srv_AcceptClient();
                    // client_slot_ptr: Pointer to a client slot.
    if (uVar9 == g_max_players) {
      bVar1 = true;
      puVar4 = &g_client_slots;
      do {
        if ((*puVar4 != 0) && ((*puVar4 & 0x800) == 0)) {
          bVar1 = false;
          goto LAB_10009553;
        }
        puVar4 = puVar4 + 0x99099;
      } while ((int)puVar4 < 0x114ffe20);
      logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x14e,
                 s_SERVER>>>>_ALL_PLAYER_ARE_READY_10029890,1);
    }
LAB_10009553:
    DVar5 = timeGetTime();
                    // current_time: Stores the current time.
    if ((3000 < DVar5 - last_broadcast_time) || (bVar1)) {
      uStack_86._0_2_ = CONCAT11((char)uVar9,(byte)uStack_86);
      send_broadcast_message();
      last_broadcast_time = timeGetTime();
    }
    iVar8 = srv_ProcessClientCommands();
                    // result: Stores the result of function calls.
    if (iVar8 == -1) {
      path_ptr = s_Datatransfer_failed__>_terminati_1002986c;
      iVar8 = 0x15f;
      goto LAB_10009d01;
    }
    iVar8 = srv_SendQueuedCommands();
    if (iVar8 == -1) {
      path_ptr = s_Datatransfer_failed__>_terminati_1002986c;
      iVar8 = 0x16a;
      goto LAB_10009d01;
    }
    puVar4 = &g_client_slots;
    do {
      if ((*puVar4 & 0x1000) != 0) {
        if ((*puVar4 & 0x400) != 0) {
          path_ptr = s_Terminating__serving_host_reques_10029834;
          iVar8 = 0x176;
          goto LAB_10009d01;
        }
        close_connection(puVar4);
      }
      puVar4 = puVar4 + 0x99099;
    } while ((int)puVar4 < 0x114ffe20);
    Sleep(0x1e);
  } while (!bVar1);
  puVar4 = &g_client_slots;
  do {
    if ((*puVar4 & 1) != 0) {
      *puVar4 = *puVar4 & 0xfffffdff | 0x4004;
    }
    puVar4 = puVar4 + 0x99099;
  } while ((int)puVar4 < 0x114ffe20);
  iVar8 = 0;
  puVar4 = &g_client_slots;
  do {
    if ((*puVar4 & 0x400) != 0) {
      (&g_client_slots)[iVar8 * 0x99099] = (&g_client_slots)[iVar8 * 0x99099] | 8;
      goto LAB_10009657;
    }
    puVar4 = puVar4 + 0x99099;
    iVar8 = iVar8 + 1;
  } while ((int)puVar4 < 0x114ffe20);
  sockets_cleanup();
LAB_10009657:
  Sleep(2000);
  iVar8 = 0;
  puVar4 = &g_client_slots;
  do {
    if (*puVar4 != 0) {
      auStack_1e4[0] = 4;
      uStack_1e1 = 0xff;
      uStack_1e0 = 0xffffffff;
      uStack_1d8 = 0;
      uStack_1d4 = CONCAT31(uStack_1d4._1_3_,(-((*puVar4 & 8) != 0) & 7U) + 2);
      iVar6 = client_queue_append_command(puVar4,auStack_1e4);
      if (iVar6 == -1) goto LAB_10009d0e;
      uStack_1d0._0_1_ = (undefined1)((uint)iVar8 >> 0x18);
      auStack_1e4[0] = 0x20;
      uStack_1e1 = 0xff;
      uStack_1e0 = 0xffffffff;
      uStack_1d8 = 0;
      uStack_1d4 = CONCAT31((int3)iVar8,7);
      iVar8 = iVar8 + 1;
      iVar6 = client_queue_append_command(puVar4,auStack_1e4);
      if (iVar6 == -1) goto LAB_10009d0e;
    }
    puVar4 = puVar4 + 0x99099;
  } while ((int)puVar4 < 0x114ffe20);
  logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x1ca,s_Receiving_Data_10029824,1);
  do {
    if (g_shutdown_flag != 0) break;
    bVar1 = true;
    pbVar7 = (byte *)&g_client_slots;
    do {
      if ((*pbVar7 & 8) != 0) {
        bVar1 = false;
        break;
      }
                    // client_slot_ptr_byte: Pointer to a client slot (byte).
      pbVar7 = pbVar7 + 0x264264;
    } while ((int)pbVar7 < 0x114ffe20);
    iVar8 = srv_ProcessClientCommands();
    if ((iVar8 == -1) || (iVar8 = srv_SendQueuedCommands(), iVar8 == -1)) {
      path_ptr = s_Datatransfer_failed__>_terminati_1002986c;
      iVar8 = 0x1df;
      goto LAB_10009d01;
    }
    Sleep(0x1e);
  } while (!bVar1);
  srv_LoadGameState(unaff_EDI);
  logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x1f9,s_Initializing_Client_s__1002980c,1);
  if ((DAT_101de464 & 4) == 0) {
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x1ff,s_Sending_data____100297fc,1);
    do {
      bVar1 = true;
      client = &g_client_slots;
      puVar4 = &DAT_101deac8;
      do {
        if ((*client & 4) != 0) {
          uStack_1e0 = *puVar4;
          if (uStack_1e0 == 0xffffffff) {
            auStack_1e4[0] = 8;
            uStack_1e1 = 0xff;
            uStack_1d8 = 0;
            uStack_1d4 = DAT_101deac0;
            iVar8 = client_queue_append_command(client,auStack_1e4);
                    // client_data_ptr: Pointer to client data.
            if (iVar8 == -1) goto LAB_10009d0e;
            *puVar4 = 0;
          }
          else {
            auStack_1e4[0] = 9;
            puVar10 = (uint *)(uStack_1e0 + (int)DAT_101deae8);
            uStack_1e1 = 0xff;
            uStack_1e0 = 0xffffffff;
            uStack_1d8 = 0;
            puVar12 = &uStack_1d4;
            for (iVar8 = 0x20; iVar8 != 0; iVar8 = iVar8 + -1) {
              *puVar12 = *puVar10;
              puVar10 = puVar10 + 1;
              puVar12 = puVar12 + 1;
            }
            iVar8 = client_queue_append_command(client,auStack_1e4);
            if (iVar8 == -1) {
              logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x228,
                         s_Error_is_not_critical__100297e4,1);
            }
            else {
              *puVar4 = *puVar4 + 0x80;
            }
            if (DAT_101deac0 <= *puVar4) {
              *client = *client & 0xfffffffb;
            }
          }
          bVar1 = false;
        }
        puVar4 = puVar4 + 1;
        client = client + 0x99099;
      } while ((int)puVar4 < 0x101deae8);
      iVar8 = srv_ProcessClientCommands();
      if ((iVar8 == -1) || (iVar8 = srv_SendQueuedCommands(), iVar8 == -1)) {
        path_ptr = s_Datatransfer_failed__>_terminati_1002986c;
        iVar8 = 0x23a;
        goto LAB_10009d01;
      }
      Sleep(0x1e);
    } while (!bVar1);
  }
  else {
    puVar4 = &g_client_slots;
    do {
      if ((*puVar4 & 4) != 0) {
        *puVar4 = *puVar4 & 0xfffffffb;
      }
      puVar4 = puVar4 + 0x99099;
    } while ((int)puVar4 < 0x114ffe20);
  }
  m_free(DAT_101deae8);
  DAT_101deae8 = (void *)0x0;
  DAT_101deac0 = 0;
  if ((DAT_101de464 & 4) == 0) {
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x262,
               s_Waiting_for_allocation_of_Player_100297bc,1);
    puVar4 = &g_client_slots;
    do {
      if ((*puVar4 & 1) != 0) {
        *puVar4 = *puVar4 | 0x10;
      }
      puVar4 = puVar4 + 0x99099;
    } while ((int)puVar4 < 0x114ffe20);
    do {
      bVar1 = true;
      pbVar7 = (byte *)&g_client_slots;
      do {
        if (0x114ffe1f < (int)pbVar7) break;
        if ((*pbVar7 & 0x10) != 0) {
          bVar1 = false;
        }
        pbVar7 = pbVar7 + 0x264264;
      } while (bVar1);
      iVar8 = srv_ProcessClientCommands();
      if ((iVar8 == -1) || (iVar8 = srv_SendQueuedCommands(), iVar8 == -1)) {
        path_ptr = s_Datatransfer_failed__>_terminati_1002986c;
        iVar8 = 0x278;
        goto LAB_10009d01;
      }
      Sleep(0x1e);
    } while (!bVar1);
  }
  pbVar7 = (byte *)&g_client_slots;
  do {
    if ((*pbVar7 & 1) != 0) {
      auStack_148[0] = 4;
      uStack_145 = 0xff;
      uStack_144 = 0xffffffff;
      uStack_13c = 0;
      uStack_138 = 4;
      iVar8 = client_queue_append_command(pbVar7,auStack_148);
      if (iVar8 == -1) goto LAB_10009d0e;
    }
    pbVar7 = pbVar7 + 0x264264;
  } while ((int)pbVar7 < 0x114ffe20);
  logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x2a8,s_Let_s_go__100297b0,1);
joined_r0x10009a3e:
  if (g_shutdown_flag != 0) {
    s__game_ini_1002993c[0] = (char)s__game_ini_1002993c._0_4_;
    s__game_ini_1002993c[1] = SUB41(s__game_ini_1002993c._0_4_,1);
    s__game_ini_1002993c[2] = SUB41(s__game_ini_1002993c._0_4_,2);
    s__game_ini_1002993c[3] = SUB41(s__game_ini_1002993c._0_4_,3);
    s__game_ini_1002993c[4] = (char)s__game_ini_1002993c._4_4_;
    s__game_ini_1002993c[5] = SUB41(s__game_ini_1002993c._4_4_,1);
    s__game_ini_1002993c[6] = SUB41(s__game_ini_1002993c._4_4_,2);
    s__game_ini_1002993c[7] = SUB41(s__game_ini_1002993c._4_4_,3);
    s__game_ini_1002993c[8] = (char)s__game_ini_1002993c._8_2_;
    s__game_ini_1002993c[9] = SUB21(s__game_ini_1002993c._8_2_,1);
    g_shutdown_flag = 0;
    return 0;
  }
  Sleep(0x1e);
  last_broadcast_time = GetTickCount();
  puVar4 = &g_client_slots;
  do {
    if ((*puVar4 != 0) && ((*puVar4 & 0x40) != 0)) {
      puVar4 = &g_client_slots;
      goto LAB_10009a8c;
    }
    puVar4 = puVar4 + 0x99099;
  } while ((int)puVar4 < 0x114ffe20);
  goto LAB_10009aa7;
  while (puVar4 = puVar4 + 0x99099, (int)puVar4 < 0x114ffe20) {
LAB_10009a8c:
    if ((*puVar4 != 0) && ((*puVar4 & 0x40) == 0)) {
      bVar1 = true;
      goto LAB_10009afa;
    }
  }
LAB_10009aa7:
  bVar1 = false;
  puVar4 = &g_client_slots;
  do {
    if ((*puVar4 != 0) && ((*puVar4 & 0x40) != 0)) {
      logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x2ce,s_Usefull_Sync_100297a0,1);
      *puVar4 = *puVar4 & 0xffffffbf;
      iVar8 = client_queue_append_command(puVar4,puVar4 + 0x99055);
      if (iVar8 == -1) goto LAB_10009d0e;
    }
    puVar4 = puVar4 + 0x99099;
  } while ((int)puVar4 < 0x114ffe20);
LAB_10009afa:
  if (g_serverRunning == 0) {
    if (bVar1) goto LAB_10009cb6;
    g_serverRunning = 1;
    bVar1 = true;
    puVar4 = &g_client_slots;
    do {
      if ((*puVar4 != 0) && ((*puVar4 & 0x20) == 0)) {
        g_serverRunning = 0;
        bVar1 = false;
      }
      puVar4 = puVar4 + 0x99099;
    } while ((int)puVar4 < 0x114ffe20);
    if (!bVar1) goto LAB_10009cb6;
    puVar4 = &g_client_slots;
    do {
      if (*puVar4 != 0) {
        *puVar4 = *puVar4 & 0xffffffdf;
      }
      puVar4 = puVar4 + 0x99099;
      DAT_101deaf0 = last_broadcast_time;
    } while ((int)puVar4 < 0x114ffe20);
  }
  else if ((bVar1) || (last_broadcast_time < DAT_101deaf0)) goto LAB_10009cb6;
  sim_UpdateCitizenAge(&DAT_10035880,0,1,0);
  piVar3 = &g_client_slots;
  do {
    if (*piVar3 != 0) {
      uStack_1d0 = _DAT_10035884;
      uStack_1d4 = DAT_10035880;
      auStack_1e4[0] = 0x1e;
      uStack_1e1 = 0xff;
      uStack_1e0 = 0xffffffff;
      uStack_1d8 = 0;
      uStack_1cc = DAT_10035888;
      uStack_1c8 = DAT_1003588c;
      iVar8 = client_queue_append_command(piVar3,auStack_1e4);
      if (iVar8 == -1) goto LAB_10009d0e;
    }
    piVar3 = piVar3 + 0x99099;
  } while ((int)piVar3 < 0x114ffe20);
  if (0x16 < DAT_10035884) {
    bVar1 = true;
    piVar3 = &g_client_slots;
    do {
      if (*piVar3 != 0) {
        auStack_148[0] = 0x20;
        uStack_145 = 0xff;
        uStack_144 = 0xffffffff;
        uStack_13c = 0;
        uStack_138 = 2;
        bVar2 = bVar1;
        if (bVar1) {
          bVar2 = false;
        }
        uStack_137 = (uint)bVar1;
        iVar8 = client_queue_append_command(piVar3,auStack_148);
        if (iVar8 == -1) goto LAB_10009d0e;
        g_serverRunning = 0;
        bVar1 = bVar2;
      }
      piVar3 = piVar3 + 0x99099;
    } while ((int)piVar3 < 0x114ffe20);
    DAT_10035880 = DAT_10035880 + 1;
    sim_SetCitizenData(&DAT_10035880,'\x06',0,0);
  }
  DAT_101deaf0 = DAT_101deaf0 + DAT_1002c3f0;
LAB_10009cb6:
  iVar8 = srv_ProcessClientCommands();
  if ((iVar8 == -1) || (iVar8 = srv_SendQueuedCommands(), iVar8 == -1)) {
    path_ptr = s_Datatransfer_failed__>_terminati_1002986c;
    iVar8 = 0x348;
LAB_10009d01:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,iVar8,path_ptr,1);
LAB_10009d0e:
    sockets_cleanup();
    return 0;
  }
  iVar8 = srv_DispatchGameCommand();
  if (iVar8 == -1) goto LAB_10009d0e;
  goto joined_r0x10009a3e;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void server_main(void)

void srv_InitServer(void)

{
  char cVar1;
  HANDLE thread_handle;
  uint string_length;
  uint loop_counter;
  int result;
  char *char_ptr;
  char *path_walker;
  char *pcVar2;
  char acStack_504 [260];
  CHAR aCStack_400 [1024];
  
                    // Initializes the server. Sets up error handling, memory allocation, loads game
                    // data, and initializes networking.
  thread_handle = GetCurrentThread();
  SetThreadPriority(thread_handle,2);
  errorHandlerInit(sockets_cleanup,(void *)0x0,(HWND)0x0,3);
  m_alloc_init(0x7fa6);
  string_length = 0xffffffff;
                    // char_ptr: A character pointer used for various string operations.
  char_ptr = s__project_DieGilde_game__10029594;
  do {
    pcVar2 = char_ptr;
    if (string_length == 0) break;
    string_length = string_length - 1;
    pcVar2 = char_ptr + 1;
    cVar1 = *char_ptr;
    char_ptr = pcVar2;
  } while (cVar1 != '\0');
  string_length = ~string_length;
                    // temp_char_ptr: A temporary character pointer.
  char_ptr = pcVar2 + -string_length;
  pcVar2 = acStack_504;
  for (loop_counter = string_length >> 2; loop_counter != 0; loop_counter = loop_counter - 1) {
    *(undefined4 *)pcVar2 = *(undefined4 *)char_ptr;
    char_ptr = char_ptr + 4;
    pcVar2 = pcVar2 + 4;
  }
  for (string_length = string_length & 3; string_length != 0; string_length = string_length - 1) {
    *pcVar2 = *char_ptr;
    char_ptr = char_ptr + 1;
    pcVar2 = pcVar2 + 1;
  }
  string_length = 0xffffffff;
  char_ptr = s_data__10029998;
  do {
    pcVar2 = char_ptr;
    if (string_length == 0) break;
    string_length = string_length - 1;
    pcVar2 = char_ptr + 1;
    cVar1 = *char_ptr;
    char_ptr = pcVar2;
  } while (cVar1 != '\0');
  string_length = ~string_length;
  result = -1;
  char_ptr = acStack_504;
  do {
    path_walker = char_ptr;
    if (result == 0) break;
    result = result + -1;
    path_walker = char_ptr + 1;
    cVar1 = *char_ptr;
    char_ptr = path_walker;
  } while (cVar1 != '\0');
  char_ptr = pcVar2 + -string_length;
  pcVar2 = path_walker + -1;
  for (loop_counter = string_length >> 2; loop_counter != 0; loop_counter = loop_counter - 1) {
    *(undefined4 *)pcVar2 = *(undefined4 *)char_ptr;
    char_ptr = char_ptr + 4;
    pcVar2 = pcVar2 + 4;
  }
  for (string_length = string_length & 3; string_length != 0; string_length = string_length - 1) {
    *pcVar2 = *char_ptr;
    char_ptr = char_ptr + 1;
    pcVar2 = pcVar2 + 1;
  }
  result = load_game_data(acStack_504);
                    // path_walker: Used to walk through the game data path string.
  if (result < 0) {
    printf_wrapper(aCStack_400,s_Could_not_open_gamefiles_path__s_10029974,acStack_504);
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x3cd,aCStack_400,1);
    return;
  }
  remove_all_players();
  init_offices();
  g_socketStatus = srv_InitSockets();
  if (g_socketStatus == -1) {
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x3db,
               s____ERROR__Initialization_of_Sock_10029948,1);
    return;
  }
  g_serverRunning = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int sockets_init(void)

int srv_InitSockets(void)

{
  undefined4 *client_slot_initializer;
  int server_socket;
  int result;
  undefined1 wsa_data [396];
  uint16_t server_port;
  
                    // Initializes the server sockets for network communication. This involves
                    // creating a socket, setting various options, binding it to an address, and
                    // starting to listen for incoming connections.
  client_slot_initializer = &DAT_101deb14;
  do {
    client_slot_initializer[-5] = 0;
    *client_slot_initializer = 0xffffffff;
    client_slot_initializer = client_slot_initializer + 0x99099;
  } while ((int)client_slot_initializer < 0x114ffe34);
                    // client_slot_initializer: Initializes the client slots.
                    // game_data_path: Stores the path to the game data.
  WSACancelBlockingCall(0x101,wsa_data);
  server_socket = socket(2,1,6);
                    // error_message_buffer: A buffer to store error messages.
  if (server_socket != -1) {
                    // wsa_data: Stores Winsock data.
                    // server_socket: The main server socket.
    result = setsockopt(server_socket,0xffff,4,&stack0xfffffe54,4);
    if (result != -1) {
                    // result: Stores the result of socket operations.
      result = setsockopt(server_socket,0xffff,-0x81,&stack0xfffffe54,4);
      if (result != -1) {
        result = setsockopt(server_socket,0xffff,0x1002,&stack0xfffffe54,4);
        if (result == -1) {
          logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x424,
                     s_Can_t_set_SO_RCVBUF_on_Socket_100293e4,1);
        }
        else {
          result = setsockopt(server_socket,0xffff,0x1001,&stack0xfffffe54,4);
          if (result == -1) {
            logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x42b,
                       s_Can_t_set_SO_SNDBUF_on_Socket_100293c4,1);
                    // server_port: The port the server listens on.
          }
          else {
            result = ioctlsocket(server_socket,0x8004667e,&stack0xfffffe54);
            if (result != -1) {
              htons(server_port);
              result = bind(server_socket,&stack0xfffffe58,0x10);
              if (result != -1) {
                result = listen(server_socket,5);
                if (result != -1) {
                  return server_socket;
                }
              }
            }
          }
        }
      }
    }
    shutdown(server_socket,2);
    closesocket(server_socket);
  }
  WSAIsBlocking();
  return -1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void sockets_cleanup(void)

void sockets_cleanup(void)

{
  int *piVar1;
  
                    // 
                    // Cleans up all active sockets and associated resources.
                    // This includes shutting down and closing individual client sockets, the main
                    // server socket,
                    // and performing general memory and error handler cleanup.
                    // 
  piVar1 = &DAT_101deb14;
  do {
    if (piVar1[-5] != 0) {
      shutdown(*piVar1,2);
      closesocket(*piVar1);
    }
    piVar1 = piVar1 + 0x99099;
  } while ((int)piVar1 < 0x114ffe34);
  shutdown(g_socketStatus,2);
  closesocket(g_socketStatus);
  WSAIsBlocking();
  remove_all_players();
  handleLoadGameData2();
  handleLoadGameData3();
  handleLoadGameData5();
  m_alloc_cleanup();
  errorHandlerCleanup();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: uint32_t accept_connection(void)

uint32_t srv_AcceptClient(void)

{
  int *client_slot_ptr;
  uint client_socket;
  DWORD current_tick_count;
  int client_slot_index;
  int loop_counter;
  uint *puVar1;
  uint *new_client_slot;
  undefined1 uStack_118;
  undefined1 uStack_117;
  undefined1 uStack_116;
  undefined1 uStack_115;
  undefined1 local_114;
  undefined1 uStack_113;
  undefined1 uStack_112;
  undefined1 uStack_111;
  undefined1 local_110 [4];
  CHAR aCStack_10c [268];
  
                    // 
                    // Accepts a new client connection on the listening socket.
                    // It finds an available slot for the new connection, sets up socket options,
                    // and initializes connection-specific data.
                    // 
                    // Return values:
                    //   The new socket descriptor if successful, or -1 on failure.
                    // 
  if (g_socketStatus == -1) {
    return 0xffffffff;
  }
  loop_counter = 0;
  client_slot_ptr = &g_client_slots;
  do {
    if (*client_slot_ptr == 0) {
      puVar1 = &g_client_slots + loop_counter * 0x99099;
      if (puVar1 != (uint *)0x0) goto LAB_1000a101;
      break;
    }
    client_slot_ptr = client_slot_ptr + 0x99099;
    loop_counter = loop_counter + 1;
  } while ((int)client_slot_ptr < 0x114ffe20);
  logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x495,
             s_No_more_Slots_for_new_Connection_100299c8,1);
  if (_DAT_114ffe20 == 0) {
    puVar1 = (uint *)&DAT_114ffe20;
LAB_1000a101:
    local_114 = 0x10;
    uStack_113 = 0;
    uStack_112 = 0;
    uStack_111 = 0;
    client_socket = accept(g_socketStatus,local_110,&local_114);
    if (client_socket != 0xffffffff) {
      setsockopt(client_socket,0xffff,0x1002,&stack0xfffffedc,4);
      setsockopt(client_socket,0xffff,0x1001,&stack0xfffffedc,4);
      DAT_1003467c = DAT_1003467c + 1;
      puVar1[1] = DAT_1003467c;
      *puVar1 = 0x2103;
      new_client_slot = puVar1 + 0x99083;
      for (client_slot_index = 0x15; client_slot_index != 0;
          client_slot_index = client_slot_index + -1) {
        *new_client_slot = 0;
        new_client_slot = new_client_slot + 1;
      }
      *(undefined2 *)new_client_slot = 0;
      *(undefined1 *)((int)new_client_slot + 2) = 0;
      puVar1[0x99083] = puVar1[1];
      if (loop_counter == 0) {
        *puVar1 = *puVar1 | 0x400;
      }
      puVar1[5] = client_socket;
      *(undefined2 *)((int)puVar1 + 0x14a) = 0;
      *(undefined2 *)(puVar1 + 0x53) = 0;
      *(undefined2 *)((int)puVar1 + 0x14e) = 0x19;
      current_tick_count = GetTickCount();
      loop_counter = 0;
      puVar1[0x54] = current_tick_count + 300000;
      do {
        *(undefined1 *)((int)puVar1 + loop_counter * 0x99 + 0x154) = 0;
        *(undefined1 *)((int)puVar1 + loop_counter * 0x99 + 0x132154) = 0;
        if (loop_counter == 0) {
          *(undefined4 *)((int)puVar1 + 0x1e5) = 0;
          *(undefined4 *)((int)puVar1 + 0x1321e5) = 0;
LAB_1000a225:
          *(int *)((int)puVar1 + loop_counter * 0x99 + 0x1e9) =
               (int)puVar1 + loop_counter * 0x99 + 0x1ed;
          *(int *)((int)puVar1 + loop_counter * 0x99 + 0x1321e9) =
               (int)puVar1 + loop_counter * 0x99 + 0x1321ed;
        }
        else {
          *(int *)((int)puVar1 + loop_counter * 0x99 + 0x1e5) =
               (int)puVar1 + loop_counter * 0x99 + 0xbb;
          *(int *)((int)puVar1 + loop_counter * 0x99 + 0x1321e5) =
               (int)puVar1 + loop_counter * 0x99 + 0x1320bb;
          if (loop_counter < 0x1fff) goto LAB_1000a225;
          *(undefined4 *)((int)puVar1 + loop_counter * 0x99 + 0x1e9) = 0;
          *(undefined4 *)((int)puVar1 + loop_counter * 0x99 + 0x1321e9) = 0;
        }
        loop_counter = loop_counter + 1;
        if (0x1fff < loop_counter) {
          puVar1[0x9907e] = (uint)(puVar1 + 0x55);
          puVar1[0x9907f] = (uint)(puVar1 + 0x4c855);
          puVar1[0x9907c] = 0;
          puVar1[0x9907d] = 0;
          printf_wrapper(aCStack_10c,s_New_Connection_from__li__li__li__100299a0,
                         CONCAT12(uStack_116,CONCAT11(uStack_117,uStack_118)) & 0xff,
                         CONCAT12(uStack_115,CONCAT11(uStack_116,uStack_117)) & 0xff,
                         CONCAT12(local_114,CONCAT11(uStack_115,uStack_116)) & 0xff,
                         CONCAT12(uStack_113,CONCAT11(local_114,uStack_115)) & 0xff);
          logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x4e1,aCStack_10c,1);
          return client_socket;
        }
      } while( true );
    }
  }
  return 0xffffffff;
}



// Setting prototype: int close_connection(void *client_data)

int close_connection(void *client_data)

{
  int loop_counter;
  undefined4 *puVar1;
  
                    // 
                    // Closes a client connection and cleans up associated resources.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    // 
                    // Return values:
                    //   Always returns 0.
                    // 
  shutdown(*(undefined4 *)((int)client_data + 0x14),2);
  closesocket(*(int *)((int)client_data + 0x14));
  *(undefined4 *)client_data = 0;
  *(undefined4 *)((int)client_data + 0x14) = 0xffffffff;
  *(undefined4 *)((int)client_data + 4) = 0;
  puVar1 = (undefined4 *)((int)client_data + 0x26420c);
  for (loop_counter = 0x15; loop_counter != 0; loop_counter = loop_counter + -1) {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  }
  *(undefined2 *)puVar1 = 0;
  *(undefined1 *)((int)puVar1 + 2) = 0;
  logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x500,s_Connection_dropped__100299ec,1);
  return 0;
}



// Setting prototype: int receive_data(void *client_data)

int srv_RecvFromClient(void *client_data)

{
  void *pvVar1;
  DWORD DVar2;
  int iVar3;
  uint32_t error_code;
  ushort bytes_received_short;
  
                    // 
                    // Receives data from a client connection.
                    // It handles partial reads, timeouts, and Winsock errors.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error, or 0xFFFFFFFF on critical error/timeout.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x80) != 0) {
    return 0;
  }
  bytes_received_short = *(ushort *)((int)client_data + 0x14a);
  pvVar1 = client_data;
  if (bytes_received_short < 3) {
    pvVar1 = (void *)recv(*(undefined4 *)((int)client_data + 0x14),
                          bytes_received_short + 0x18 + (int)client_data,
                          3 - (uint)bytes_received_short,0);
    if (pvVar1 == (void *)0x0) {
      DVar2 = GetTickCount();
      if (DVar2 <= *(uint *)((int)client_data + 0x150)) {
        return 0;
      }
      logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x52a,s_Connection_timed_out__10029a04,
                 1);
      close_connection(client_data);
      return -1;
    }
    if (pvVar1 == (void *)0xffffffff) goto LAB_1000a435;
  }
  *(short *)((int)client_data + 0x14a) = *(short *)((int)client_data + 0x14a) + (short)pvVar1;
  bytes_received_short = *(ushort *)((int)client_data + 0x14a);
  if (bytes_received_short < 3) {
    return 0;
  }
  iVar3 = recv(*(undefined4 *)((int)client_data + 0x14),
               bytes_received_short + 0x18 + (int)client_data,
               (uint)*(ushort *)((int)client_data + 0x19) - (uint)bytes_received_short,0);
  if (iVar3 == 0) {
    DVar2 = GetTickCount();
    if (DVar2 <= *(uint *)((int)client_data + 0x150)) {
      return 0;
    }
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x552,s_Connection_timed_out__10029a04,1)
    ;
    close_connection(client_data);
    return -1;
  }
  if (iVar3 != -1) {
    *(short *)((int)client_data + 0x14a) = *(short *)((int)client_data + 0x14a) + (short)iVar3;
    DVar2 = GetTickCount();
    *(DWORD *)((int)client_data + 0x150) = DVar2 + 300000;
    if (*(short *)((int)client_data + 0x14a) != *(short *)((int)client_data + 0x19)) {
      return 0;
    }
                    // WARNING: Load size is inaccurate
    *(undefined2 *)((int)client_data + 0x14a) = 0;
    *(uint *)client_data = *client_data | 0x80;
    return 0;
  }
LAB_1000a435:
  error_code = WSASetBlockingHook();
  if (error_code == 0x2733) {
    return 0;
  }
  handle_winsock_error(error_code);
  close_connection(client_data);
  return -1;
}



// Setting prototype: int send_data(void *client_data)

int srv_SendData(void *client_data)

{
  int bytes_sent;
  DWORD DVar1;
  
                    // 
                    // Sends data to a client connection.
                    // It handles partial sends, timeouts, and Winsock errors.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or 0xFFFFFFFF on critical error/timeout.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x100) == 0) {
    bytes_sent = send(*(undefined4 *)((int)client_data + 0x14),
                      *(ushort *)((int)client_data + 0x14c) + 0xb1 + (int)client_data,
                      (uint)*(ushort *)((int)client_data + 0xb2) -
                      (uint)*(ushort *)((int)client_data + 0x14c),0);
    if (bytes_sent == 0) {
      DVar1 = GetTickCount();
      if (*(uint *)((int)client_data + 0x150) < DVar1) {
        logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x58f,
                   s_Connection_timed_out__10029a04,1);
        close_connection(client_data);
        return -1;
      }
    }
    else if (bytes_sent == -1) {
      bytes_sent = WSASetBlockingHook();
      if (bytes_sent != 0x2733) {
        close_connection(client_data);
        return -1;
      }
    }
    else if (0 < bytes_sent) {
      *(short *)((int)client_data + 0x14c) =
           *(short *)((int)client_data + 0x14c) + (short)bytes_sent;
      DVar1 = GetTickCount();
      *(DWORD *)((int)client_data + 0x150) = DVar1 + 300000;
      if (*(short *)((int)client_data + 0x14c) == *(short *)((int)client_data + 0xb2)) {
                    // WARNING: Load size is inaccurate
        *(undefined2 *)((int)client_data + 0x14c) = 0;
        *(uint *)client_data = *client_data | 0x100;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int process_commands(void)

int srv_ProcessClientCommands(void)

{
  int recv_result;
  int iVar1;
  uint uVar2;
  int iVar3;
  uint *client_data;
  uint *puVar4;
  undefined4 *puVar5;
  uint *puVar6;
  undefined1 local_29c [156];
  CHAR local_200 [256];
  CHAR local_100 [256];
  
                    // 
                    // Processes incoming commands from connected clients.
                    // This function iterates through active connections, receives data, and
                    // dispatches commands based on their type.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  iVar3 = 0;
  client_data = &g_client_slots;
  do {
    if ((*client_data & 1) != 0) {
      do {
        recv_result = srv_RecvFromClient(client_data);
        if (recv_result == -1) {
          return -1;
        }
        uVar2 = *client_data;
        if ((uVar2 & 0x80) == 0) break;
        if ((uVar2 & 2) == 0) {
          if ((uVar2 & 0x200) == 0) {
            if ((uVar2 & 8) == 0) {
              if ((uVar2 & 4) != 0) {
                printf_wrapper(local_100,s_Unexpected_Request_from_connecti_10029a1c,iVar3);
                logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x609,local_100,1);
                *client_data = *client_data & 0xffffff7f;
                local_29c[0] = 2;
                iVar1 = client_queue_append_command(client_data,local_29c);
                if (iVar1 == -1) {
                  return -1;
                }
                goto LAB_1000a7cb;
              }
              *(byte *)((int)client_data + 0x1b) = (byte)iVar3;
              if ((uVar2 & 0x10) != 0) {
                iVar1 = enqueue_client_command(client_data,client_data + 6);
                if (iVar1 != 0) {
                  return -1;
                }
                uVar2 = *client_data & 0xffffff6f;
                goto LAB_1000a7c8;
              }
              iVar1 = enqueue_client_command(client_data,client_data + 6);
              if (iVar1 != 0) {
                return -1;
              }
            }
            else {
              if ((byte)client_data[6] == 8) {
                uVar2 = client_data[10];
                DAT_101deac4 = 0;
                puVar5 = &DAT_101deac8;
                DAT_101deac0 = uVar2;
                for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {
                  *puVar5 = 0xffffffff;
                  puVar5 = puVar5 + 1;
                }
                DAT_101deae8 = mAlloc(uVar2,s_srv_LoadBuf_10029a48);
              }
              else if ((byte)client_data[6] == 9) {
                puVar4 = client_data + 10;
                puVar6 = (uint *)(DAT_101deae8 + DAT_101deac4);
                for (iVar1 = 0x20; iVar1 != 0; iVar1 = iVar1 + -1) {
                  *puVar6 = *puVar4;
                  puVar4 = puVar4 + 1;
                  puVar6 = puVar6 + 1;
                }
                DAT_101deac4 = DAT_101deac4 + 0x80;
              }
              if (DAT_101deac0 <= DAT_101deac4) {
                *client_data = *client_data & 0xfffffff7;
              }
            }
            uVar2 = *client_data & 0xffffff7f;
            goto LAB_1000a7c8;
          }
          logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x5df,s_LOBBY_mode_10029a9c,1);
          if ((byte)client_data[6] == 0x5f) {
            iVar1 = dispatch_lobby_command(client_data,client_data + 6);
            if (iVar1 == -1) {
              return -1;
            }
            printf_wrapper(local_200,s_status_after_lb_ExLobbyServerCom_10029a70,*client_data);
            logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x5e5,local_200,1);
          }
          uVar2 = *client_data;
          *client_data = uVar2 & 0xffffff7f;
          printf_wrapper(local_200,s_leaving_lobby_branch___i_10029a54,uVar2 & 0xffffff7f);
          logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x5e9,local_200,1);
        }
        else {
          if ((byte)client_data[6] == 3) {
            client_data[0xb] = client_data[1];
            client_data[0xc] = 2 - ((*client_data & 0x400) != 0);
            iVar1 = client_queue_append_command(client_data,client_data + 6);
            if (iVar1 == -1) {
              return -1;
            }
          }
          uVar2 = *client_data & 0xffffff7d | 0x200;
LAB_1000a7c8:
          *client_data = uVar2;
        }
LAB_1000a7cb:
      } while ((*client_data & 1) != 0);
      if (recv_result == -1) {
        return -1;
      }
    }
    client_data = client_data + 0x99099;
    iVar3 = iVar3 + 1;
    if (0x114ffe1f < (int)client_data) {
      if ((DAT_114ffe20 & 1) != 0) {
        while (iVar3 = srv_RecvFromClient(&DAT_114ffe20), iVar3 != -1) {
          if ((DAT_114ffe20 & 0x80) != 0) {
            local_29c[0] = 2;
            client_queue_append_command(&DAT_114ffe20,local_29c);
            close_connection(&DAT_114ffe20);
            return 0;
          }
          if ((DAT_114ffe20 & 1) == 0) {
            return 0;
          }
        }
      }
      return 0;
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int send_commands(void)

int srv_SendQueuedCommands(void)

{
  int send_result;
  uint *current_client;
  byte *pbVar1;
  byte *command_data_ptr;
  
                    // 
                    // Sends pending commands to connected clients.
                    // This function iterates through active connections, sends data, and dequeues
                    // commands after successful transmission.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  current_client = &g_client_slots;
  do {
    if ((*current_client & 1) != 0) {
      send_result = srv_SendData(current_client);
      while( true ) {
        if (send_result == -1) {
          return -1;
        }
        if (((byte *)current_client[0x9907d] == (byte *)0x0) || ((*current_client & 0x100) == 0))
        break;
        pbVar1 = (byte *)current_client[0x9907d];
        command_data_ptr = (byte *)((int)current_client + 0xb1);
        for (send_result = 0x26; send_result != 0; send_result = send_result + -1) {
          *(undefined4 *)command_data_ptr = *(undefined4 *)pbVar1;
          pbVar1 = pbVar1 + 4;
          command_data_ptr = command_data_ptr + 4;
        }
        *command_data_ptr = *pbVar1;
        dequeue_command(current_client,(void *)current_client[0x9907d]);
        *current_client = *current_client & 0xfffffeff;
        send_result = srv_SendData(current_client);
      }
      if (send_result == -1) {
        return -1;
      }
    }
    current_client = current_client + 0x99099;
    if (0x114ffe1f < (int)current_client) {
      return 0;
    }
  } while( true );
}



// Setting prototype: int queue_send_command(void *client_data, void *command)

int enqueue_client_command(void *client_data,void *command)

{
  int iVar1;
  undefined4 *puVar2;
  int last_command_in_queue;
  undefined4 *new_command;
  
                    // 
                    // Queues a command to be sent to a client.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command: Pointer to the command data to queue.
                    // 
                    // Return values:
                    //   0 if successful, or -1 if the command buffer is full.
                    // 
  new_command = *(undefined4 **)((int)client_data + 0x2641f8);
  if (new_command == (undefined4 *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x671,s_Commandbuffer_full__10029aa8,1);
    return -1;
  }
  *(undefined4 *)((int)client_data + 0x2641f8) = *(undefined4 *)((int)new_command + 0x95);
  puVar2 = new_command;
                    // WARNING: Load size is inaccurate
  for (iVar1 = 0x26; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = *command;
    command = (undefined4 *)((int)command + 4);
    puVar2 = puVar2 + 1;
  }
                    // WARNING: Load size is inaccurate
  *(undefined1 *)puVar2 = *command;
  iVar1 = get_command_size(new_command);
  *(short *)((int)new_command + 1) = (short)iVar1;
  iVar1 = *(int *)((int)client_data + 0x2641f0);
  if (iVar1 == 0) {
    *(undefined4 *)((int)new_command + 0x91) = 0;
    *(undefined4 *)((int)new_command + 0x95) = 0;
    *(undefined4 **)((int)client_data + 0x2641f0) = new_command;
    return 0;
  }
  for (last_command_in_queue = *(int *)(iVar1 + 0x95); last_command_in_queue != 0;
      last_command_in_queue = *(int *)(last_command_in_queue + 0x95)) {
    iVar1 = last_command_in_queue;
  }
  *(int *)((int)new_command + 0x91) = iVar1;
  *(undefined4 *)((int)new_command + 0x95) = 0;
  *(undefined4 **)(iVar1 + 0x95) = new_command;
  return 0;
}



// Setting prototype: int client_queue_append_command(client_t *client, command_t *command_data)

int client_queue_append_command(void *client,void *command_data)

{
  int iVar1;
  undefined4 *puVar2;
  int last_command;
  undefined4 *new_command_buffer;
  
                    // Queues a command to be sent to a client. This function adds a command to a
                    // client's outgoing queue, but it does not send it. It is the responsibility of
                    // the caller to eventually send the command.
  new_command_buffer = *(undefined4 **)((int)client + 0x2641fc);
  if (new_command_buffer == (undefined4 *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x6b0,s_Commandbuffer_full__10029aa8,1);
    return -1;
  }
  *(undefined4 *)((int)client + 0x2641fc) = *(undefined4 *)((int)new_command_buffer + 0x95);
  puVar2 = new_command_buffer;
                    // WARNING: Load size is inaccurate
  for (iVar1 = 0x26; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = *command_data;
    command_data = (undefined4 *)((int)command_data + 4);
    puVar2 = puVar2 + 1;
  }
                    // WARNING: Load size is inaccurate
  *(undefined1 *)puVar2 = *command_data;
  iVar1 = get_command_size(new_command_buffer);
  *(short *)((int)new_command_buffer + 1) = (short)iVar1;
  iVar1 = *(int *)((int)client + 0x2641f4);
  if (iVar1 == 0) {
    *(undefined4 *)((int)new_command_buffer + 0x91) = 0;
    *(undefined4 *)((int)new_command_buffer + 0x95) = 0;
    *(undefined4 **)((int)client + 0x2641f4) = new_command_buffer;
    return 0;
  }
  for (last_command = *(int *)(iVar1 + 0x95); last_command != 0;
      last_command = *(int *)(last_command + 0x95)) {
    iVar1 = last_command;
  }
  *(int *)((int)new_command_buffer + 0x91) = iVar1;
  *(undefined4 *)((int)new_command_buffer + 0x95) = 0;
  *(undefined4 **)(iVar1 + 0x95) = new_command_buffer;
  return 0;
}



// Setting prototype: void dequeue_command(void *client_data, void *command)

void dequeue_command(void *client_data,void *command)

{
                    // Dequeues a command from a client's command queue.
  if (*(int *)((int)command + 0x91) == 0) {
    *(undefined4 *)((int)client_data + 0x2641f4) = *(undefined4 *)((int)command + 0x95);
  }
  else {
    *(undefined4 *)(*(int *)((int)command + 0x91) + 0x95) = *(undefined4 *)((int)command + 0x95);
  }
  if (*(int *)((int)command + 0x95) != 0) {
    *(undefined4 *)(*(int *)((int)command + 0x95) + 0x91) = *(undefined4 *)((int)command + 0x91);
  }
  *(undefined4 *)((int)command + 0x91) = 0;
  *(undefined4 *)((int)command + 0x95) = *(undefined4 *)((int)client_data + 0x2641fc);
  *(void **)((int)client_data + 0x2641fc) = command;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int process_command_queue(void)

int srv_DispatchGameCommand(void)

{
  byte *pbVar1;
  int iVar2;
  byte *command_data;
  uint uVar3;
  byte *current_command;
  byte *pbVar4;
  byte *local_8;
  undefined4 *local_4;
  byte *command_ptr_1;
  
                    // 
                    // Processes commands from the global command queue.
                    // This function dispatches commands to appropriate handlers based on their
                    // type.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  local_4 = &DAT_10442cf0;
  do {
    command_data = (byte *)0x0;
    local_8 = (byte *)*local_4;
joined_r0x1000aad7:
    current_command = local_8;
    if (current_command != (byte *)0x0) {
      local_8 = *(byte **)(current_command + 0x95);
      pbVar4 = current_command + 0x95;
      if (command_data == (byte *)0x0) {
        command_ptr_1 = current_command;
        pbVar1 = current_command;
        if (*current_command == 5) goto joined_r0x1000ab32;
        goto LAB_1000ab38;
      }
      command_ptr_1 = command_data;
      pbVar1 = command_data;
      if (*current_command == 6) {
        pbVar1 = (byte *)process_command(command_data);
        local_8 = *(byte **)(command_data + 0x95);
        pbVar4 = command_data + 0x95;
        command_ptr_1 = (byte *)0x0;
        current_command = command_data;
      }
joined_r0x1000ab32:
      command_data = command_ptr_1;
      if (pbVar1 != (byte *)0x0) {
LAB_1000ab38:
        if (current_command == (byte *)*local_4) {
          *local_4 = local_8;
        }
        else {
          *(undefined4 *)(*(int *)(current_command + 0x91) + 0x95) = *(undefined4 *)pbVar4;
          *(undefined4 *)(*(int *)pbVar4 + 0x91) = *(undefined4 *)(current_command + 0x91);
        }
        current_command[0x91] = 0;
        current_command[0x92] = 0;
        current_command[0x93] = 0;
        current_command[0x94] = 0;
        *(undefined4 *)pbVar4 = local_4[2];
        local_4[2] = current_command;
        if (*current_command < 0x6a) {
          if (((*current_command == 0x20) && (current_command[0x10] == 0xe)) &&
             ((*(byte *)(&g_client_slots + (uint)current_command[3] * 0x99099) & 0x40) != 0)) {
            logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x72e,s_Multisync____10029adc,1);
          }
          iVar2 = (*(code *)(&PTR_handle_invalid_command_1002c3f8)[*current_command])
                            (current_command,0);
          if (iVar2 == 0) {
            if ((*current_command == 0x20) && (current_command[0x10] == 0xe)) {
              pbVar4 = &DAT_10442c54 + (uint)current_command[3] * 0x264264;
              for (iVar2 = 0x26; iVar2 != 0; iVar2 = iVar2 + -1) {
                *(undefined4 *)pbVar4 = *(undefined4 *)current_command;
                current_command = current_command + 4;
                pbVar4 = pbVar4 + 4;
              }
              *pbVar4 = *current_command;
              goto joined_r0x1000aad7;
            }
            if (((*(byte *)(&g_client_slots + (uint)current_command[3] * 0x99099) & 1) == 0) ||
               (iVar2 = client_queue_append_command
                                  (&g_client_slots + (uint)current_command[3] * 0x99099,
                                   current_command), iVar2 != -1)) {
              current_command[4] = 0xff;
              current_command[5] = 0xff;
              current_command[6] = 0xff;
              current_command[7] = 0xff;
              uVar3 = 0;
              pbVar4 = (byte *)&g_client_slots;
              do {
                if (((uVar3 != current_command[3]) && ((*pbVar4 & 1) != 0)) &&
                   (iVar2 = client_queue_append_command(pbVar4,current_command), iVar2 == -1)) {
                  return -1;
                }
                pbVar4 = pbVar4 + 0x264264;
                uVar3 = uVar3 + 1;
              } while ((int)pbVar4 < 0x114ffe20);
              goto joined_r0x1000aad7;
            }
          }
          else {
            if ((*(byte *)(&g_client_slots + (uint)current_command[3] * 0x99099) & 1) == 0)
            goto joined_r0x1000aad7;
            *current_command = 2;
            iVar2 = client_queue_append_command
                              (&g_client_slots + (uint)current_command[3] * 0x99099,current_command)
            ;
            if (iVar2 != -1) goto joined_r0x1000aad7;
          }
          return -1;
        }
        logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x756,
                   s_Command_Type_out_of_Range__10029ac0,1);
      }
      goto joined_r0x1000aad7;
    }
    local_4 = local_4 + 0x99099;
    if (0x1176400f < (int)local_4) {
      return 0;
    }
  } while( true );
}



// Setting prototype: void handle_winsock_error(uint32_t error_code)

void handle_winsock_error(uint32_t error_code)

{
  CHAR error_message_buffer [256];
  
                    // Handles Winsock errors by logging a descriptive message based on the error
                    // code.
  switch(error_code) {
  case 0x2714:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x771,
               s_WSAEINTR__The__blocking__call_wa_100292a4,1);
    return;
  default:
    printf_wrapper(error_message_buffer,s_Unknown_winsock_error__u____10028bdc,error_code);
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x789,error_message_buffer,1);
    return;
  case 0x271e:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x76d,
               s_WSAEFAULT__The_buf_parameter_is_n_1002931c,1);
    return;
  case 0x2726:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x781,
               s_WSAEINVAL__The_socket_has_not_be_10028e3c,1);
    return;
  case 0x2733:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x77d,
               s_WSAEWOULDBLOCK__The_socket_is_ma_10028f6c,1);
    return;
  case 0x2734:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x773,
               s_WSAEINPROGRESS__A_blocking_Windo_1002921c,1);
    return;
  case 0x2736:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x777,
               s_WSAENOTSOCK__The_descriptor_is_n_10029164,1);
    return;
  case 0x2738:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x77f,
               s_WSAEMSGSIZE__The_message_was_too_10028f10,1);
    return;
  case 0x273d:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x779,
               s_WSAEOPNOTSUPP__MSG_OOB_was_speci_10029068,1);
    return;
  case 0x2742:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x76b,
               s_WSAENETDOWN__The_network_subsyst_10029380,1);
    return;
  case 0x2744:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x775,
               s_WSAENETRESET__The_connection_has_10029194,1);
    return;
  case 0x2745:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x783,
               s_WSAECONNABORTED__The_virtual_cir_10028da0,1);
    return;
  case 0x2746:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x787,
               s_WSAECONNRESET__The_virtual_circu_10028bf8,1);
    return;
  case 0x2749:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x76f,
               s_WSAENOTCONN__The_socket_is_not_c_100292f0,1);
    return;
  case 0x274a:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x77b,
               s_WSAESHUTDOWN__The_socket_has_bee_10028fc8,1);
    return;
  case 0x274c:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x785,
               s_WSAETIMEDOUT__The_connection_has_10028d24,1);
    return;
  case 0x276d:
    logMessage(s_D__Develop_DieGildeAddOnServer_s_100298b0,0x769,s_WSANOTINITIALISED_100293b0,1);
    return;
  }
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void aemter_init(void)

void init_offices(void)

{
  undefined4 *aemter_data_ptr;
  char cVar1;
  int iVar2;
  
                    // 
                    // Initializes the 'Aemter' (offices/ranks) data structures.
                    // This function sets up initial values and states for various game-related
                    // entities.
                    // 
  aemter_data_ptr = (undefined4 *)&g_aemter_data;
  for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
    *(undefined1 *)aemter_data_ptr = 0;
    aemter_data_ptr = (undefined4 *)((int)aemter_data_ptr + 1);
  }
  for (iVar2 = 0xfc; iVar2 != 0; iVar2 = iVar2 + -1) {
    *aemter_data_ptr = 0;
    aemter_data_ptr = aemter_data_ptr + 1;
  }
  for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
    *(undefined1 *)aemter_data_ptr = 0;
    aemter_data_ptr = (undefined4 *)((int)aemter_data_ptr + 1);
  }
  cVar1 = '\0';
  aemter_data_ptr = &DAT_101de5a4;
  do {
    *(char *)(aemter_data_ptr + -1) = cVar1;
    *aemter_data_ptr = 0xffffffff;
    aemter_data_ptr[4] = 0xffffffff;
    aemter_data_ptr = aemter_data_ptr + 6;
    cVar1 = cVar1 + '\x01';
  } while ((int)aemter_data_ptr < 0x101de994);
  DAT_101de5d8 = 2;
  DAT_101de5a8 = 1;
  DAT_101de5c0 = 1;
  DAT_101de5f0 = 3;
  DAT_101de608 = 4;
  DAT_101de620 = 4;
  DAT_101de638 = 5;
  DAT_101de650 = 6;
  DAT_101de668 = 7;
  DAT_101de680 = 7;
  DAT_101de698 = 8;
  DAT_101de6b0 = 9;
  DAT_101de6c8 = 10;
  DAT_101de6e0 = 0xb;
  DAT_101de6f8 = 0xc;
  DAT_101de710 = 0xd;
  DAT_101de728 = 0xe;
  DAT_101de740 = 0xf;
  DAT_101de758 = 0x10;
  DAT_101de770 = 0x11;
  DAT_101de788 = 0x12;
  DAT_101de7a0 = 0x13;
  DAT_101de7b8 = 0x14;
  DAT_101de7d0 = 0x15;
  DAT_101de7e8 = 0x16;
  DAT_101de800 = 0x17;
  DAT_101de818 = 0x18;
  DAT_101de830 = 0x19;
  DAT_101de848 = 0x1a;
  DAT_101de860 = 0x1b;
  DAT_101de878 = 0x1c;
  DAT_101de890 = 0x1d;
  DAT_101de8a8 = 0x1e;
  DAT_101de8c0 = 0x1f;
  DAT_101de8d8 = 0x20;
  DAT_101de8f0 = 0x21;
  DAT_101de908 = 0x22;
  DAT_101de920 = 0x23;
  DAT_101de938 = 0x24;
  DAT_101de950 = 0x25;
  DAT_101de968 = 0x26;
  DAT_101de980 = 0x27;
  return;
}



// Setting prototype: int validate_amt(void *amt_data)

int validate_amt(void *amt_data)

{
  int player_data;
  char *pcVar1;
  int iVar2;
  
                    // 
                    // Validates an 'Amt' (office/rank) entry based on various criteria.
                    // 
                    // Parameters:
                    //   amt_data: Pointer to the Amt data structure.
                    // 
                    // Return values:
                    //   1 if the Amt is valid, 0 otherwise.
                    // 
                    // WARNING: Load size is inaccurate
  player_data = handleGetPlayerById(*amt_data);
  if ((player_data != 0) && (*(char *)(player_data + 0x168) == '\0')) {
    player_data = 0;
    pcVar1 = &g_aemter_data;
    do {
      if (*pcVar1 == *(char *)((int)amt_data + 4)) {
        if (0x1d < player_data) {
          return 0;
        }
        if ((&DAT_101de5a4)[player_data * 6] != -1) {
          return 0;
        }
        if ((&DAT_101de5b0)[player_data * 0x18] != '\x03') {
          return 0;
        }
        if (3 < (int)(&DAT_101de5ac)[player_data * 6]) {
          return 0;
        }
        if (*(char *)((int)amt_data + 6) != (&DAT_101de5a8)[player_data * 0x18]) {
          return 0;
        }
        if (*(char *)((int)amt_data + 5) != -1) {
          iVar2 = 0;
          pcVar1 = &g_aemter_data;
          while (*pcVar1 != *(char *)((int)amt_data + 5)) {
            pcVar1 = pcVar1 + 0x18;
            iVar2 = iVar2 + 1;
            if (0x101de86f < (int)pcVar1) {
              return 0;
            }
          }
          if (0x1d < iVar2) {
            return 0;
          }
          if ((&DAT_101de5a8)[player_data * 0x18] != (&DAT_101de5a8)[iVar2 * 0x18]) {
            return 0;
          }
          if ((&DAT_101de5a4)[iVar2 * 6] != -1) {
            return 0;
          }
          if ((&DAT_101de5b0)[iVar2 * 0x18] != '\x03') {
            return 0;
          }
          if (3 < (int)(&DAT_101de5ac)[iVar2 * 6]) {
            return 0;
          }
        }
        return 1;
      }
      pcVar1 = pcVar1 + 0x18;
      player_data = player_data + 1;
    } while ((int)pcVar1 < 0x101de870);
  }
  return 0;
}



// Setting prototype: int assign_player_to_amt(void *assignment_data)

int handleAssignPlayerToAmt(void *assignment_data)

{
  byte bVar1;
  void *pvVar2;
  short *psVar3;
  char *pcVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined4 *puVar9;
  void **ppvVar10;
  void *local_18 [4];
  int local_8;
  byte amt_id;
  
                    // 
                    // Assigns a player to a specific 'Amt' (office/rank).
                    // This function validates the assignment and updates player and Amt data
                    // accordingly.
                    // 
                    // Parameters:
                    //   assignment_data: Pointer to the assignment data structure.
                    // 
                    // Return values:
                    //   1 if the assignment is successful, 0 otherwise.
                    // 
  pvVar2 = assignment_data;
                    // WARNING: Load size is inaccurate
  psVar3 = (short *)handleGetPlayerById(*assignment_data);
  if (((psVar3 != (short *)0x0) && (*psVar3 != -1)) && ((char)psVar3[0xb4] == '\0')) {
    iVar6 = 0;
    pcVar4 = &g_aemter_data;
    do {
      if (*pcVar4 == *(char *)((int)assignment_data + 4)) {
        if (0x1d < iVar6) {
          return 0;
        }
        amt_id = *(byte *)((int)assignment_data + 6);
        iVar7 = iVar6 * 0x18;
        assignment_data = (void *)(uint)amt_id;
        bVar1 = (&DAT_101de5a8)[iVar7];
        if (amt_id != bVar1) {
          return 0;
        }
        if (*(char *)((int)pvVar2 + 5) == -1) {
          if ((&DAT_101de5a4)[iVar6 * 6] != -1) {
            return 0;
          }
          if ((&DAT_101de5b0)[iVar7] != '\x03') {
            return 0;
          }
          if (3 < (int)(&DAT_101de5ac)[iVar6 * 6]) {
            return 0;
          }
          *(byte *)(psVar3 + 0xb4) = amt_id;
          (&DAT_101de5ac)[iVar6 * 6] = (&DAT_101de5ac)[iVar6 * 6] + 1;
          return 1;
        }
        iVar8 = 0;
        pcVar4 = &g_aemter_data;
        while (*pcVar4 != *(char *)((int)pvVar2 + 5)) {
          pcVar4 = pcVar4 + 0x18;
          iVar8 = iVar8 + 1;
          if (0x101de86f < (int)pcVar4) {
            return 0;
          }
        }
        if (0x1d < iVar8) {
          return 0;
        }
        if (bVar1 != (&DAT_101de5a8)[iVar8 * 0x18]) {
          return 0;
        }
        puVar9 = (undefined4 *)(&DAT_10029bb8 + (uint)bVar1 * 0x18);
        ppvVar10 = local_18;
        for (iVar5 = 6; iVar5 != 0; iVar5 = iVar5 + -1) {
          *ppvVar10 = (void *)*puVar9;
          puVar9 = puVar9 + 1;
          ppvVar10 = ppvVar10 + 1;
        }
        if (local_18[0] != assignment_data) {
          return 0;
        }
        if (local_8 == 0) {
          return 0;
        }
        if ((&DAT_101de5a4)[iVar6 * 6] != -1) {
          return 0;
        }
        if ((&DAT_101de5b0)[iVar7] != '\x03') {
          return 0;
        }
        if (3 < (int)(&DAT_101de5ac)[iVar6 * 6]) {
          return 0;
        }
        if ((&DAT_101de5a4)[iVar8 * 6] != -1) {
          return 0;
        }
        if (3 < (int)(&DAT_101de5ac)[iVar8 * 6]) {
          return 0;
        }
        *(byte *)(psVar3 + 0xb4) = amt_id;
        (&DAT_101de5ac)[iVar6 * 6] = (&DAT_101de5ac)[iVar6 * 6] + 1;
        (&DAT_101de5ac)[iVar8 * 6] = (&DAT_101de5ac)[iVar8 * 6] + 1;
        return 1;
      }
      pcVar4 = pcVar4 + 0x18;
      iVar6 = iVar6 + 1;
    } while ((int)pcVar4 < 0x101de870);
  }
  return 0;
}



// Setting prototype: int validate_amt_action(void *action_data)

int handleValidateAmtAction(void *action_data)

{
  char *aemter_data_ptr;
  int iVar1;
  
                    // 
                    // Validates an 'Amt' (office/rank) action based on various criteria.
                    // 
                    // Parameters:
                    //   action_data: Pointer to the action data structure.
                    // 
                    // Return values:
                    //   1 if the action is valid, 0 otherwise.
                    // 
  if (*(char *)((int)action_data + 6) != -1) {
                    // WARNING: Load size is inaccurate
    iVar1 = 0;
    aemter_data_ptr = &g_aemter_data;
    while (*aemter_data_ptr != *action_data) {
      aemter_data_ptr = aemter_data_ptr + 0x18;
      iVar1 = iVar1 + 1;
      if (0x101de98f < (int)aemter_data_ptr) {
        return 0;
      }
    }
    if (0x29 < iVar1) {
      return 0;
    }
    if ((&DAT_101de5b0)[iVar1 * 0x18] != '\x01') {
      return 0;
    }
    if ((&DAT_101de5b4)[iVar1 * 6] != -1) {
      return 0;
    }
    if (*(int *)((int)action_data + 7) != -1) {
      iVar1 = handleGetPlayerById(*(int *)((int)action_data + 7));
      if (iVar1 == 0) {
        return 0;
      }
    }
    if (*(int *)((int)action_data + 1) != -1) {
      iVar1 = handleGetPlayerById(*(int *)((int)action_data + 1));
      if (iVar1 == 0) {
        return 0;
      }
    }
  }
  return 1;
}



// Setting prototype: int perform_amt_action(void *action_data)

int handlePerformAmtAction(void *action_data)

{
  char cVar1;
  byte bVar2;
  int iVar3;
  char *pcVar4;
  int iVar5;
  int *piVar6;
  uint uVar7;
  byte *pbVar8;
  uint *puVar9;
  uint *puVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  int local_4;
  
                    // 
                    // Performs an 'Amt' (office/rank) action, such as assigning or unassigning
                    // players, or modifying Amt properties.
                    // 
                    // Parameters:
                    //   action_data: Pointer to the action data structure.
                    // 
                    // Return values:
                    //   1 if the action is successful, 0 otherwise.
                    // 
  local_4 = -1;
  if ((*(int *)((int)action_data + 7) != -1) &&
     (iVar3 = handleGetPlayerById(*(int *)((int)action_data + 7)), iVar3 == 0)) {
    return 0;
  }
  iVar3 = 0;
  if (*(int *)((int)action_data + 1) != -1) {
    iVar3 = handleGetPlayerById(*(int *)((int)action_data + 1));
    if (iVar3 == 0) {
      return 0;
    }
    local_4 = *(int *)(iVar3 + 4);
  }
                    // WARNING: Load size is inaccurate
  iVar12 = 0;
  pcVar4 = &g_aemter_data;
  while (*pcVar4 != *action_data) {
    pcVar4 = pcVar4 + 0x18;
    iVar12 = iVar12 + 1;
    if (0x101de98f < (int)pcVar4) {
      return 0;
    }
  }
  if (0x29 < iVar12) {
    return 0;
  }
  iVar13 = iVar12 * 0x18;
  iVar5 = handleGetPlayerById((&DAT_101de5a4)[iVar12 * 6]);
  if ((iVar5 != 0) && (*(int *)(iVar5 + 4) != *(int *)((int)action_data + 1))) {
    cVar1 = (&DAT_101de5a8)[iVar13];
    if (*(char *)(iVar5 + 0x166) == cVar1) {
      *(undefined1 *)(iVar5 + 0x166) = 0;
    }
    else if (*(char *)(iVar5 + 0x169) == cVar1) {
      *(undefined1 *)(iVar5 + 0x169) = 0;
    }
    else {
      if (cVar1 == '#') {
        uVar7 = *(uint *)(iVar5 + 0x1cc) & 0xfffffdff;
      }
      else if (cVar1 == '$') {
        uVar7 = *(uint *)(iVar5 + 0x1cc) & 0xfffffbff;
      }
      else {
        if (cVar1 != '%') goto LAB_1000b5cd;
        uVar7 = *(uint *)(iVar5 + 0x1cc) & 0xfffff7ff;
      }
      *(uint *)(iVar5 + 0x1cc) = uVar7;
    }
  }
LAB_1000b5cd:
  if (iVar3 == 0) goto LAB_1000b6ec;
  bVar2 = (&DAT_101de5a8)[iVar13];
  if (0x1b < bVar2) {
    if ((bVar2 < 0x1c) || (0x22 < bVar2)) {
      uVar11 = 0;
      uVar7 = *(uint *)(iVar3 + 0x1cc) & 0xfffff1ff;
      *(uint *)(iVar3 + 0x1cc) = uVar7;
      cVar1 = (&DAT_101de5a8)[iVar13];
      if (cVar1 == '#') {
        uVar11 = 0x4000;
        *(uint *)(iVar3 + 0x1cc) = uVar7 | 0x200;
      }
      else if (cVar1 == '$') {
        uVar11 = 0x8000;
        *(uint *)(iVar3 + 0x1cc) = uVar7 | 0x400;
      }
      else if (cVar1 == '%') {
        uVar11 = 0x10000;
        *(uint *)(iVar3 + 0x1cc) = uVar7 | 0x800;
      }
      puVar9 = &DAT_10035a6c;
      do {
        puVar10 = puVar9 + 0x87;
        *puVar9 = *puVar9 & ~uVar11;
        puVar9 = puVar10;
      } while ((int)puVar10 < 0x1009ae6c);
    }
    else {
      if (*(char *)(iVar3 + 0x169) != '\0') {
        piVar6 = &DAT_101de874;
        do {
          if (((char)piVar6[1] == *(char *)(iVar3 + 0x169)) && (*piVar6 == *(int *)(iVar3 + 4))) {
            *piVar6 = -1;
          }
          piVar6 = piVar6 + 6;
        } while ((int)piVar6 < 0x101de91c);
      }
      *(undefined1 *)(iVar3 + 0x169) = (&DAT_101de5a8)[iVar13];
    }
    goto LAB_1000b6ec;
  }
  if (*(char *)(iVar3 + 0x166) != '\0') {
    iVar5 = 0;
    piVar6 = &DAT_101de5a4;
    do {
      if (*piVar6 == local_4) {
        (&DAT_101de5a4)[iVar5 * 6] = 0xffffffff;
        (&DAT_101de5b4)[iVar5 * 6] = 0xffffffff;
        (&DAT_101de5b0)[iVar5 * 0x18] = 4;
        (&DAT_101de5ac)[iVar5 * 6] = 0;
        break;
      }
      piVar6 = piVar6 + 6;
      iVar5 = iVar5 + 1;
    } while ((int)piVar6 < 0x101de874);
  }
  if ((byte)(&DAT_10029bc0)[(uint)*(byte *)(iVar3 + 0x166) * 0x18] <=
      (byte)(&DAT_10029bc0)[(uint)(byte)(&DAT_101de5a8)[iVar13] * 0x18]) {
    *(undefined1 *)(iVar3 + 0x167) = (&DAT_101de5a8)[iVar13];
  }
  cVar1 = (&DAT_101de5a8)[iVar13];
  *(char *)(iVar3 + 0x166) = cVar1;
  if (*(char *)(iVar3 + 0x168) == cVar1) {
    *(undefined1 *)(iVar3 + 0x168) = 0;
  }
  cVar1 = (&DAT_101de5a8)[iVar13];
  if (cVar1 == '\x0f') {
    uVar7 = *(uint *)(iVar3 + 0x1cc) | 0x40;
LAB_1000b6ad:
    *(uint *)(iVar3 + 0x1cc) = uVar7;
  }
  else {
    if (cVar1 == '\x15') {
      uVar7 = *(uint *)(iVar3 + 0x1cc) | 0x80;
      goto LAB_1000b6ad;
    }
    if (cVar1 == '\x1b') {
      uVar7 = *(uint *)(iVar3 + 0x1cc) | 0x100;
      goto LAB_1000b6ad;
    }
  }
  if (*(int *)(&DAT_10029bc8 + (uint)(byte)(&DAT_101de5a8)[iVar13] * 0x18) != 0) {
    iVar3 = 0;
    pbVar8 = &DAT_101de5a8;
    do {
      if ((*pbVar8 == (&DAT_101de5a8)[iVar13]) && (iVar3 != iVar12)) {
        if (((&DAT_101de5b0)[iVar3 * 0x18] == '\x03') &&
           (((&DAT_101de5ac)[iVar3 * 6] != 0 &&
            (iVar5 = (&DAT_101de5ac)[iVar3 * 6] + -1, (&DAT_101de5ac)[iVar3 * 6] = iVar5, iVar5 == 0
            )))) {
          (&DAT_101de5b0)[iVar3 * 0x18] = 4;
        }
        break;
      }
      pbVar8 = pbVar8 + 0x18;
      iVar3 = iVar3 + 1;
    } while ((int)pbVar8 < 0x101de878);
  }
LAB_1000b6ec:
  (&DAT_101de5a4)[iVar12 * 6] = local_4;
  (&DAT_101de5b4)[iVar12 * 6] = *(undefined4 *)((int)action_data + 7);
  (&DAT_101de5b0)[iVar13] = *(undefined1 *)((int)action_data + 5);
  if (*(char *)((int)action_data + 5) == '\x03') {
    (&DAT_101de5ac)[iVar12 * 6] = 0;
  }
  return 1;
}



// Setting prototype: void register_player_for_amt(uint32_t player_id)

void handleRegisterPlayerForAmt(uint32_t player_id)

{
  char *pcVar1;
  int iVar2;
  
                    // 
                    // Registers a player for an 'Amt' (office/rank).
                    // 
                    // Parameters:
                    //   player_id: The ID of the player to register.
                    // 
  iVar2 = 0x29;
  pcVar1 = &DAT_101de980;
  do {
    if (*pcVar1 == '&') {
      (&DAT_101de5a4)[iVar2 * 6] = player_id;
      return;
    }
    pcVar1 = pcVar1 + -0x18;
    iVar2 = iVar2 + -1;
  } while (pcVar1 != &DAT_101de5a8);
  return;
}



// Setting prototype: void unregister_player_from_amt(uint32_t player_id)

void handleUnregisterPlayerFromAmt(uint32_t player_id)

{
  char *pcVar1;
  int iVar2;
  
                    // 
                    // Unregisters a player from an 'Amt' (office/rank).
                    // 
                    // Parameters:
                    //   player_id: The ID of the player to unregister.
                    // 
  iVar2 = 0x29;
  pcVar1 = &DAT_101de980;
  do {
    if (*pcVar1 == '\'') {
      (&DAT_101de5a4)[iVar2 * 6] = player_id;
      return;
    }
    pcVar1 = pcVar1 + -0x18;
    iVar2 = iVar2 + -1;
  } while (pcVar1 != &DAT_101de5a8);
  return;
}



// Setting prototype: int swap_players_in_amt(void *swap_data)

int handleSwapPlayersInAmt(void *swap_data)

{
  undefined4 uVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
                    // 
                    // Swaps two players within an 'Amt' (office/rank).
                    // 
                    // Parameters:
                    //   swap_data: Pointer to the swap data structure.
                    // 
                    // Return values:
                    //   1 if the swap is successful, 0 otherwise.
                    // 
                    // WARNING: Load size is inaccurate
  iVar2 = handleGetPlayerById(*swap_data);
  if (iVar2 == 0) {
    return 0;
  }
  if (*(int *)(iVar2 + 0x194) < *(int *)((int)swap_data + 6)) {
    return 0;
  }
  iVar6 = 0;
  pcVar3 = &g_aemter_data;
  while (*pcVar3 != *(char *)((int)swap_data + 4)) {
    pcVar3 = pcVar3 + 0x18;
    iVar6 = iVar6 + 1;
    if (0x101de86f < (int)pcVar3) {
      return 0;
    }
  }
  if (iVar6 * 0x18 == -0x101de5a0) {
    return 0;
  }
  iVar4 = handleGetPlayerById((&DAT_101de5a4)[iVar6 * 6]);
  if (iVar4 == 0) {
    return 0;
  }
  iVar7 = 0;
  pcVar3 = &g_aemter_data;
  while (*pcVar3 != *(char *)((int)swap_data + 5)) {
    pcVar3 = pcVar3 + 0x18;
    iVar7 = iVar7 + 1;
    if (0x101de86f < (int)pcVar3) {
      return 0;
    }
  }
  if (iVar7 * 0x18 == -0x101de5a0) {
    return 0;
  }
  iVar5 = handleGetPlayerById((&DAT_101de5a4)[iVar7 * 6]);
  if (iVar5 == 0) {
    return 0;
  }
  *(undefined1 *)(iVar4 + 0x166) = (&DAT_101de5a8)[iVar7 * 0x18];
  *(undefined1 *)(iVar5 + 0x166) = (&DAT_101de5a8)[iVar6 * 0x18];
  uVar1 = (&DAT_101de5a4)[iVar6 * 6];
  (&DAT_101de5a4)[iVar6 * 6] = (&DAT_101de5a4)[iVar7 * 6];
  (&DAT_101de5a4)[iVar7 * 6] = uVar1;
  *(int *)(iVar2 + 0x194) = *(int *)(iVar2 + 0x194) - *(int *)((int)swap_data + 6);
  return 1;
}



// Setting prototype: int remove_player_from_amt(void *player_data)

int handleRemovePlayerFromAmt(void *player_data)

{
  ushort uVar1;
  int iVar2;
  int *piVar3;
  
                    // 
                    // Removes a player from an 'Amt' (office/rank).
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   1 if the player was successfully removed, 0 otherwise.
                    // 
  uVar1 = DAT_10035884;
  iVar2 = 0;
  piVar3 = &DAT_101de5b4;
  do {
    if (piVar3[-4] == *(int *)((int)player_data + 4)) {
      piVar3[-4] = -1;
      *piVar3 = -1;
      *(char *)(piVar3 + -1) = (0xb < uVar1) + '\x03';
      piVar3[-2] = 0;
      iVar2 = 1;
    }
    else if (*piVar3 == *(int *)((int)player_data + 4)) {
      *piVar3 = -1;
      *(undefined1 *)(piVar3 + -1) = 1;
    }
    piVar3 = piVar3 + 6;
  } while ((int)piVar3 < 0x101de9a4);
  if (*(char *)((int)player_data + 0x168) != '\0') {
    piVar3 = &DAT_101de5ac;
    do {
      if (((char)piVar3[-1] == *(char *)((int)player_data + 0x168)) && (0 < *piVar3)) {
        iVar2 = 1;
        *piVar3 = *piVar3 + -1;
      }
      piVar3 = piVar3 + 6;
    } while ((int)piVar3 < 0x101de99c);
  }
  *(undefined1 *)((int)player_data + 0x166) = 0;
  *(undefined1 *)((int)player_data + 0x169) = 0;
  *(undefined1 *)((int)player_data + 0x168) = 0;
  return iVar2;
}



// Setting prototype: void remove_player_from_amt_with_cleanup(void *player_data, int cleanup_flags)

void handleRemovePlayerFromAmtWithCleanup(void *player_data,int cleanup_flags)

{
  ushort uVar1;
  int *piVar2;
  
                    // 
                    // Removes a player from an 'Amt' (office/rank) and performs additional cleanup
                    // based on flags.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   cleanup_flags: Flags indicating what cleanup operations to perform.
                    // 
  uVar1 = DAT_10035884;
  piVar2 = &DAT_101de5b4;
  do {
    if ((piVar2[-4] == *(int *)((int)player_data + 4)) && (cleanup_flags != 0)) {
      piVar2[-4] = -1;
      *piVar2 = -1;
      *(char *)(piVar2 + -1) = (0xb < uVar1) + '\x03';
      piVar2[-2] = 0;
    }
    else if (*piVar2 == *(int *)((int)player_data + 4)) {
      *piVar2 = -1;
      *(undefined1 *)(piVar2 + -1) = 1;
    }
    piVar2 = piVar2 + 6;
  } while ((int)piVar2 < 0x101de9a4);
  if (*(char *)((int)player_data + 0x168) != '\0') {
    piVar2 = &DAT_101de5ac;
    do {
      if (((char)piVar2[-1] == *(char *)((int)player_data + 0x168)) && (0 < *piVar2)) {
        *piVar2 = *piVar2 + -1;
      }
      piVar2 = piVar2 + 6;
    } while ((int)piVar2 < 0x101de99c);
  }
  if (cleanup_flags != 0) {
    *(undefined1 *)((int)player_data + 0x166) = 0;
    *(undefined1 *)((int)player_data + 0x169) = 0;
  }
  *(undefined1 *)((int)player_data + 0x168) = 0;
  return;
}



// Setting prototype: int aemter_load(void *file_handle, uint32_t file_size)

int amt_fio_LoadAemter(void *file_handle,uint32_t file_size)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  uint uVar4;
  undefined4 *buffer;
  uint local_104;
  CHAR local_100 [256];
  
                    // 
                    // Loads 'Amt' (office/rank) data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    //   file_size: The size of the file.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  uVar2 = ((int)file_size < 0x10051) - 1 & 5;
  uVar3 = uVar2 + 0x25;
  init_offices();
  if (file_handle == (void *)0x0) {
    return 0;
  }
  bVar1 = handleReadFileData(&local_104,4,1,file_handle);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe73,
               s_amt_fio_LoadAemter____Can_t_load_1002a0c8,1);
    return 0;
  }
  if (local_104 != uVar3) {
    printf_wrapper(local_100,s_amt_fio_LoadAemter____count_read_1002a06c,local_104,0x2a);
    logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe7c,local_100,1);
    return 0;
  }
  uVar4 = 0;
  if (uVar2 != 0xffffffdb) {
    buffer = &DAT_101de5a4;
    do {
      bVar1 = handleReadFileData(buffer + -1,1,1,file_handle);
      if (CONCAT31(extraout_var_00,bVar1) == 0) {
        logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe82,
                   s_amt_fio_LoadAemter____Can_t_load_1002a048,1);
        return 0;
      }
      bVar1 = handleReadFileData(buffer,4,1,file_handle);
      if (CONCAT31(extraout_var_01,bVar1) == 0) {
        logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe83,
                   s_amt_fio_LoadAemter____Can_t_load_1002a01c,1);
        return 0;
      }
      bVar1 = handleReadFileData(buffer + 1,1,1,file_handle);
      if (CONCAT31(extraout_var_02,bVar1) == 0) {
        logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe84,
                   s_amt_fio_LoadAemter____Can_t_load_10029ff4,1);
        return 0;
      }
      bVar1 = handleReadFileData(buffer + 2,4,1,file_handle);
      if (CONCAT31(extraout_var_03,bVar1) == 0) {
        logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe85,
                   s_amt_fio_LoadAemter____Can_t_load_10029fcc,1);
        return 0;
      }
      bVar1 = handleReadFileData(buffer + 3,1,1,file_handle);
      if (CONCAT31(extraout_var_04,bVar1) == 0) {
        logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe86,
                   s_amt_fio_LoadAemter____Can_t_load_10029fa4,1);
        return 0;
      }
      bVar1 = handleReadFileData(buffer + 4,4,1,file_handle);
      if (CONCAT31(extraout_var_05,bVar1) == 0) {
        logMessage(s_D__Develop_DieGildeAddOn_game_ae_1002a0a0,0xe87,
                   s__amt_fio_LoadAemter____Can_t_loa_10029f77 + 1,1);
        return 0;
      }
      uVar4 = uVar4 + 1;
      buffer = buffer + 6;
    } while (uVar4 < uVar3);
  }
  return 1;
}



// Setting prototype: void player_aemter_init(void *player_data)

void player_AemterInit(void *player_data)

{
  uint *puVar1;
  
                    // 
                    // Initializes the 'Amt' (office/rank) related data for a player.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
  if (((*(char *)((int)player_data + 2) == '\x01') || (*(char *)((int)player_data + 2) == '\x02'))
     && (*(char *)((int)player_data + 0x164) != '\0')) {
    puVar1 = (uint *)((int)player_data + 0x1b4);
    *puVar1 = 0;
    *(undefined4 *)((int)player_data + 0x1b8) = 0;
    *(undefined4 *)((int)player_data + 0x1bc) = 0;
    *(undefined4 *)((int)player_data + 0x1c0) = 0;
    *(undefined4 *)((int)player_data + 0x1c0) = 0xffffffff;
    *puVar1 = *puVar1 | 1;
  }
  return;
}



// Setting prototype: bool is_player_in_amt(void *player_data)

bool handleIsPlayerInAmt(void *player_data)

{
  byte *pbVar1;
  
                    // 
                    // Checks if a player is currently assigned to an 'Amt' (office/rank).
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   True if the player is in an Amt, false otherwise.
                    // 
  if ((((*(byte *)((int)player_data + 0x1cc) & 4) != 0) &&
      (pbVar1 = *(byte **)((int)player_data + 0x16c), pbVar1 != (byte *)0x0)) &&
     (*(char *)(DAT_100a8c30 + (uint)*pbVar1 * 0x24d) == '\x1e')) {
    return *(int *)(pbVar1 + 0x65) != 0;
  }
  return false;
}



// Setting prototype: uint16_t get_player_amt_id(void *player_data)

uint16_t handleGetPlayerAmtId(void *player_data)

{
  ushort *puVar1;
  ushort uVar2;
  ushort uVar3;
  short *psVar4;
  int iVar5;
  int32_t iVar6;
  uint uVar7;
  undefined4 uVar8;
  int iVar9;
  int iVar10;
  ushort *puVar11;
  undefined4 *puVar12;
  float fVar13;
  int iVar14;
  char *pcVar15;
  byte *local_8;
  int local_4;
  
                    // 
                    // Retrieves the 'Amt' (office/rank) ID associated with a player.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   The Amt ID if found, or 0xFFFF if not found or an error occurs.
                    // 
  gm_LoadGameData(&local_8,(void **)0x0,(void **)0x0,*(uint32_t *)((int)player_data + 8));
  if (local_8 == (byte *)0x0) {
    pcVar15 = s_ahm_ExAllocAlchemist__cant_find_t_1002a19c;
    iVar14 = 0x449;
  }
  else {
    if (*(char *)(DAT_100a8c30 + (uint)*local_8 * 0x24d) == '\x1e') {
      iVar14 = 0;
      psVar4 = &DAT_100358a0;
      do {
        if (*psVar4 == -1) break;
        psVar4 = psVar4 + 0x10e;
        iVar14 = iVar14 + 1;
      } while ((int)psVar4 < 0x1009aca0);
      if (iVar14 == 0x300) {
        iVar14 = 0;
        pcVar15 = &DAT_100358a2;
        do {
          if (*pcVar15 == '\x0f') break;
          pcVar15 = pcVar15 + 0x21c;
          iVar14 = iVar14 + 1;
        } while ((int)pcVar15 < 0x1009aca2);
        if (iVar14 == 0x300) {
          pcVar15 = s_ahm_ExAllocAlchemist__array_over_1002a140;
          iVar14 = 0x45d;
          goto LAB_1000be9f;
        }
      }
      iVar10 = iVar14 * 0x21c;
      if ((&DAT_100358a2)[iVar10] == '\x0f') {
        DAT_10035434 = DAT_10035434 + -1;
      }
      puVar1 = &DAT_100358a0 + iVar14 * 0x10e;
      puVar11 = puVar1;
      for (iVar9 = 0x87; iVar9 != 0; iVar9 = iVar9 + -1) {
        puVar11[0] = 0;
        puVar11[1] = 0;
        puVar11 = puVar11 + 2;
      }
      *puVar1 = 0xffff;
      (&DAT_100358a4)[iVar14 * 0x87] = 0xffffffff;
      puVar12 = &DAT_100358fc + iVar14 * 0x87;
      for (iVar9 = 8; iVar9 != 0; iVar9 = iVar9 + -1) {
        *puVar12 = 0xffffffff;
        puVar12 = puVar12 + 1;
      }
      DAT_10035434 = DAT_10035434 + 1;
      *puVar1 = (ushort)iVar14;
      (&DAT_10035a10)[iVar14 * 0x87] = local_8;
      (&DAT_10035a0c)[iVar14 * 0x87] = local_8;
      (&DAT_100358a2)[iVar10] = 0;
      (&DAT_100358a4)[iVar14 * 0x87] = DAT_10030b6c;
      DAT_10030b6c = DAT_10030b6c + 1;
      *(undefined4 *)(iVar10 + 0x10035a90) = 0;
      (&DAT_10035ab0)[iVar14 * 0x87] = 0xffffffff;
      *(undefined1 *)(iVar10 + 0x10035ab5) = 0;
      *(undefined1 *)(iVar10 + 0x10035ab6) = 0;
      *(undefined1 *)(iVar10 + 0x10035ab7) = 0;
      *(undefined1 *)(iVar10 + 0x10035ab8) = 1;
      *(undefined4 *)(iVar10 + 0x10035a84) = 0x3f800000;
      (&DAT_100358a8)[iVar10] = 100;
      *(ushort *)(&DAT_100358aa + iVar10) = (ushort)*(byte *)((int)player_data + 0x10);
      (&DAT_10035a04)[iVar10] = 0x52;
      *(undefined1 *)(iVar10 + 0x10035a06) = 0;
      (&DAT_10035a05)[iVar10] = 0;
      *(undefined1 *)(iVar10 + 0x10035a94) = 0;
      *(undefined4 *)(&DAT_10035a30 + iVar10) = 4;
      *(undefined4 *)(&DAT_10035a34 + iVar10) = 0;
      *(undefined1 *)(iVar10 + 0x100358ad) = 1;
      *(undefined4 *)(iVar10 + 0x10035a2c) = 0xffffffff;
      *(undefined4 *)(&DAT_10035aac + iVar10) = 0xffffffff;
      *(undefined2 *)(&DAT_100358f0 + iVar10) = 0x7fff;
      iVar9 = 0;
      do {
        iVar5 = get_random_number(0x40);
        *(char *)(iVar10 + 0x10035920 + iVar9) = (char)iVar5 + 'T';
        iVar9 = iVar9 + 1;
      } while (iVar9 < 5);
      *(undefined1 *)(iVar10 + 0x100358a9) = 0;
      *(undefined4 *)(iVar10 + 0x100358bc) = 0x447a0000;
      fVar13 = get_random_float_in_range();
      *(undefined4 *)(&DAT_100358c0 + iVar10) = 0x41400000;
      *(float *)(iVar10 + 0x100358b4) = (fVar13 * 7.0 + 30.0) - 2.0;
      iVar6 = __ftol();
      uVar7 = get_random_number((uint16_t)iVar6);
      *(undefined4 *)(iVar10 + 0x100358b8) = *(undefined4 *)(iVar10 + 0x100358bc);
      local_4 = 0;
      iVar9 = 0;
      *(float *)(iVar10 + 0x100358b0) =
           (*(float *)(iVar10 + 0x100358bc) * 0.33 + (float)(uVar7 & 0xffff)) -
           *(float *)(iVar10 + 0x100358bc) * 0.1;
      do {
        uVar2 = *puVar1;
        iVar10 = get_random_number(0x40);
        (&DAT_100a9820)[(uint)uVar2 + iVar9] = (char)iVar10 + -0x20;
        uVar3 = *puVar1;
        (&DAT_1014d8e0)[(uint)uVar2 + iVar9] = 0;
        iVar10 = (uint)uVar3 * 0x300 + local_4;
        iVar5 = get_random_number(0x40);
        iVar9 = iVar9 + 0x300;
        local_4 = local_4 + 1;
        (&DAT_100a9820)[iVar10] = (char)iVar5 + -0x20;
        (&DAT_1014d8e0)[iVar10] = 0;
      } while (iVar9 < 0x90000);
      if (*(int *)(local_8 + 0x65) == 0) {
        uVar8 = mAlloc(0x3c,s__ahm_AllocAhmInfo_1002a0f7 + 1);
        *(undefined4 *)(local_8 + 0x65) = uVar8;
      }
      puVar12 = *(undefined4 **)(local_8 + 0x65);
      for (iVar10 = 0xf; iVar10 != 0; iVar10 = iVar10 + -1) {
        *puVar12 = 0;
        puVar12 = puVar12 + 1;
      }
      **(undefined4 **)(local_8 + 0x65) = (&DAT_100358a4)[iVar14 * 0x87];
      *(float *)(*(int *)(local_8 + 0x65) + 4) =
           ((float)*(byte *)((int)player_data + 0xf) * 0.003968254 + 1.0) * 0.5;
      *(undefined1 *)(*(int *)(local_8 + 0x65) + 8) = *(undefined1 *)((int)player_data + 0xc);
      *(undefined1 *)(*(int *)(local_8 + 0x65) + 9) = *(undefined1 *)((int)player_data + 0xd);
      *(undefined1 *)(*(int *)(local_8 + 0x65) + 10) = *(undefined1 *)((int)player_data + 0xe);
      *(undefined1 *)(*(int *)(local_8 + 0x65) + 0xb) = *(undefined1 *)((int)player_data + 0xf);
      *(undefined4 *)(*(int *)(local_8 + 0x65) + 0xc) = *(undefined4 *)((int)player_data + 0x14);
      iVar10 = handleFindObjectInList(*(undefined4 *)(local_8 + 0x5d),2,6,0,0xff);
      if (iVar10 != 0) {
        puVar11 = *(ushort **)(iVar10 + 0x14);
        while (puVar11 != (ushort *)0x0) {
          handleRemoveObjectFromList((void *)(iVar10 + 0x14),(uint)*puVar11);
          puVar11 = *(ushort **)(iVar10 + 0x14);
        }
      }
      *(undefined4 *)(*(int *)(local_8 + 0x65) + 0x10) = *(undefined4 *)((int)player_data + 0x20);
      if (iVar10 != 0) {
        gm_AddObject(*(undefined4 *)(iVar10 + 2),*(undefined4 *)((int)player_data + 0x14),2);
      }
      handleLoadGameData7((uint)DAT_10035439);
      (&DAT_10035a6c)[iVar14 * 0x87] = (&DAT_10035a6c)[iVar14 * 0x87] | 4;
      return *puVar1;
    }
    pcVar15 = s_ahm_ExAllocAlchemist__wrong_type_1002a168;
    iVar14 = 0x451;
  }
LAB_1000be9f:
  logMessage(s_D__Develop_DieGildeAddOn_game_al_1002a10c,iVar14,pcVar15,1);
  return 0xffff;
}



// Setting prototype: int set_player_attributes(void *player_data, int attribute_value)

int set_player_attributes(void *player_data,int attribute_value)

{
  int32_t iVar1;
  
                    // 
                    // Sets various attributes for a player.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   attribute_value: The value to set for the attribute.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  switch(*(undefined4 *)((int)player_data + 8)) {
  case 0:
    iVar1 = __ftol();
    *(char *)(attribute_value + 8) = (char)iVar1;
    return 1;
  case 1:
    iVar1 = __ftol();
    *(char *)(attribute_value + 9) = (char)iVar1;
    return 1;
  case 2:
    iVar1 = __ftol();
    *(char *)(attribute_value + 10) = (char)iVar1;
    return 1;
  case 3:
    iVar1 = __ftol();
    *(char *)(attribute_value + 0xb) = (char)iVar1;
    return 1;
  default:
    return 0;
  }
}



// Setting prototype: int add_player_to_building(void *player_data, void *building_data, void
// *game_data)

int add_player_to_building(void *player_data,void *building_data,void *game_data)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
                    // 
                    // Adds a player to a building.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   building_data: Pointer to the building's data structure.
                    //   game_data: Pointer to the game's data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  iVar3 = 0;
  piVar1 = (int *)((int)building_data + 0xc);
  do {
    if (*piVar1 == 0) {
      iVar2 = handleFindObjectInList(*(undefined4 *)((int)game_data + 0x5d),2,6,0,0xff);
      *(undefined4 *)((int)player_data + 0x14) = DAT_10030b6c;
      *(undefined4 *)((int)building_data + iVar3 * 8 + 0xc) = *(undefined4 *)((int)player_data + 8);
      *(undefined4 *)((int)building_data + iVar3 * 8 + 0x10) =
           *(undefined4 *)((int)player_data + 0x10);
      if (iVar2 != 0) {
        gm_AddObject(*(undefined4 *)(iVar2 + 2),*(undefined4 *)((int)player_data + 8),2);
      }
      handleLoadGameData7((uint)DAT_10035439);
      return 1;
    }
    iVar3 = iVar3 + 1;
    piVar1 = piVar1 + 2;
  } while (iVar3 < 6);
  return 0;
}



// Setting prototype: int remove_player_from_building(void *player_data, void *building_data, void
// *game_data)

int remove_player_from_building(void *player_data,void *building_data,void *game_data)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
                    // 
                    // Removes a player from a building.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   building_data: Pointer to the building's data structure.
                    //   game_data: Pointer to the game's data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  iVar3 = 0;
  piVar1 = (int *)((int)building_data + 0xc);
  do {
    if (*piVar1 == *(int *)((int)player_data + 8)) {
      iVar2 = handleFindObjectInList(*(undefined4 *)((int)game_data + 0x5d),2,6,0,0xff);
      if (iVar2 != 0) {
        handleRemoveObjectFromList((void *)(iVar2 + 0x14),*(uint32_t *)((int)player_data + 8));
      }
      *(undefined4 *)((int)building_data + iVar3 * 8 + 0xc) = 0;
      *(undefined4 *)((int)building_data + iVar3 * 8 + 0x10) = 0;
      return 1;
    }
    iVar3 = iVar3 + 1;
    piVar1 = piVar1 + 2;
  } while (iVar3 < 6);
  return 0;
}



// Setting prototype: int update_player_building(void *player_data, void *building_data)

int update_player_building(void *player_data,void *building_data)

{
  int iVar1;
  int *piVar2;
  
                    // 
                    // Updates a player's building information.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  iVar1 = 0;
  piVar2 = (int *)((int)building_data + 0xc);
  do {
    if (*piVar2 == *(int *)((int)player_data + 8)) {
      *(undefined4 *)((int)building_data + iVar1 * 8 + 0x10) =
           *(undefined4 *)((int)player_data + 0x10);
      return 1;
    }
    iVar1 = iVar1 + 1;
    piVar2 = piVar2 + 2;
  } while (iVar1 < 6);
  return 0;
}



// Setting prototype: int update_player_desire(void *player_data, void *desire_data)

int update_player_desire(void *player_data,void *desire_data)

{
  float fVar1;
  
                    // 
                    // Updates a player's desire level.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   desire_data: Pointer to the desire data structure.
                    // 
                    // Return values:
                    //   1 if successful.
                    // 
  fVar1 = *(float *)((int)player_data + 0x10) + *(float *)((int)desire_data + 4);
  if (fVar1 <= 0.0) {
    *(undefined4 *)((int)desire_data + 4) = 0;
    return 1;
  }
  if (fVar1 < 1.0) {
    *(float *)((int)desire_data + 4) = fVar1;
    return 1;
  }
  *(undefined4 *)((int)desire_data + 4) = 0x3f800000;
  return 1;
}



// Setting prototype: int clear_inventory_slot(uint32_t player_id, void *inventory_data, void
// *game_data)

int clear_inventory_slot(uint32_t player_id,void *inventory_data,void *game_data)

{
  ushort *puVar1;
  int iVar2;
  uint32_t *puVar3;
  int iVar4;
  
                    // 
                    // Clears a specific inventory slot for a player.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player.
                    //   inventory_data: Pointer to the player's inventory data.
                    //   game_data: Pointer to the game's data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
                    // WARNING: Load size is inaccurate
  puVar1 = (ushort *)handleGetPlayerById(*inventory_data);
  if (puVar1 != (ushort *)0x0) {
    iVar2 = handleFindObjectInList(*(undefined4 *)((int)game_data + 0x5d),2,6,0,0xff);
    puVar1[0xb8] = 0;
    puVar1[0xb9] = 0;
    puVar1[0xb6] = 0;
    puVar1[0xb7] = 0;
    puVar3 = (uint32_t *)((int)inventory_data + 0xc);
    iVar4 = 6;
    do {
      if (*puVar3 != 0) {
        if (iVar2 != 0) {
          handleRemoveObjectFromList((void *)(iVar2 + 0x14),*puVar3);
        }
        *puVar3 = 0;
        puVar3[1] = 0;
      }
      puVar3 = puVar3 + 2;
      iVar4 = iVar4 + -1;
    } while (iVar4 != 0);
    for (iVar2 = 0xf; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined4 *)inventory_data = 0;
      inventory_data = (undefined4 *)((int)inventory_data + 4);
    }
    gm_KillSpieler((uint)*puVar1,1);
    return 1;
  }
  return 0;
}



// Setting prototype: int load_alchemist_data(void *file_handle, void *alchemist_data)

int load_alchemist_data(void *file_handle,void *alchemist_data)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined4 uVar2;
  int iVar3;
  undefined1 *buffer;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 local_3c;
  undefined1 local_38 [4];
  undefined1 local_34;
  undefined1 local_33;
  undefined1 local_32;
  undefined1 local_31 [5];
  undefined1 local_2c [44];
  
                    // 
                    // Loads alchemist data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    //   alchemist_data: Pointer to the alchemist data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  bVar1 = handleReadFileData(&local_3c,4,1,file_handle);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData(local_38,4,1,file_handle);
  if (CONCAT31(extraout_var_00,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData(&local_34,1,1,file_handle);
  if (CONCAT31(extraout_var_01,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData(&local_33,1,1,file_handle);
  if (CONCAT31(extraout_var_02,bVar1) != 0) {
    bVar1 = handleReadFileData(&local_32,1,1,file_handle);
    if (CONCAT31(extraout_var_03,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(local_31,1,1,file_handle);
    if (CONCAT31(extraout_var_04,bVar1) != 0) {
      iVar3 = 0;
      buffer = local_2c;
      while (bVar1 = handleReadFileData(buffer + -4,4,1,file_handle),
            CONCAT31(extraout_var_05,bVar1) != 0) {
        bVar1 = handleReadFileData(buffer,4,1,file_handle);
        if (CONCAT31(extraout_var_06,bVar1) == 0) {
          return 0;
        }
        iVar3 = iVar3 + 1;
        buffer = buffer + 8;
        if (5 < iVar3) {
          if (*(int *)((int)alchemist_data + 0x65) == 0) {
            uVar2 = mAlloc(0x3c,s__ahm_AllocAhmInfo_1002a0f7 + 1);
            *(undefined4 *)((int)alchemist_data + 0x65) = uVar2;
          }
          puVar4 = &local_3c;
          puVar5 = *(undefined4 **)((int)alchemist_data + 0x65);
          for (iVar3 = 0xf; iVar3 != 0; iVar3 = iVar3 + -1) {
            *puVar5 = *puVar4;
            puVar4 = puVar4 + 1;
            puVar5 = puVar5 + 1;
          }
          return 1;
        }
      }
    }
    return 0;
  }
  return 0;
}



// Setting prototype: void *alloc_alchemist(void)

char * alloc_alchemist(void)

{
  uint uVar1;
  float *pfVar2;
  int iVar3;
  int iVar4;
  
                    // 
                    // Allocates a new alchemist and initializes its data.
                    // 
                    // Return values:
                    //   A pointer to the allocated alchemist data, or NULL if allocation fails.
                    // 
  uVar1 = get_random_number(0x20);
  uVar1 = uVar1 & 0xffff;
  iVar3 = 0x20;
  do {
    if ((&DAT_1002a2c2)[uVar1 * 0xf4] == '\0') {
      iVar4 = 0xe;
      iVar3 = uVar1 * 0xf4;
      pfVar2 = (float *)(&DAT_1002a200 + iVar3);
      do {
        *pfVar2 = pfVar2[-1] * 0.001;
        pfVar2 = pfVar2 + 3;
        iVar4 = iVar4 + -1;
      } while (iVar4 != 0);
      (&DAT_1002a2c2)[iVar3] = 1;
      return s_neVmMaven_1002a1d0 + iVar3;
    }
    iVar3 = iVar3 + -1;
    uVar1 = uVar1 + 1 & 0x1f;
  } while (iVar3 != 0);
  return (char *)0x0;
}



// Setting prototype: void *get_alchemist_by_id(uint32_t alchemist_id)

undefined4 * get_alchemist_by_id(int alchemist_id)

{
  int *piVar1;
  int iVar2;
  
                    // 
                    // Retrieves an alchemist's data by their ID.
                    // 
                    // Parameters:
                    //   alchemist_id: The ID of the alchemist.
                    // 
                    // Return values:
                    //   A pointer to the alchemist's data structure, or NULL if not found.
                    // 
  iVar2 = 0;
  piVar1 = &DAT_1002c050;
  do {
    if (*piVar1 == alchemist_id) {
      return &DAT_1002c050 + iVar2 * 0x17;
    }
    piVar1 = piVar1 + 0x17;
    iVar2 = iVar2 + 1;
  } while ((int)piVar1 < 0x1002c3e8);
  return (undefined4 *)0x0;
}



// Setting prototype: void process_alchemist_turn(void *game_data)

void process_alchemist_turn(void *game_data)

{
  undefined2 *puVar1;
  int iVar2;
  
                    // 
                    // Processes a turn for alchemists in the game.
                    // 
                    // Parameters:
                    //   game_data: Pointer to the game's data structure.
                    // 
  puVar1 = (undefined2 *)handleFindObjectInList(*(undefined4 *)((int)game_data + 0x178),1,5);
  if (puVar1 != (undefined2 *)0x0) {
    while (iVar2 = get_alchemist_by_id(*puVar1), iVar2 == 0) {
      puVar1 = (undefined2 *)handleGetNextObjectFromList();
      if (puVar1 == (undefined2 *)0x0) {
        get_alchemist_by_id(0);
        return;
      }
    }
    if ((*(int *)(iVar2 + 0x58) != 1) && (*(int *)(iVar2 + 0x58) != 2)) {
      return;
    }
    if (0 < *(int *)(puVar1 + 0x10)) {
      return;
    }
  }
  get_alchemist_by_id(0);
  return;
}



// Setting prototype: int get_command_size(void *command_data)

int get_command_size(void *command_data)

{
  int iVar1;
  byte *pbVar2;
  int iVar3;
  uint uVar4;
  
                    // 
                    // Returns the size of a command based on its type.
                    // 
                    // Parameters:
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   The size of the command in bytes.
                    // 
                    // WARNING: Load size is inaccurate
  switch(*command_data) {
  case 3:
  case 0x13:
  case 0x1a:
  case 0x25:
  case 0x2b:
  case 0x34:
  case 0x36:
  case 0x38:
  case 0x47:
  case 0x52:
  case 0x54:
  case 0x5b:
  case 0x5d:
    return 0x1c;
  case 4:
    return 0x11;
  default:
    return 0x91;
  case 8:
  case 0x1c:
  case 0x28:
  case 0x31:
  case 0x3b:
  case 0x42:
  case 0x43:
  case 0x4a:
  case 0x4d:
  case 0x57:
  case 0x58:
  case 0x69:
    return 0x14;
  case 10:
    return 0x50;
  case 0xb:
    return 0x2a;
  case 0xc:
    return 0x49;
  case 0xd:
  case 0x21:
  case 0x23:
  case 0x24:
  case 0x26:
  case 0x27:
  case 0x29:
  case 0x2a:
  case 0x33:
  case 0x39:
  case 0x3a:
  case 0x5a:
  case 0x66:
  case 0x68:
    return 0x18;
  case 0xf:
  case 0x2c:
    return 0x21;
  case 0x11:
  case 0x3d:
    return 0x27;
  case 0x12:
  case 0x1e:
    return 0x1e;
  case 0x14:
    return 0x16;
  case 0x15:
    return 0x39;
  case 0x16:
  case 0x17:
    pbVar2 = (byte *)((int)command_data + 0x15);
    iVar3 = 0x15;
    break;
  case 0x18:
    return (uint)*(byte *)((int)command_data + 0x14) * 5 + 0x15;
  case 0x19:
  case 0x53:
    return 0x24;
  case 0x1b:
  case 100:
    return 0x28;
  case 0x1d:
    return 0x5f;
  case 0x20:
    return (-(uint)(*(char *)((int)command_data + 0x10) != '\x0e') & 0x7c) + 0x11;
  case 0x22:
    return 0x3d;
  case 0x2d:
  case 0x45:
    return 0x1f;
  case 0x2e:
  case 0x3c:
    return 0x20;
  case 0x2f:
  case 0x30:
    return 0x3c;
  case 0x32:
  case 0x3e:
  case 0x4f:
  case 0x5e:
  case 99:
    return 0x34;
  case 0x35:
    return 0x5d;
  case 0x37:
    return 0x45;
  case 0x40:
  case 0x60:
    return 0x2f;
  case 0x41:
    return 0x4a;
  case 0x44:
    return 0x17;
  case 0x46:
    return 0x19;
  case 0x48:
    return 0x15;
  case 0x49:
    return 0x36;
  case 0x4b:
  case 0x67:
    return 0x90;
  case 0x4c:
    return 0x35;
  case 0x4e:
    return 0x40;
  case 0x50:
  case 0x51:
    return 0x44;
  case 0x55:
    return 0x61;
  case 0x56:
    return 0x38;
  case 0x5c:
    return 0x1a;
  case 0x5f:
    return 0x80;
  case 0x61:
  case 0x62:
    return 0x29;
  }
  for (uVar4 = (uint)*(byte *)((int)command_data + 0x14); uVar4 != 0; uVar4 = uVar4 - 1) {
    iVar1 = (uint)pbVar2[1] * (uint)*pbVar2 + 4;
    iVar3 = iVar3 + iVar1;
    pbVar2 = pbVar2 + iVar1;
  }
  return iVar3;
}



// Setting prototype: int process_command(void *command_data)

int process_command(void *command_data)

{
  char cVar1;
  bool bVar2;
  int iVar3;
  byte *pbVar4;
  
                    // 
                    // Processes a single command.
                    // This function dispatches the command to the appropriate handler based on its
                    // type.
                    // 
                    // Parameters:
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   1 if successful, or 0 otherwise.
                    // 
  bVar2 = true;
  pbVar4 = *(byte **)((int)command_data + 0x95);
  do {
    if (*pbVar4 == 6) {
      if (bVar2) {
        *(undefined1 *)command_data = 1;
                    // WARNING: Load size is inaccurate
        cVar1 = *command_data;
        while (cVar1 != '\x06') {
          command_data = *(void **)((int)command_data + 0x95);
                    // WARNING: Load size is inaccurate
          cVar1 = *command_data;
        }
        *(char *)command_data = '\x01';
        return 1;
      }
      break;
    }
    iVar3 = (*(code *)(&PTR_LAB_1002c5a0)[*pbVar4])(pbVar4);
    if (iVar3 != 0) {
      bVar2 = false;
    }
    pbVar4 = *(byte **)(pbVar4 + 0x95);
  } while (bVar2);
                    // WARNING: Load size is inaccurate
  cVar1 = *command_data;
  while (cVar1 != '\x06') {
    *(char *)command_data = '\x02';
    command_data = *(void **)((int)command_data + 0x95);
                    // WARNING: Load size is inaccurate
    cVar1 = *command_data;
  }
  *(char *)command_data = '\x02';
  return 1;
}



// Setting prototype: int get_player_connection(void *player_data, int connection_type)

int gm_GetPlayerConnection(void *player_data,int connection_type)

{
                    // 
                    // Retrieves a player's connection information based on the connection type.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   connection_type: The type of connection to retrieve (-2, -3, -4, or other).
                    // 
                    // Return values:
                    //   The connection information, or the input connection_type if not a special
                    // type.
                    // 
  if (connection_type == -2) {
    return *(int *)(&DAT_10442d00 + (uint)*(byte *)((int)player_data + 3) * 0x264264);
  }
  if (connection_type == -3) {
    return *(int *)(&DAT_10442d04 + (uint)*(byte *)((int)player_data + 3) * 0x264264);
  }
  if (connection_type == -4) {
    connection_type = *(int *)(&DAT_10442d08 + (uint)*(byte *)((int)player_data + 3) * 0x264264);
  }
  return connection_type;
}



undefined4 cm_ChkSellObjekt(short *param_1)

{
  short sVar1;
  short *player_data;
  uint32_t uVar2;
  int iVar3;
  short *psVar4;
  uint extraout_EDX;
  undefined4 extraout_EDX_00;
  longlong lVar5;
  char *message;
  void *local_c;
  void *local_8;
  void *local_4;
  
  player_data = param_1;
  if (*(int *)(param_1 + 10) != -1) {
    uVar2 = gm_GetPlayerConnection(param_1,*(int *)(param_1 + 10));
    *(uint32_t *)(player_data + 10) = uVar2;
    iVar3 = gm_LoadGameData(&local_8,&param_1,&local_c,uVar2);
    if (iVar3 == 0) {
      message = s_cm_ChkSellObjekt___Invalid__quel_1002c8dc;
      iVar3 = 0x236b;
      goto LAB_1000cdb7;
    }
    if (local_8 == (void *)0x0) {
      if (param_1 == (short *)0x0) {
        psVar4 = (short *)((int)local_c + 0x178);
      }
      else {
        psVar4 = param_1 + 10;
      }
    }
    else {
      psVar4 = (short *)((int)local_8 + 0x5d);
    }
    iVar3 = handleFindObjectInList(*(undefined4 *)psVar4,1,0,player_data[0xc]);
    if (iVar3 == 0) {
      message = s_cm_ChkSellObjekt___No_Objekts_at_1002c8b4;
      iVar3 = 0x2383;
      goto LAB_1000cdb7;
    }
    if (*(int *)(iVar3 + 0xe) < *(int *)((int)player_data + 0x1f)) {
      message = s_cm_ChkSellObjekt___Not_enough_Ob_1002c884;
      iVar3 = 0x238f;
      goto LAB_1000cdb7;
    }
  }
  if (*(int *)(player_data + 8) != -1) {
    uVar2 = gm_GetPlayerConnection(player_data,*(int *)(player_data + 8));
    *(uint32_t *)(player_data + 8) = uVar2;
    iVar3 = gm_LoadGameData(&local_4,&param_1,&local_c,uVar2);
    if (iVar3 == 0) {
      message = s_cm_ChkSellObjekt___Invalid__ziel_1002c854;
      iVar3 = 0x23ab;
      goto LAB_1000cdb7;
    }
    if (local_4 == (void *)0x0) {
      if (param_1 == (short *)0x0) {
        uVar2 = add_item_to_building_inventory
                          (local_c,(uint)(ushort)player_data[0xc],
                           *(uint32_t *)((int)player_data + 0x1f));
        lVar5 = CONCAT44(extraout_EDX_00,local_c);
        if ((int)uVar2 < *(int *)((int)player_data + 0x1f)) {
          message = s_cm_ChkSellObjekt___Inventory_vol_1002c810;
          iVar3 = 0x23e3;
          goto LAB_1000cdb7;
        }
      }
      else {
        sVar1 = *param_1;
        if ((((sVar1 == 0x2a) || (sVar1 == 0x116)) || (sVar1 == 0x1dd)) &&
           (iVar3 = gm_IsBuildingInventoryFull
                              (param_1,(uint)(ushort)player_data[0xc],
                               *(int *)((int)player_data + 0x1f)),
           iVar3 < *(int *)((int)player_data + 0x1f))) {
          message = s_cm_ChkSellObjekt___Lager_voll_1002c834;
          iVar3 = 0x23cd;
          goto LAB_1000cdb7;
        }
        lVar5 = gm_GetPlayerSpouse(param_1);
      }
    }
    else if (*(ushort *)((int)local_4 + 0x27) == 0xffff) {
      lVar5 = (ulonglong)extraout_EDX << 0x20;
    }
    else {
      lVar5 = CONCAT44(extraout_EDX,&DAT_100358a0 + (uint)*(ushort *)((int)local_4 + 0x27) * 0x10e);
    }
    if (((*(int *)((int)player_data + 0x23) != 0) && ((int)lVar5 != 0)) &&
       (iVar3 = get_building_item_count
                          (*(uint32_t *)((int)lVar5 + 0x178),
                           CONCAT31((int3)((ulonglong)lVar5 >> 0x28),(char)player_data[0xf])),
       iVar3 < *(int *)((int)player_data + 0x1f) * *(int *)((int)player_data + 0x23))) {
      message = s_cm_ChkSellObjekt___Not_enough_Cr_1002c7d8;
      iVar3 = 0x23ff;
LAB_1000cdb7:
      logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar3,message,8);
      return 1;
    }
  }
  return 0;
}



undefined4 cm_ChkChangeBits(void *param_1)

{
  void *pvVar1;
  uint32_t id;
  int iVar2;
  void *pvVar3;
  char *message;
  void *local_8;
  void *local_4;
  
  pvVar1 = param_1;
  id = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
  *(uint32_t *)((int)pvVar1 + 0x10) = id;
  iVar2 = gm_LoadGameData(&param_1,&local_4,&local_8,id);
  if (iVar2 == 0) {
    message = s_cm_ChkChangeBits___Invalid_Id_1002ca54;
    iVar2 = 0x250d;
  }
  else {
    pvVar3 = param_1;
    if ((param_1 == (void *)0x0) && (pvVar3 = local_4, local_4 == (void *)0x0)) {
      pvVar3 = local_8;
    }
    if ((((local_8 == (void *)0x0) ||
         ((uint *)(*(int *)((int)pvVar1 + 0x14) + (int)pvVar3) != (uint *)((int)local_8 + 0x1c8)))
        || ((*(uint *)((int)pvVar1 + 0x1c) & 0x800000) == 0)) ||
       ((*(uint *)((int)local_8 + 0x1c8) & 0x800000) == 0)) {
      return 0;
    }
    message = s_cm_ChkChangeBits___Invalid_actio_1002ca04;
    iVar2 = 0x2533;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar2,message,1);
  return 1;
}



undefined4 cm_ChkSetGebBesitzer(int param_1)

{
  int iVar1;
  
  iVar1 = gm_FindObject(1,1,*(undefined4 *)(param_1 + 0x10));
  if ((iVar1 != 0) && ((*(byte *)(iVar1 + 0x5a) & 2) != 0)) {
    return 0;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x256b,
             s_cm_ChkSetGebBesitzer___Invalid_I_1002ca74,1);
  return 1;
}



bool is_amt_valid(int param_1)

{
  int iVar1;
  
  iVar1 = validate_amt((void *)(param_1 + 0x10));
  return iVar1 == 0;
}



bool is_amt_action_valid(int param_1)

{
  int iVar1;
  
  iVar1 = handleValidateAmtAction((void *)(param_1 + 0x10));
  return iVar1 == 0;
}



// Setting prototype: bool can_buy_item(void *item_data)

bool cm_CanBuyItem(void *item_data)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  
                    // 
                    // Checks if a specific item can be bought.
                    // 
                    // Parameters:
                    //   item_data: Pointer to the item's data structure.
                    // 
                    // Return values:
                    //   True if the item can be bought, false otherwise.
                    // 
  if (*(int *)((int)item_data + 0x10) == 0x636c6572) {
    iVar1 = gm_FindObject(1,1,*(undefined4 *)((int)item_data + 0x18));
    if (iVar1 != 0) {
      iVar1 = handleFindObjectInList(*(undefined4 *)(iVar1 + 0x5d),2,6,0,300);
      if (iVar1 != 0) {
        return DAT_10035880 - *(int *)(iVar1 + 0x28) < 2;
      }
    }
  }
  else if (*(int *)((int)item_data + 0x10) == 0x62757920) {
    iVar1 = gm_FindObject(1,1,*(undefined4 *)((int)item_data + 0x18));
    if (iVar1 != 0) {
      iVar1 = handleFindObjectInList(*(undefined4 *)(iVar1 + 0x5d),2,6,0,300);
      if (iVar1 != 0) {
        iVar3 = 0;
        piVar2 = (int *)(iVar1 + 0x1c);
        do {
          if (*piVar2 == *(int *)((int)item_data + 0x1c)) {
            return false;
          }
          iVar3 = iVar3 + 1;
          piVar2 = piVar2 + 1;
        } while (iVar3 < 3);
      }
    }
  }
  return true;
}



// Setting prototype: bool can_join_game(void *player_data)

bool cm_ValidateLobbyAction(void *player_data)

{
  ushort uVar1;
  int iVar2;
  int *piVar3;
  int *piVar4;
  int iVar5;
  
                    // 
                    // Checks if a player can join a game.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   True if the player can join, false otherwise.
                    // 
  iVar2 = *(int *)((int)player_data + 0x10);
  if (iVar2 == 0x6a6f696e) {
    iVar2 = gm_FindObject(1,1,*(undefined4 *)((int)player_data + 0x18));
    if ((iVar2 != 0) &&
       (iVar2 = handleFindObjectInList(*(undefined4 *)(iVar2 + 0x5d),2,6,0,0x12d), iVar2 != 0)) {
      piVar4 = (int *)(iVar2 + 0x1c);
      iVar2 = 0;
      piVar3 = piVar4;
      do {
        if (*piVar3 == *(int *)((int)player_data + 0x14)) {
          return true;
        }
        iVar2 = iVar2 + 1;
        piVar3 = piVar3 + 1;
      } while (iVar2 < 4);
      iVar2 = 0;
      do {
        if (*piVar4 == -1) {
          if (3 < iVar2) {
            return true;
          }
          return false;
        }
        iVar2 = iVar2 + 1;
        piVar4 = piVar4 + 1;
      } while (iVar2 < 4);
    }
  }
  else if (iVar2 == 0x6c656176) {
    iVar2 = gm_FindObject(1,1,*(undefined4 *)((int)player_data + 0x18));
    if ((iVar2 != 0) &&
       (iVar2 = handleFindObjectInList(*(undefined4 *)(iVar2 + 0x5d),2,6,0,0x12d), iVar2 != 0)) {
      iVar5 = 0;
      piVar4 = (int *)(iVar2 + 0x1c);
      while (*piVar4 != *(int *)((int)player_data + 0x14)) {
        iVar5 = iVar5 + 1;
        piVar4 = piVar4 + 1;
        if (3 < iVar5) {
          return true;
        }
      }
      if (iVar5 < 4) {
        return false;
      }
    }
  }
  else if ((iVar2 == 0x636c6572) &&
          (iVar2 = gm_FindObject(1,1,*(undefined4 *)((int)player_data + 0x18)), iVar2 != 0)) {
    uVar1 = *(ushort *)(iVar2 + 0x27);
    if (uVar1 != 0xffff) {
      iVar5 = (uint)uVar1 * 0x21c;
      if ((((iVar5 != -0x100358a0) && (&DAT_100358a0 + (uint)uVar1 * 0x10e != DAT_1003546c)) &&
          ((&DAT_100358a8)[iVar5] != '\0')) && ((&DAT_100358a2)[iVar5] != '\x0f')) {
        return true;
      }
    }
    iVar2 = handleFindObjectInList(*(undefined4 *)(iVar2 + 0x5d),2,6,0,0x12d);
    return (bool)('\x01' - (iVar2 != 0));
  }
  return true;
}



// Setting prototype: int is_cutscene_ready(void *cutscene_data)

int cm_IsCutsceneReady(void *cutscene_data)

{
  int iVar1;
  undefined4 *puVar2;
  int iVar3;
  
                    // 
                    // Checks if a cutscene is ready to be played.
                    // 
                    // Parameters:
                    //   cutscene_data: Pointer to the cutscene's data structure.
                    // 
                    // Return values:
                    //   1 if the cutscene is ready, 0 otherwise.
                    // 
  if (*(int *)((int)cutscene_data + 0x10) == -1) {
    return 1;
  }
  iVar3 = 0;
  puVar2 = (undefined4 *)((int)cutscene_data + 0x14);
  while( true ) {
    iVar1 = handleGetPlayerById(*puVar2);
    if (((iVar1 != 0) &&
        (((*(char *)(iVar1 + 2) == '\x06' || (*(char *)(iVar1 + 2) == '\a')) &&
         (*(int *)(iVar1 + 0x20c) != -1)))) &&
       (*(int *)(iVar1 + 0x20c) != *(int *)((int)cutscene_data + 0x10))) break;
    iVar3 = iVar3 + 1;
    puVar2 = puVar2 + 1;
    if (0xf < iVar3) {
      return 0;
    }
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x26db,
             s_cm_ChkCutsceneReady____failed____1002caa8,1);
  return 1;
}



undefined4 handle_invalid_command(char *param_1,undefined1 *param_2)

{
  char cVar1;
  
  cVar1 = *param_1;
  if ((((cVar1 != '\0') && (cVar1 != '\x05')) && (cVar1 != '\x06')) && (cVar1 != '\a')) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x270b,
               s_Invalid_Commandtype_in_Execution_1002cacc,1);
    crt_startup_3(s_Invalid_Commandtype_in_Execution_1002cacc);
    return 1;
  }
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



undefined4 cm_Stub(undefined4 param_1,undefined1 *param_2)

{
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



undefined4 cm_NotYetImplemented(void)

{
  return 1;
}



undefined4 cmdt_AllocBuilding(void *param_1,undefined1 *param_2)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  char *message;
  
  *(undefined4 *)((int)param_1 + 0x10) = DAT_10030b6c;
  if (*(int *)((int)param_1 + 0x16) == -1) {
    uVar3 = 0xffff;
LAB_1000d36b:
    iVar1 = gm_AllocBuilding(*(undefined1 *)((int)param_1 + 0x14),uVar3);
    if (iVar1 != 0) {
      *(undefined4 *)(&DAT_10442d04 + (uint)*(byte *)((int)param_1 + 3) * 0x264264) =
           *(undefined4 *)(iVar1 + 1);
      *(undefined2 *)(iVar1 + 0x5a) = *(undefined2 *)((int)param_1 + 0x1a);
      if (*(int *)((int)param_1 + 0x1c) != 0) {
        puVar4 = (undefined4 *)((int)param_1 + 0x20);
        puVar5 = (undefined4 *)(iVar1 + 0x65);
        for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {
          *puVar5 = *puVar4;
          puVar4 = puVar4 + 1;
          puVar5 = puVar5 + 1;
        }
      }
      if (param_2 != (undefined1 *)0x0) {
        *param_2 = 1;
        param_2[1] = 2;
        *(int *)(param_2 + 6) = iVar1;
      }
      return 0;
    }
    message = s_gm_AllocGebaeude___failed_1002cb34;
    iVar1 = 0x2817;
  }
  else {
    iVar1 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x16));
    *(int *)((int)param_1 + 0x16) = iVar1;
    uVar3 = 0;
    do {
      if (((&DAT_100358a0)[(uVar3 & 0xffff) * 0x10e] != -1) &&
         ((&DAT_100358a4)[(uVar3 & 0xffff) * 0x87] == iVar1)) {
        if ((ushort)uVar3 < 0x300) goto LAB_1000d36b;
        message = s_Invalid__eigentuemer_id__for_cmd_1002caf0;
        iVar1 = 0x280b;
        goto LAB_1000d38c;
      }
      uVar3 = uVar3 + 1;
    } while ((ushort)uVar3 < 0x300);
    message = s_Invalid__eigentuemer_id__for_cmd_1002caf0;
    iVar1 = 0x280b;
  }
LAB_1000d38c:
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar1,message,1);
  return 1;
}



undefined4 cmdt_AllocPlayer(void *param_1,undefined1 *param_2)

{
  uint16_t uVar1;
  uint32_t seed;
  void *building_data;
  int iVar3;
  uint uVar2;
  
  *(undefined4 *)((int)param_1 + 0x10) = DAT_10030b6c;
  seed = _rand();
  *(uint32_t *)((int)param_1 + 0x26) = seed;
  seed_random(seed);
  if (*(int *)((int)param_1 + 0x1f) == -1) {
    building_data = (void *)0x0;
  }
  else {
    iVar3 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x1f));
    *(int *)((int)param_1 + 0x1f) = iVar3;
    building_data = (void *)gm_FindObject(1,1,iVar3);
    if (building_data == (void *)0x0) {
      logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2889,
                 s_Invalid__GI_Id__for_cmdt_ALLOC_S_1002cb50,1);
      return 1;
    }
  }
  uVar1 = gm_AllocPlayer((uint)*(byte *)((int)param_1 + 0x14),*(uint32_t *)((int)param_1 + 0x15),
                         *(uint32_t *)((int)param_1 + 0x19),
                         (void *)(uint)*(ushort *)((int)param_1 + 0x1d),building_data,
                         *(uint8_t *)((int)param_1 + 0x23),(uint)*(byte *)((int)param_1 + 0x24),
                         (uint)*(byte *)((int)param_1 + 0x25));
  uVar2 = (uint)uVar1;
  if (uVar2 == 0xffff) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2897,
               s_cm_ExAllocSpieler___gm_AllocSpie_1002cb8c,1);
    return 1;
  }
  *(undefined4 *)(&DAT_10442d00 + (uint)*(byte *)((int)param_1 + 3) * 0x264264) =
       (&DAT_100358a4)[uVar2 * 0x87];
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
    param_2[1] = 1;
    *(undefined2 **)(param_2 + 6) = &DAT_100358a0 + uVar2 * 0x10e;
  }
  return 0;
}



undefined4 cmdt_AllocClientPlayer(int param_1,undefined1 *param_2)

{
  char *source;
  uint16_t uVar1;
  int iVar2;
  undefined2 *puVar3;
  int iVar4;
  uint uVar5;
  
  *(undefined4 *)(param_1 + 0x10) = DAT_10030b6c;
  iVar2 = _rand();
  *(int *)(param_1 + 0x45) = iVar2;
  seed_random(*(uint32_t *)(param_1 + 0x22));
  uVar1 = gm_AllocPlayer(7 - (param_2 != (undefined1 *)0x0),*(uint32_t *)(param_1 + 0x14),
                         *(uint32_t *)(param_1 + 0x18),(void *)(uint)*(ushort *)(param_1 + 0x1c),
                         (void *)0x0,*(uint8_t *)(param_1 + 0x1e),0,(uint)*(byte *)(param_1 + 0x23))
  ;
  uVar5 = (uint)uVar1;
  if (uVar5 != 0xffff) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2917,s_ClientSpieler_erzeugt_1002cbbc,1
              );
    iVar2 = uVar5 * 0x21c;
    *(undefined4 *)(&DAT_10442d00 + (uint)*(byte *)(param_1 + 3) * 0x264264) =
         (&DAT_100358a4)[uVar5 * 0x87];
    _strncpy(&DAT_100358d0 + iVar2,(char *)(param_1 + 0x25),0x10);
    puVar3 = (undefined2 *)gm_GetPlayerResidence(&DAT_100358a0 + uVar5 * 0x10e);
    if (puVar3 != (undefined2 *)0x0) {
      source = (char *)(param_1 + 0x35);
      *puVar3 = *(undefined2 *)(&DAT_100358f0 + iVar2);
      _strncpy((char *)(puVar3 + 1),source,0x10);
      _strncpy(&DAT_100358e0 + iVar2,source,0x10);
      iVar4 = handleGetPlayerById((&DAT_10035900)[uVar5 * 0x87]);
      if (iVar4 != 0) {
        _strncpy((char *)(iVar4 + 0x40),source,0x10);
      }
    }
    *(undefined4 *)(&DAT_100358f4 + iVar2) = *(undefined4 *)(param_1 + 0x1f);
    (&DAT_100358ac)[iVar2] = *(undefined1 *)(param_1 + 0x24);
    if (param_2 != (undefined1 *)0x0) {
      *param_2 = 1;
      param_2[1] = 1;
      *(undefined2 **)(param_2 + 6) = &DAT_100358a0 + uVar5 * 0x10e;
    }
    return 0;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x290f,s_gm_AllocSpieler___failed_1002cbd4,
             1);
  return 1;
}



undefined4 cmdt_ChangePlayerIdentity(int param_1)

{
  uint32_t uVar1;
  
  uVar1 = gm_ChangePlayerIdentity(*(uint32_t *)(param_1 + 0x10),*(uint32_t *)(param_1 + 0x14));
  if (-1 < (int)uVar1) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x299d,
               s_cm_ExChangePlayerIdentity___exec_1002cc14,1);
    return 0;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x29a1,
             s_cm_ExChangePlayerIdentity___fail_1002cbf0,1);
  return 0;
}



undefined4 cmdt_Free(void *param_1,undefined1 *param_2)

{
  void *pvVar1;
  uint uVar2;
  int iVar3;
  char *message;
  void *local_8;
  ushort *local_4;
  
  pvVar1 = param_1;
  uVar2 = gm_GetPlayerConnection(param_1,(uint)*(ushort *)((int)param_1 + 0x10));
  *(short *)((int)pvVar1 + 0x10) = (short)uVar2;
  iVar3 = gm_LoadGameData(&param_1,&local_8,&local_4,uVar2 & 0xffff);
  if (iVar3 == 0) {
    message = s_Invalid_Id_for_cmdt_FREE_in_cm_E_1002cc5c;
    iVar3 = 0x2a09;
LAB_1000d7ab:
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar3,message,1);
    return 1;
  }
  if (param_1 == (void *)0x0) {
    if (local_8 != (void *)0x0) {
      message = s_cm_ExFree____Can_t_free_Objects_1002cc3c;
      iVar3 = 0x2a21;
      goto LAB_1000d7ab;
    }
    gm_KillSpieler((uint)*local_4,1);
  }
  else {
    iVar3 = gm_FreeBuilding(param_1);
    if (iVar3 != 0) {
      return 1;
    }
  }
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



undefined4 cmdt_SellObject(void *param_1,undefined1 *param_2)

{
  uint32_t parent_id;
  int iVar1;
  
  *(undefined4 *)((int)param_1 + 0x18) = DAT_10030b6c;
  if (*(int *)((int)param_1 + 0x14) != -1) {
    parent_id = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x14));
    *(uint32_t *)((int)param_1 + 0x14) = parent_id;
    iVar1 = gm_RemoveObject(parent_id,
                            (uint)*(ushort *)
                                   (&DAT_100a8c94 + (uint)*(byte *)((int)param_1 + 0x1c) * 0x2f4),
                            *(int *)((int)param_1 + 0x1d));
    if (iVar1 == 0) {
      return 1;
    }
  }
  if (*(int *)((int)param_1 + 0x10) != -1) {
    iVar1 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
    *(int *)((int)param_1 + 0x10) = iVar1;
    iVar1 = gm_AddObject(iVar1,*(undefined2 *)
                                (&DAT_100a8c94 + (uint)*(byte *)((int)param_1 + 0x1c) * 0x2f4),
                         *(undefined4 *)((int)param_1 + 0x1d));
    if (iVar1 == 0) {
      return 1;
    }
  }
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



undefined4 cmdt_MoveObject(void *param_1,undefined1 *param_2)

{
  uint32_t parent_id;
  int iVar1;
  
  *(undefined4 *)((int)param_1 + 0x18) = DAT_10030b6c;
  if (*(int *)((int)param_1 + 0x14) != -1) {
    parent_id = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x14));
    *(uint32_t *)((int)param_1 + 0x14) = parent_id;
    gm_RemoveObjectNoKill
              (parent_id,
               (uint)*(ushort *)(&DAT_100a8c94 + (uint)*(byte *)((int)param_1 + 0x1c) * 0x2f4),
               *(int *)((int)param_1 + 0x1d));
  }
  if (*(int *)((int)param_1 + 0x10) != -1) {
    iVar1 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
    *(int *)((int)param_1 + 0x10) = iVar1;
    gm_AddObject(iVar1,*(undefined2 *)(&DAT_100a8c94 + (uint)*(byte *)((int)param_1 + 0x1c) * 0x2f4)
                 ,*(undefined4 *)((int)param_1 + 0x1d));
  }
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



undefined4 cmdt_SellObjectEx(void *param_1,undefined1 *param_2)

{
  char cVar1;
  short sVar2;
  uint32_t uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  undefined2 *puVar7;
  int extraout_ECX;
  void *object_data;
  short *psVar8;
  undefined2 *puVar9;
  char *pcVar10;
  undefined2 *local_228;
  short *local_224;
  short *local_220;
  void *local_21c;
  short *local_218;
  undefined2 *local_214;
  short *local_210;
  int local_20c;
  void *local_208;
  uint local_204;
  CHAR local_200 [512];
  
  puVar9 = (undefined2 *)0x0;
  *(undefined4 *)((int)param_1 + 0x1a) = DAT_10030b6c;
  object_data = (void *)0x0;
  local_228 = (undefined2 *)0x0;
  local_224 = (short *)0x0;
  local_20c = 0;
  local_220 = (short *)0x0;
  local_218 = (short *)0x0;
  local_210 = (short *)0x0;
  local_208 = (void *)0x0;
  local_21c = (void *)0x0;
  local_214 = (undefined2 *)0x0;
  if (*(int *)((int)param_1 + 0x14) != -1) {
    uVar3 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x14));
    *(uint32_t *)((int)param_1 + 0x14) = uVar3;
    iVar4 = gm_LoadGameData(&local_208,&local_224,&local_214,uVar3);
    if (iVar4 == 0) {
      pcVar10 = s_cm_ExSellObjekt___Invalid__quell_1002cec4;
      iVar4 = 0x2c05;
      goto LAB_1000e00e;
    }
    if (local_208 == (void *)0x0) {
      if (local_224 == (short *)0x0) {
        psVar8 = local_214 + 0xbc;
        puVar9 = local_214;
        local_210 = psVar8;
      }
      else {
        sVar2 = *local_224;
        if ((((sVar2 == 0x2a) || (sVar2 == 0x1db)) || (sVar2 == 0x1dc)) ||
           ((sVar2 == 0x116 || (sVar2 == 0x1dd)))) {
          local_220 = local_224;
        }
        psVar8 = local_224 + 10;
        local_210 = psVar8;
        puVar9 = (undefined2 *)gm_GetPlayerSpouse(local_224);
        if (puVar9 == (undefined2 *)0x0) {
          pcVar10 = s_cm_ExSellObjekt___Invalid__gm_ev_1002ce90;
          iVar4 = 0x2c2f;
          goto LAB_1000e00e;
        }
      }
    }
    else {
      psVar8 = (short *)((int)local_208 + 0x5d);
      local_210 = psVar8;
      if (*(ushort *)((int)local_208 + 0x27) == 0xffff) {
        puVar9 = (undefined2 *)0x0;
      }
      else {
        puVar9 = &DAT_100358a0 + (uint)*(ushort *)((int)local_208 + 0x27) * 0x10e;
      }
    }
    object_data = (void *)handleFindObjectInList
                                    (*(undefined4 *)psVar8,1,0,*(undefined2 *)((int)param_1 + 0x18))
    ;
    if (object_data == (void *)0x0) {
      printf_wrapper(local_200,s_cm_ExSellObjekt____Object_not_fo_1002ce4c,
                     (uint)*(ushort *)((int)param_1 + 0x18),*(undefined4 *)((int)param_1 + 0x1f),
                     *(undefined4 *)((int)param_1 + 8));
      logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2c53,local_200,8);
      return 1;
    }
    if (local_220 != (short *)0x0) {
      iVar4 = *(int *)((int)param_1 + 0x1f);
      iVar5 = gm_GetBuildingItemCount(local_220,object_data);
      if (iVar5 < iVar4) {
        printf_wrapper(local_200,s_cm_ExSellObjekt___Not_enough_Obj_1002cdfc,
                       (uint)*(ushort *)((int)param_1 + 0x18),iVar4,
                       *(undefined4 *)((int)param_1 + 8));
        logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2c75,local_200,8);
        return 1;
      }
    }
    iVar4 = *(int *)((int)param_1 + 0x1f);
    if (*(int *)((int)object_data + 0xe) < iVar4) {
      printf_wrapper(local_200,s_cm_ExSellObjekt___Not_enough_Obj_1002cdfc,
                     (uint)*(ushort *)((int)param_1 + 0x18),iVar4,*(undefined4 *)((int)param_1 + 8))
      ;
      logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2c97,local_200,8);
      return 1;
    }
    if ((*(int *)((int)param_1 + 0x23) != 0) && (puVar9 != (undefined2 *)0x0)) {
      get_building_item_count
                (*(uint32_t *)(puVar9 + 0xbc),
                 CONCAT31((int3)((uint)iVar4 >> 8),*(undefined1 *)((int)param_1 + 0x1e)));
    }
  }
  if (*(int *)((int)param_1 + 0x10) != -1) {
    uVar3 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
    *(uint32_t *)((int)param_1 + 0x10) = uVar3;
    iVar4 = gm_LoadGameData(&local_21c,&local_224,&local_214,uVar3);
    if (iVar4 == 0) {
      pcVar10 = s_cm_ExSellObjekt___Invalid__ziel__1002cdcc;
      iVar4 = 0x2cdd;
      goto LAB_1000e00e;
    }
    if (local_21c == (void *)0x0) {
      if (local_224 == (short *)0x0) {
        psVar8 = local_214 + 0xbc;
        local_228 = local_214;
      }
      else {
        sVar2 = *local_224;
        if ((((sVar2 == 0x2a) || (sVar2 == 0x1db)) || (sVar2 == 0x1dc)) || (sVar2 == 0x116)) {
          local_218 = local_224;
LAB_1000dc24:
          iVar4 = gm_IsBuildingInventoryFull
                            (local_224,(uint)*(ushort *)((int)param_1 + 0x18),
                             *(int *)((int)param_1 + 0x1f));
          if (iVar4 < *(int *)((int)param_1 + 0x1f)) {
            pcVar10 = s_cm_ExSellObjekt___Lager_voll_1002cdac;
            iVar4 = 0x2d1b;
            goto LAB_1000e00e;
          }
        }
        else if (sVar2 == 0x1dd) goto LAB_1000dc24;
        psVar8 = local_224 + 10;
        local_228 = (undefined2 *)gm_GetPlayerSpouse(local_224);
      }
    }
    else {
      psVar8 = (short *)((int)local_21c + 0x5d);
      if (*(ushort *)((int)local_21c + 0x27) == 0xffff) {
        local_228 = (undefined2 *)0x0;
      }
      else {
        local_228 = &DAT_100358a0 + (uint)*(ushort *)((int)local_21c + 0x27) * 0x10e;
      }
    }
    uVar6 = (uint)*(ushort *)((int)param_1 + 0x18);
    iVar4 = uVar6 * 0x40;
    if (*(char *)(DAT_101de450 + uVar6 * 0x41) == '\x1d') {
      local_20c = 0;
    }
    else {
      local_20c = handleFindObjectInList(*(undefined4 *)psVar8,1,0,uVar6);
      iVar4 = extraout_ECX;
    }
    if (((*(int *)((int)param_1 + 0x23) != 0) && (local_228 != (undefined2 *)0x0)) &&
       (iVar4 = get_building_item_count
                          (*(uint32_t *)(local_228 + 0xbc),
                           CONCAT31((int3)((uint)iVar4 >> 8),*(undefined1 *)((int)param_1 + 0x1e))),
       iVar4 < *(int *)((int)param_1 + 0x1f) * *(int *)((int)param_1 + 0x23))) {
      pcVar10 = s_cm_ExSellObjekt___Not_enough_Cre_1002cd78;
      iVar4 = 0x2d4f;
      goto LAB_1000e00e;
    }
  }
  psVar8 = local_220;
  if (local_220 == (short *)0x0) {
LAB_1000dd58:
    if ((((local_228 != (undefined2 *)0x0) && (local_21c == (void *)0x0)) &&
        (local_218 == (short *)0x0)) && (local_224 == (short *)0x0)) {
      uVar3 = add_item_to_building_inventory
                        (local_228,(uint)*(ushort *)((int)param_1 + 0x18),
                         *(uint32_t *)((int)param_1 + 0x1f));
      *(uint32_t *)((int)param_1 + 0x1f) = uVar3;
      if (uVar3 == 0) {
        return 1;
      }
    }
  }
  else if (local_228 != (undefined2 *)0x0) {
    puVar7 = (undefined2 *)gm_GetPlayerSpouse(object_data);
    if ((puVar7 != local_228) && (*(int *)((int)object_data + 0x1c) != 0)) {
      iVar4 = get_building_inventory_size(psVar8);
      local_204 = (uint)(iVar4 * *(int *)((int)object_data + 0x1c)) >> 2;
      iVar4 = gm_GetBuildingItemCount(psVar8,object_data);
      psVar8 = local_220;
      if (iVar4 - local_204 < *(uint *)((int)param_1 + 0x1f)) {
        pcVar10 = s_cm_ExSellObjekt___Verkaufslimit_b_1002cd48;
        iVar4 = 0x2d79;
        goto LAB_1000e00e;
      }
    }
    goto LAB_1000dd58;
  }
  if (*(int *)((int)param_1 + 0x23) != 0) {
    if (((local_218 == (short *)0x0) && (local_224 != (short *)0x0)) &&
       ((*local_224 == 0x1dd &&
        (iVar4 = gm_GetObjectFromList(DAT_10035439,*(undefined2 *)((int)param_1 + 0x18)), iVar4 != 0
        )))) {
      *(int *)(iVar4 + 0x18) = *(int *)(iVar4 + 0x18) + *(int *)((int)param_1 + 0x1f);
    }
    if (((psVar8 != (short *)0x0) && (*psVar8 == 0x1dd)) &&
       (iVar4 = gm_GetObjectFromList(DAT_10035439,*(undefined2 *)((int)param_1 + 0x18)), iVar4 != 0)
       ) {
      *(int *)(iVar4 + 0x1c) = *(int *)(iVar4 + 0x1c) + *(int *)((int)param_1 + 0x1f);
    }
  }
  if (*(int *)((int)param_1 + 0x14) != -1) {
    iVar4 = *(int *)((int)object_data + 0xe) - *(int *)((int)param_1 + 0x1f);
    *(int *)((int)object_data + 0xe) = iVar4;
    if (iVar4 < 1) {
      uVar6 = (uint)*(ushort *)((int)param_1 + 0x18);
      cVar1 = *(char *)(DAT_101de450 + uVar6 * 0x41);
      if ((cVar1 == '\x02') || (cVar1 == '\x06')) {
        if (local_208 == (void *)0x0) {
          pcVar10 = s_cm_ExSellObjekt____Quell_Besitze_1002cd14;
          iVar4 = 0x2def;
          goto LAB_1000e00e;
        }
        handleRemoveObjectFromList4(local_208,uVar6);
      }
      else {
        handleRemoveObjectFromList(local_210,uVar6);
      }
    }
    if (*(int *)((int)param_1 + 0x23) != 0) {
      gm_AddObject(*(undefined4 *)(puVar9 + 2),
                   *(undefined2 *)(&DAT_100a8c94 + (uint)*(byte *)((int)param_1 + 0x1e) * 0x2f4),
                   *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f));
      if (psVar8 == (short *)0x0) {
LAB_1000def2:
        *(int *)(puVar9 + 0xce) =
             *(int *)(puVar9 + 0xce) + *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f)
        ;
      }
      else if (*psVar8 == 0x1db) {
        *(int *)(puVar9 + 0xd2) =
             *(int *)(puVar9 + 0xd2) + *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f)
        ;
      }
      else {
        if (*psVar8 != 0x1dc) goto LAB_1000def2;
        *(int *)(puVar9 + 0xd0) =
             *(int *)(puVar9 + 0xd0) + *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f)
        ;
      }
    }
  }
  iVar4 = local_20c;
  if (*(int *)((int)param_1 + 0x10) != -1) {
    if (local_20c == 0) {
      uVar6 = (uint)*(ushort *)((int)param_1 + 0x18);
      cVar1 = *(char *)(DAT_101de450 + uVar6 * 0x41);
      if ((cVar1 == '\x02') || (cVar1 == '\x06')) {
        if (local_21c == (void *)0x0) {
          pcVar10 = s_cm_ExSellObjekt____Ziel_Besitzer_1002cc8c;
          iVar4 = 0x2e45;
LAB_1000e00e:
          logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar4,pcVar10,8);
          return 1;
        }
        iVar4 = gm_AllocRoom(local_21c,uVar6);
        if (iVar4 == 0) {
          pcVar10 = s_cm_ExSellObjekt____gm_AllocRaum_f_1002ccc0;
          iVar4 = 0x2e39;
          goto LAB_1000e00e;
        }
      }
      else {
        iVar4 = gm_AllocObject(*(int *)((int)param_1 + 0x10),uVar6,
                               *(undefined4 *)((int)param_1 + 0x1f));
        if (iVar4 == 0) {
          pcVar10 = s_cm_ExSellObjekt____gm_AllocObjek_1002cce8;
          iVar4 = 0x2e5d;
          goto LAB_1000e00e;
        }
        if (local_218 != (short *)0x0) {
          pcVar10 = (char *)(DAT_101de450 + (uint)*(ushort *)((int)param_1 + 0x18) * 0x41);
          *(int *)(iVar4 + 0xe) = *(int *)(iVar4 + 0xe) + 1;
          cVar1 = *pcVar10;
          if (((((cVar1 == '\x17') || (cVar1 == '%')) &&
               ((*local_218 == 0x2a || (*local_218 == 0x116)))) && (local_228 != (undefined2 *)0x0))
             && ((*(char *)(local_228 + 1) == '\x06' || (*(char *)(local_228 + 1) == '\a')))) {
            *(undefined4 *)(iVar4 + 0x1c) = 4;
          }
        }
      }
    }
    else {
      *(int *)(local_20c + 0xe) = *(int *)(local_20c + 0xe) + *(int *)((int)param_1 + 0x1f);
    }
    *(undefined4 *)(&DAT_10442d08 + (uint)*(byte *)((int)param_1 + 3) * 0x264264) =
         *(undefined4 *)(iVar4 + 2);
    if ((*(int *)((int)param_1 + 0x23) != 0) && (local_228 != (undefined2 *)0x0)) {
      gm_RemoveObject(*(uint32_t *)(local_228 + 2),
                      (uint)*(ushort *)
                             (&DAT_100a8c94 + (uint)*(byte *)((int)param_1 + 0x1e) * 0x2f4),
                      *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f));
      if (local_218 != (short *)0x0) {
        if (*local_218 == 0x1db) {
          *(int *)(local_228 + 0xd0) =
               *(int *)(local_228 + 0xd0) +
               *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f);
          goto LAB_1000e0e7;
        }
        if (*local_218 == 0x1dc) {
          *(int *)(local_228 + 0xd2) =
               *(int *)(local_228 + 0xd2) +
               *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f);
          goto LAB_1000e0e7;
        }
      }
      *(int *)(local_228 + 0xcc) =
           *(int *)(local_228 + 0xcc) +
           *(int *)((int)param_1 + 0x23) * *(int *)((int)param_1 + 0x1f);
    }
  }
LAB_1000e0e7:
  if ((param_2 != (undefined1 *)0x0) && (*param_2 = 1, *(int *)((int)param_1 + 0x10) != -1)) {
    param_2[1] = 3;
    *(int *)(param_2 + 6) = iVar4;
  }
  return 0;
}



undefined4 cmdt_ProduceObject(void *param_1,undefined1 *param_2)

{
  uint32_t id;
  int iVar1;
  void *object_data;
  int iVar2;
  int iVar3;
  int iVar4;
  int32_t iVar5;
  ushort *puVar6;
  char *pcVar7;
  short *local_10;
  char *local_c;
  int local_8;
  int local_4;
  
  *(undefined4 *)((int)param_1 + 0x1a) = DAT_10030b6c;
  id = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
  *(uint32_t *)((int)param_1 + 0x10) = id;
  iVar1 = gm_LoadGameData((void **)0x0,&local_10,(void **)0x0,id);
  if (iVar1 == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2f3b,
               s_cm_ExProdObjekt___Invalid__lager_1002cf9c,1);
    return 1;
  }
  if ((*local_10 != 0x2a) && (*local_10 != 0x116)) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2f53,
               s_cm_ExProdObjekt___Lager_has_wron_1002cf74,1);
    return 1;
  }
  local_4 = gm_GetPlayerSpouse(local_10);
  if (local_4 == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x2f6d,
               s_cm_ExProdObjekt___Lager_hat_kein_1002cf48,1);
    return 1;
  }
  iVar1 = *(int *)((int)param_1 + 0x16);
  local_c = (char *)(DAT_101de450 + (uint)*(ushort *)((int)param_1 + 0x14) * 0x41);
  local_8 = 4;
  puVar6 = (ushort *)(local_c + 0x26);
  do {
    if (puVar6[4] != 0) {
      object_data = (void *)handleFindObjectInList(*(undefined4 *)(local_10 + 10),1,0,puVar6[4]);
      if (object_data == (void *)0x0) {
        iVar1 = 0;
      }
      else {
        iVar2 = gm_GetBuildingItemCount(local_10,object_data);
        if (iVar2 / (int)(uint)*puVar6 <= iVar1) {
          iVar1 = gm_GetBuildingItemCount(local_10,object_data);
          iVar1 = iVar1 / (int)(uint)*puVar6;
        }
      }
    }
    pcVar7 = local_c;
    puVar6 = puVar6 + 1;
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  local_8 = iVar1;
  iVar2 = gm_IsBuildingInventoryFull
                    (local_10,(uint)*(ushort *)((int)param_1 + 0x14),
                     (uint)*(ushort *)(local_c + 0x36) * iVar1);
  iVar2 = iVar2 / (int)(uint)*(ushort *)(pcVar7 + 0x36);
  if (iVar2 <= iVar1) {
    iVar1 = iVar2;
    local_8 = iVar2;
  }
  if (iVar1 == 0) {
    pcVar7 = s_cm_ExProdObjekt____Nicht_gen_gen_1002cf1c;
    iVar1 = 0x2fb5;
LAB_1000e3e1:
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar1,pcVar7,1);
    if (param_2 != (undefined1 *)0x0) {
      param_2[1] = 8;
    }
    return 1;
  }
  iVar2 = 0;
  puVar6 = (ushort *)(local_c + 0x2e);
  do {
    if (*puVar6 != 0) {
      iVar3 = handleFindObjectInList(*(undefined4 *)(local_10 + 10),1,0,*puVar6);
      if (iVar3 == 0) {
        pcVar7 = s_cm_ExProdObjekt___Rohstoff_versc_1002cef4;
        iVar1 = 0x2fdd;
        goto LAB_1000e3e1;
      }
      *(uint *)(iVar3 + 0xe) = *(int *)(iVar3 + 0xe) - (uint)puVar6[-4] * iVar1;
      iVar4 = gm_GetObjectFromList(DAT_10035439,*puVar6);
      if (iVar4 != 0) {
        *(uint *)(iVar4 + 0x14) = *(int *)(iVar4 + 0x14) + (uint)*(ushort *)(local_c + 0x36) * iVar1
        ;
      }
      if (*(int *)(iVar3 + 0xe) == 0) {
        handleRemoveObjectFromList(local_10 + 10,(uint)*puVar6);
      }
    }
    iVar2 = iVar2 + 1;
    puVar6 = puVar6 + 1;
    if (3 < iVar2) {
      iVar2 = handleFindObjectInList
                        (*(undefined4 *)(local_10 + 10),1,0,*(undefined2 *)((int)param_1 + 0x14));
      pcVar7 = local_c;
      if (iVar2 == 0) {
        iVar2 = gm_AllocObject(*(undefined4 *)(local_10 + 1),*(undefined2 *)((int)param_1 + 0x14),
                               (uint)*(ushort *)(local_c + 0x36) * iVar1);
        if (iVar2 == 0) {
          if (param_2 != (undefined1 *)0x0) {
            param_2[1] = 6;
          }
          return 1;
        }
        if (*local_10 == 0x2a) {
          *(int *)(iVar2 + 0xe) = *(int *)(iVar2 + 0xe) + 1;
        }
        if ((((*pcVar7 == '\x17') || (*pcVar7 == '%')) &&
            ((*local_10 == 0x2a || (*local_10 == 0x116)))) &&
           ((*(char *)(local_4 + 2) == '\x06' || (*(char *)(local_4 + 2) == '\a')))) {
          *(undefined4 *)(iVar2 + 0x1c) = 4;
        }
      }
      else {
        *(uint *)(iVar2 + 0xe) = *(int *)(iVar2 + 0xe) + (uint)*(ushort *)(local_c + 0x36) * iVar1;
      }
      gm_CalculateItemValue((uint)*(ushort *)((int)param_1 + 0x14),100);
      iVar5 = __ftol();
      iVar3 = gm_GetPlayerParent(local_10);
      if (iVar3 != 0) {
        *(int *)(iVar3 + 0x4d) = *(int *)(iVar3 + 0x4d) + iVar5;
      }
      iVar3 = gm_GetObjectFromList(DAT_10035439,*(undefined2 *)((int)param_1 + 0x14));
      if (iVar3 != 0) {
        *(uint *)(iVar3 + 0x10) = *(int *)(iVar3 + 0x10) + (uint)*(ushort *)(local_c + 0x36) * iVar1
        ;
      }
      iVar1 = gm_GetPlayerResidence(local_4);
      if (iVar1 != 0) {
        *(int *)(iVar1 + 0x24) = *(int *)(iVar1 + 0x24) + iVar5;
      }
      if ((param_2 != (undefined1 *)0x0) && (*param_2 = 1, *(int *)((int)param_1 + 0x10) != -1)) {
        param_2[1] = 3;
        *(int *)(param_2 + 6) = iVar2;
      }
      return 0;
    }
  } while( true );
}



undefined4 cm_ExMoveObject(void *param_1,undefined4 param_2,void *param_3,undefined1 *param_4)

{
  void *pvVar1;
  void *player_data;
  void *pvVar2;
  uint32_t uVar3;
  int iVar4;
  int *piVar5;
  int *piVar6;
  void *unaff_retaddr;
  char *message;
  int log_type;
  
  player_data = param_3;
  uVar3 = gm_GetPlayerConnection(param_3,*(int *)((int)param_3 + 0x14));
  *(uint32_t *)((int)player_data + 0x14) = uVar3;
  iVar4 = gm_LoadGameData((void **)&stack0x00000000,&param_3,&param_1,uVar3);
  if (iVar4 == 0) {
    log_type = 8;
    message = s_cm_ExMoveObjekt___Invalid__quell_1002d024;
    iVar4 = 0x30a1;
  }
  else {
    if (unaff_retaddr == (void *)0x0) {
      if (param_3 == (void *)0x0) {
        piVar5 = (int *)((int)param_1 + 0x178);
      }
      else {
        piVar5 = (int *)((int)param_3 + 0x14);
      }
    }
    else {
      piVar5 = (int *)((int)unaff_retaddr + 0x5d);
    }
    uVar3 = gm_GetPlayerConnection(player_data,*(int *)((int)player_data + 0x10));
    *(uint32_t *)((int)player_data + 0x10) = uVar3;
    iVar4 = gm_LoadGameData((void **)&stack0x00000000,&param_3,&param_1,uVar3);
    if (iVar4 == 0) {
      log_type = 1;
      message = s_cm_ExMoveObjekt___Invalid__ziel__1002cff4;
      iVar4 = 0x30bd;
    }
    else {
      if (unaff_retaddr == (void *)0x0) {
        if (param_3 == (void *)0x0) {
          piVar6 = (int *)((int)param_1 + 0x178);
        }
        else {
          piVar6 = (int *)((int)param_3 + 0x14);
        }
      }
      else {
        piVar6 = (int *)((int)unaff_retaddr + 0x5d);
      }
      iVar4 = gm_GetPlayerConnection(player_data,*(int *)((int)player_data + 0x18));
      *(int *)((int)player_data + 0x18) = iVar4;
      pvVar2 = (void *)*piVar5;
      pvVar1 = (void *)0x0;
      while (param_3 = pvVar2, param_3 != (void *)0x0) {
        if (*(int *)((int)param_3 + 2) == iVar4) {
          if (pvVar1 == (void *)0x0) {
            *piVar5 = *(int *)((int)param_3 + 0x3f);
          }
          else {
            *(undefined4 *)((int)pvVar1 + 0x3f) = *(undefined4 *)((int)param_3 + 0x3f);
          }
          if (param_3 != (void *)0x0) {
            *(undefined4 *)((int)param_3 + 6) = *(undefined4 *)((int)player_data + 0x10);
            *(int *)((int)param_3 + 0x3f) = *piVar6;
            *piVar6 = (int)param_3;
            if (param_4 != (undefined1 *)0x0) {
              *param_4 = 1;
            }
            return 0;
          }
          break;
        }
        pvVar1 = param_3;
        pvVar2 = *(void **)((int)param_3 + 0x3f);
      }
      log_type = 8;
      message = s_cm_ExMoveObjekt___Object_not_fou_1002cfc4;
      iVar4 = 0x30f9;
    }
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar4,message,log_type);
  return 1;
}



// Setting prototype: int clear_storage_slot(void *player_data, uint8_t *status_flag)

int cmdt_ClearStorageSlot(void *player_data,uint8_t *status_flag)

{
  void *pvVar1;
  uint32_t id;
  int iVar2;
  char *message;
  
                    // 
                    // Clears a storage slot for a player.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   status_flag: Pointer to a flag that will be set to 1 if successful.
                    // 
                    // Return values:
                    //   0 if successful, 1 otherwise.
                    // 
  pvVar1 = player_data;
  id = gm_GetPlayerConnection(player_data,*(int *)((int)player_data + 0x10));
  *(uint32_t *)((int)pvVar1 + 0x10) = id;
  iVar2 = gm_LoadGameData((void **)0x0,&player_data,(void **)0x0,id);
  if (iVar2 == 0) {
    message = s_cm_ExClearLagerslot___Invalid__L_1002d088;
    iVar2 = 0x314b;
  }
  else {
                    // WARNING: Load size is inaccurate
    if ((*player_data == 0x2a) || (*player_data == 0x116)) {
      iVar2 = handleFindObjectInList
                        (*(undefined4 *)((int)player_data + 0x14),1,0,
                         *(undefined2 *)((int)pvVar1 + 0x14));
      if (iVar2 == 0) {
        return 1;
      }
      if (*(int *)(iVar2 + 0xe) != 1) {
        return 1;
      }
      handleRemoveObjectFromList
                ((void *)((int)player_data + 0x14),(uint)*(ushort *)((int)pvVar1 + 0x14));
      if (status_flag != (uint8_t *)0x0) {
        *status_flag = '\x01';
      }
      return 0;
    }
    message = s_cm_ExClearLagerslot___Lager_has_n_1002d054;
    iVar2 = 0x3155;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar2,message,1);
  return 1;
}



// Setting prototype: int change_player_desire(void *player_data, uint8_t *status_flag)

int cmdt_ChangePlayerDesire(void *player_data,uint8_t *status_flag)

{
  undefined4 uVar1;
  void *pvVar2;
  uint32_t id;
  int iVar3;
  float *pfVar4;
  byte *pbVar5;
  uint uVar6;
  
                    // 
                    // Changes a player's desire level.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   status_flag: Pointer to a flag that will be set to 1 if successful.
                    // 
                    // Return values:
                    //   0 if successful, 1 otherwise.
                    // 
  pvVar2 = player_data;
  id = gm_GetPlayerConnection(player_data,*(int *)((int)player_data + 0x10));
  *(uint32_t *)((int)pvVar2 + 0x10) = id;
  iVar3 = gm_LoadGameData((void **)0x0,(void **)0x0,&player_data,id);
  if (iVar3 != 0) {
    uVar6 = 0;
    pbVar5 = (byte *)((int)pvVar2 + 0x15);
    if (*(char *)((int)pvVar2 + 0x14) != '\0') {
      do {
        pfVar4 = (float *)(pbVar5 + 1);
        iVar3 = ((uint)*pbVar5 * 3 + 0x24) * 4;
        pbVar5 = pbVar5 + 5;
        *(float *)(iVar3 + (int)player_data) = *pfVar4 + *(float *)(iVar3 + (int)player_data);
        if ((*(float *)(iVar3 + (int)player_data) < 0.0) ||
           (*(float *)(iVar3 + (int)player_data) < 1000.0)) {
          if (0.0 <= *(float *)(iVar3 + (int)player_data)) {
            uVar1 = *(undefined4 *)(iVar3 + (int)player_data);
          }
          else {
            uVar1 = 0;
          }
        }
        else {
          uVar1 = 0x447a0000;
        }
        *(undefined4 *)(iVar3 + (int)player_data) = uVar1;
        uVar6 = uVar6 + 1;
      } while (uVar6 < *(byte *)((int)pvVar2 + 0x14));
    }
    if (status_flag != (uint8_t *)0x0) {
      *status_flag = '\x01';
    }
    return 0;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x33af,
             s_cm_ExChangeDesire___Invalid_Id_1002d0f4,1);
  return 1;
}



undefined4 cm_ExchangeBits(void *param_1,undefined1 *param_2)

{
  void *pvVar1;
  uint32_t id;
  int iVar2;
  void *pvVar3;
  uint *puVar4;
  undefined4 uVar5;
  byte bVar6;
  uint uVar7;
  void *local_8;
  void *local_4;
  
  pvVar1 = param_1;
  id = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
  *(uint32_t *)((int)pvVar1 + 0x10) = id;
  iVar2 = gm_LoadGameData(&param_1,&local_8,&local_4,id);
  if (iVar2 == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x340d,
               s_cm_ExChangeBits___Invalid_Id_1002d114,1);
    return 1;
  }
  pvVar3 = param_1;
  if ((param_1 == (void *)0x0) && (pvVar3 = local_8, local_8 == (void *)0x0)) {
    pvVar3 = local_4;
  }
  puVar4 = (uint *)((int)pvVar3 + *(int *)((int)pvVar1 + 0x14));
  iVar2 = *(int *)((int)pvVar1 + 0x18);
  if (iVar2 == 1) {
    bVar6 = (byte)*puVar4 & ~*(byte *)((int)pvVar1 + 0x20);
    *(byte *)puVar4 = bVar6;
    *(byte *)puVar4 = *(byte *)((int)pvVar1 + 0x1c) | bVar6;
  }
  else {
    if (iVar2 == 2) {
      *(ushort *)puVar4 = (ushort)*puVar4 & ~*(ushort *)((int)pvVar1 + 0x20);
      *(ushort *)puVar4 = *(ushort *)((int)pvVar1 + 0x1c) | (ushort)*puVar4;
      uVar5 = cm_ExchangeBits_Success();
      return uVar5;
    }
    if (iVar2 == 4) {
      uVar7 = *puVar4 & ~*(uint *)((int)pvVar1 + 0x20);
      *puVar4 = uVar7;
      *puVar4 = *(uint *)((int)pvVar1 + 0x1c) | uVar7;
      uVar5 = cm_ExchangeBits_Success();
      return uVar5;
    }
  }
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



void cm_ExchangeBits_Helper1(void)

{
  ushort *in_EAX;
  int unaff_ESI;
  
  *in_EAX = *in_EAX & ~*(ushort *)(unaff_ESI + 0x20);
  *in_EAX = *(ushort *)(unaff_ESI + 0x1c) | *in_EAX;
  cm_ExchangeBits_Success();
  return;
}



undefined4 cm_ExchangeBits_Helper2(void)

{
  byte *in_EAX;
  byte bVar1;
  int unaff_ESI;
  undefined1 *in_stack_00000014;
  
  bVar1 = *in_EAX & ~*(byte *)(unaff_ESI + 0x20);
  *in_EAX = bVar1;
  *in_EAX = *(byte *)(unaff_ESI + 0x1c) | bVar1;
  if (in_stack_00000014 != (undefined1 *)0x0) {
    *in_stack_00000014 = 1;
  }
  return 0;
}



undefined4 cm_ExchangeBits_Success(void)

{
  undefined1 *in_stack_00000014;
  
  if (in_stack_00000014 != (undefined1 *)0x0) {
    *in_stack_00000014 = 1;
  }
  return 0;
}



undefined4 cm_ExchangeFloat(void *param_1,undefined1 *param_2)

{
  void *pvVar1;
  uint32_t id;
  int iVar2;
  void *local_8;
  void *local_4;
  
  pvVar1 = param_1;
  id = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x10));
  *(uint32_t *)((int)pvVar1 + 0x10) = id;
  iVar2 = gm_LoadGameData(&local_4,&local_8,&param_1,id);
  if (iVar2 == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x347f,
               s_cm_ExChangeFloat___Invalid_Id_1002d134,1);
    return 1;
  }
  if ((param_1 == (void *)0x0) && (param_1 = local_8, local_8 == (void *)0x0)) {
    param_1 = local_4;
  }
  *(float *)((int)param_1 + *(int *)((int)pvVar1 + 0x14)) =
       *(float *)((int)pvVar1 + 0x18) + *(float *)((int)param_1 + *(int *)((int)pvVar1 + 0x14));
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 1;
  }
  return 0;
}



// Setting prototype: int kill_player(void *player_data)

int cm_KillPlayer(void *player_data)

{
  ushort *puVar1;
  
                    // 
                    // Kills a player and performs cleanup.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   0 if successful.
                    // 
  puVar1 = (ushort *)handleGetPlayerById(*(undefined4 *)((int)player_data + 0x10));
  if (puVar1 != (ushort *)0x0) {
    gm_KillSpieler((uint)*puVar1,*(int *)((int)player_data + 0x14));
    return 0;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,0x397d,
             s_cm_ExKillSpieler___Could_not_fin_1002d154,1);
  return 0;
}



undefined4 cm_EmployWorker(int param_1,undefined1 *param_2)

{
  char cVar1;
  uint32_t seed;
  int iVar2;
  void *game_data;
  int iVar3;
  uint32_t *puVar4;
  void *citizen_data;
  char *message;
  
  citizen_data = (void *)0x0;
  *(undefined4 *)(param_1 + 0x1f) = DAT_10030b6c;
  seed = _rand();
  *(uint32_t *)(param_1 + 0x23) = seed;
  seed_random(seed);
  iVar2 = gm_FindObject(1,1,*(undefined4 *)(param_1 + 0x10));
  if (iVar2 == 0) {
    message = s_cm_ExEmployWorker____Illegal_geb_1002d33c;
    iVar2 = 0x4d3a;
LAB_1000f7a9:
    logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar2,message,1);
    return 1;
  }
  game_data = (void *)handleGetPlayerById(*(undefined4 *)(param_1 + 0x19));
  if (*(int *)(param_1 + 0x14) == -1) {
    if (game_data != (void *)0x0) {
      citizen_data = *(void **)((int)game_data + 0x170);
      goto LAB_1000f7ca;
    }
  }
  else {
    citizen_data = (void *)gm_FindObject(1,1,*(int *)(param_1 + 0x14));
    if (citizen_data == (void *)0x0) {
      message = s_cm_ExEmployWorker____Illegal_gw__1002d318;
      iVar2 = 0x4d50;
      goto LAB_1000f7a9;
    }
LAB_1000f7ca:
    if ((game_data != (void *)0x0) && (*(int *)((int)game_data + 0x16c) == 0)) goto LAB_1000f7f5;
  }
  game_data = (void *)handleCreateCitizen2
                                (6,*(undefined1 *)(param_1 + 0x18),0x12,
                                 *(undefined1 *)(param_1 + 0x1e),*(undefined1 *)(param_1 + 0x1d),
                                 citizen_data);
LAB_1000f7f5:
  if (game_data != (void *)0x0) {
    if (*(char *)(param_1 + 0x1d) != '\0') {
      *(char *)((int)game_data + 0x165) = *(char *)(param_1 + 0x1d);
    }
    if (*(char *)(param_1 + 0x1e) == '\0') {
      *(undefined1 *)((int)game_data + 0x164) = 0;
    }
    else {
      *(char *)((int)game_data + 0x164) = *(char *)(param_1 + 0x1e);
    }
    *(undefined1 *)((int)game_data + 2) = *(undefined1 *)(param_1 + 0x18);
    iVar3 = *(int *)((int)game_data + 0x184);
    if ((iVar3 == 0) && (citizen_data != (void *)0x0)) {
      handleRemoveCitizenFromBuilding(citizen_data);
    }
    cVar1 = *(char *)(param_1 + 0x1d);
    puVar4 = (uint32_t *)CONCAT31((int3)((uint)iVar3 >> 8),cVar1);
    if ((((cVar1 == '\x02') || (cVar1 == '\x01')) || (cVar1 == '\x10')) ||
       (((cVar1 == '\x0f' || (cVar1 == '\x14')) || (cVar1 == '\x13')))) {
      process_alchemist_turn(game_data);
      if (*puVar4 == 0) {
        gm_AllocObject(*(undefined4 *)((int)game_data + 4),0x154,1);
      }
    }
    else {
      process_alchemist_turn(game_data);
      if (*puVar4 != 0) {
        gm_RemoveObject(*(uint32_t *)((int)game_data + 4),*puVar4,1);
      }
    }
    *(int *)((int)game_data + 0x16c) = iVar2;
    if (citizen_data != (void *)0x0) {
      handleAddCitizenToBuilding(game_data,citizen_data);
    }
    *(undefined4 *)((int)game_data + 0x174) = 0;
    *(uint *)((int)game_data + 0x1c8) = *(uint *)((int)game_data + 0x1c8) & 0xffffdfff;
    player_AemterInit(game_data);
    *(undefined4 *)((int)game_data + 0x1b4) = *(undefined4 *)(iVar2 + 0x99);
    *(undefined4 *)((int)game_data + 0x1b8) = *(undefined4 *)(iVar2 + 0x9d);
    *(undefined4 *)((int)game_data + 0x1bc) = *(undefined4 *)(iVar2 + 0xa1);
    *(undefined4 *)((int)game_data + 0x1c0) = *(undefined4 *)(iVar2 + 0xa5);
    if (*(char *)(param_1 + 0x1e) != '\0') {
      *(undefined4 *)((int)game_data + 0x1b8) = *(undefined4 *)(iVar2 + 0x39);
    }
    if (param_2 != (undefined1 *)0x0) {
      *param_2 = 1;
      param_2[1] = 1;
      *(void **)(param_2 + 6) = game_data;
    }
    return 0;
  }
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 2;
    param_2[1] = 1;
    *(undefined4 *)(param_2 + 6) = 0;
  }
  return 2;
}



undefined4 cm_AllocCharacter(void *param_1,undefined1 *param_2)

{
  uint16_t uVar1;
  int iVar2;
  uint uVar3;
  char *message;
  
  *(undefined4 *)((int)param_1 + 0x10) = DAT_10030b6c;
  iVar2 = _rand();
  *(int *)((int)param_1 + 0x22) = iVar2;
  if (param_2 != (undefined1 *)0x0) {
    *param_2 = 2;
    param_2[1] = 1;
    *(undefined4 *)(param_2 + 6) = 0;
  }
  seed_random(*(uint32_t *)((int)param_1 + 0x22));
  if (*(int *)((int)param_1 + 0x17) != -1) {
    iVar2 = gm_GetPlayerConnection(param_1,*(int *)((int)param_1 + 0x17));
    *(int *)((int)param_1 + 0x17) = iVar2;
    iVar2 = gm_FindObject(1,1,iVar2);
    if (iVar2 == 0) {
      message = s_Invalid__GI_Id__for_cmdt_ALLOC_C_1002d394;
      iVar2 = 0x5246;
      goto LAB_1000fa2c;
    }
  }
  uVar1 = gm_AllocPlayer((uint)*(byte *)((int)param_1 + 0x14),0xffffffff,0xffffffff,(void *)0x14,
                         (void *)0x0,*(uint8_t *)((int)param_1 + 0x1f),
                         (uint)*(byte *)((int)param_1 + 0x20),0);
  uVar3 = (uint)uVar1;
  if (uVar3 != 0xffff) {
    if (*(int *)((int)param_1 + 0x1b) != -1) {
      handleLoadGameData4(*(int *)((int)param_1 + 0x1b));
    }
    (&DAT_10035a0c)[uVar3 * 0x87] = 0;
    (&DAT_100358a2)[uVar3 * 0x21c] = 0xd;
    if (*(char *)((int)param_1 + 0x21) != '\0') {
      gm_AllocObject((&DAT_100358a4)[uVar3 * 0x87],*(char *)((int)param_1 + 0x21),1);
    }
    *(undefined4 *)(&DAT_10442d00 + (uint)*(byte *)((int)param_1 + 3) * 0x264264) =
         (&DAT_100358a4)[uVar3 * 0x87];
    if (param_2 != (undefined1 *)0x0) {
      *param_2 = 1;
      param_2[1] = 1;
      *(undefined2 **)(param_2 + 6) = &DAT_100358a0 + uVar3 * 0x10e;
    }
    return 0;
  }
  message = s_cm_ExAllocCharacter___gm_AllocSp_1002d364;
  iVar2 = 0x525a;
LAB_1000fa2c:
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar2,message,1);
  return 1;
}



// Setting prototype: int create_building(void *player_data, uint8_t *status_flag)

int cm_CreateBuilding(void *player_data,uint8_t *status_flag)

{
  undefined2 *puVar1;
  undefined2 extraout_var;
  int iVar2;
  char *message;
  
                    // 
                    // Creates a new building in the game.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    //   status_flag: Pointer to a flag that will be set to 1 if successful.
                    // 
                    // Return values:
                    //   0 if successful, 1 otherwise.
                    // 
  puVar1 = (undefined2 *)handleGetPlayerById(*(undefined4 *)((int)player_data + 0x10));
  if (puVar1 == (undefined2 *)0x0) {
    message = s_cm_ExCreateGeb____Could_not_find_1002d41c;
    iVar2 = 0x5386;
  }
  else {
    *(undefined4 *)((int)player_data + 0x14) = DAT_10030b6c;
    iVar2 = gm_AllocBuilding(*(undefined1 *)((int)player_data + 0x18),CONCAT22(extraout_var,*puVar1)
                            );
    if (iVar2 != 0) {
      *(undefined4 *)(&DAT_10442d04 + (uint)*(byte *)((int)player_data + 3) * 0x264264) =
           *(undefined4 *)(iVar2 + 1);
      if (status_flag != (uint8_t *)0x0) {
        *status_flag = '\x01';
        status_flag[1] = '\x02';
        *(int *)(status_flag + 6) = iVar2;
      }
      return 0;
    }
    message = s_cm_ExCreateGeb____failed_1002d400;
    iVar2 = 0x539e;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002c748,iVar2,message,1);
  return 1;
}



// Setting prototype: int start_cutscene(void *cutscene_data, uint8_t *status_flag)

int cm_StartCutscene(void *cutscene_data,uint8_t *status_flag)

{
  int iVar1;
  int iVar2;
  undefined4 *puVar3;
  
                    // 
                    // Starts a cutscene in the game.
                    // 
                    // Parameters:
                    //   cutscene_data: Pointer to the cutscene's data structure.
                    //   status_flag: Pointer to a flag that will be set to 2 if the cutscene is not
                    // ready.
                    // 
                    // Return values:
                    //   0 if successful, 1 if the cutscene is already ready.
                    // 
  iVar1 = cm_IsCutsceneReady(cutscene_data);
  if (iVar1 != 0) {
    if (status_flag != (uint8_t *)0x0) {
      *status_flag = '\x02';
    }
    return 1;
  }
  puVar3 = (undefined4 *)((int)cutscene_data + 0x14);
  iVar1 = 0x10;
  do {
    iVar2 = handleGetPlayerById(*puVar3);
    if (iVar2 != 0) {
      *(undefined4 *)(iVar2 + 0x20c) = *(undefined4 *)((int)cutscene_data + 0x10);
    }
    puVar3 = puVar3 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return 0;
}



// Setting prototype: int set_player_money(void *player_data)

int cm_SetPlayerMoney(void *player_data)

{
  int iVar1;
  uint uVar2;
  
                    // 
                    // Sets a player's money.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   0 if successful, 1 otherwise.
                    // 
  iVar1 = handleGetPlayerById(*(undefined4 *)((int)player_data + 0x10));
  if (iVar1 == 0) {
    return 1;
  }
  uVar2 = *(int *)((int)player_data + 0x14) + *(int *)(iVar1 + 0x194);
  uVar2 = uVar2 & ((int)uVar2 < 0) - 1;
  if (0x31 < (int)uVar2) {
    uVar2 = 0x32;
  }
  *(uint *)(iVar1 + 0x194) = uVar2;
  return 0;
}



// Setting prototype: int set_player_title(void *player_data)

int __cdecl cm_SetPlayerTitle(void *player_data)

{
  void *player_data_00;
  char cVar1;
  uint uVar2;
  
                    // 
                    // Sets a player's title and updates related Amt information.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   0 if successful, 1 otherwise.
                    // 
  player_data_00 = (void *)handleGetPlayerById(*(undefined4 *)((int)player_data + 0x10));
  if (player_data_00 != (void *)0x0) {
    uVar2 = *(int *)((int)player_data + 0x14) + (uint)*(byte *)((int)player_data_00 + 0x1b1);
    uVar2 = uVar2 & ((int)uVar2 < 0) - 1;
    if (0xfe < (int)uVar2) {
      uVar2 = 0xff;
    }
    cVar1 = (char)uVar2;
    *(char *)((int)player_data_00 + 0x1b1) = cVar1;
    if (cVar1 == '\0') {
      cVar1 = '\0';
    }
    *(char *)((int)player_data_00 + 0x1b1) = cVar1;
    handleRemovePlayerFromAmtWithCleanup(player_data_00,*(int *)((int)player_data + 0x18));
    return 0;
  }
  return 1;
}



// Setting prototype: int set_player_skill(void *player_data)

int cm_SetPlayerSkill(void *player_data)

{
  int iVar1;
  float fVar2;
  int iVar3;
  int32_t iVar4;
  
                    // 
                    // Sets a player's skill level.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   0 if successful, 1 otherwise.
                    // 
  iVar3 = handleGetPlayerById(*(undefined4 *)((int)player_data + 0x10));
  if (((iVar3 == 0) || (iVar1 = *(int *)((int)player_data + 0x14), iVar1 < 0)) || (4 < iVar1)) {
    return 1;
  }
  fVar2 = (float)(int)(*(int *)((int)player_data + 0x18) + (uint)*(byte *)(iVar1 + 0x80 + iVar3));
  if (((252.0 <= fVar2) || (0.0 < fVar2)) && (252.0 <= fVar2)) {
    iVar4 = __ftol();
    *(char *)(iVar1 + 0x80 + iVar3) = (char)iVar4;
    return 0;
  }
  iVar4 = __ftol();
  *(char *)(iVar1 + 0x80 + iVar3) = (char)iVar4;
  return 0;
}



int cm_ZombieCommand(int param_1)

{
  void *worker_data;
  int iVar1;
  
  *(undefined4 *)(param_1 + 0x27) = DAT_10030b6c;
  iVar1 = _rand();
  *(int *)(param_1 + 0x2b) = iVar1;
  worker_data = (void *)(param_1 + 0x10);
  switch(*(undefined4 *)(param_1 + 0x10)) {
  case 0:
    iVar1 = cm_SetZombieData(worker_data);
    return iVar1;
  case 1:
    iVar1 = cm_CreateZombie(worker_data);
    return iVar1;
  case 2:
    iVar1 = cm_UpdateZombieData(worker_data);
    return iVar1;
  case 3:
    iVar1 = cm_SetZombieOwner(worker_data);
    return iVar1;
  case 4:
    iVar1 = cm_SetZombieState(worker_data);
    return iVar1;
  case 5:
    iVar1 = cm_ZombieLogic(worker_data);
    return iVar1;
  case 6:
    iVar1 = cm_AllocGraveyardWorker(worker_data);
    return iVar1;
  default:
    return -1;
  }
}



int cm_AllocGraveyardWorker(int param_1)

{
  uint32_t uVar1;
  
  *(undefined4 *)(param_1 + 0x14) = DAT_10030b6c;
  uVar1 = _rand();
  *(uint32_t *)(param_1 + 0x10) = uVar1;
  seed_random(uVar1);
  uVar1 = handleAllocGraveyardWorker2((uint32_t *)(param_1 + 0x10));
  return (uVar1 != 0xffff) - 1;
}



int cm_GetPlayerAmtId(int param_1)

{
  uint16_t uVar1;
  uint32_t seed;
  undefined2 extraout_var;
  
  *(undefined4 *)(param_1 + 0x14) = DAT_10030b6c;
  seed = _rand();
  *(uint32_t *)(param_1 + 0x10) = seed;
  seed_random(seed);
  uVar1 = handleGetPlayerAmtId((uint32_t *)(param_1 + 0x10));
  return (CONCAT22(extraout_var,uVar1) != 0xffff) - 1;
}



undefined4 srv_HandlePlayerCommand(int param_1)

{
  void *player_data;
  uint uVar1;
  bool bVar2;
  void *player_data_00;
  undefined3 extraout_var;
  
  player_data_00 = (void *)handleGetPlayerById(*(undefined4 *)(param_1 + 0x14));
  if (player_data_00 == (void *)0x0) {
    return 0xffffffff;
  }
  bVar2 = handleIsPlayerInAmt(player_data_00);
  if (CONCAT31(extraout_var,bVar2) == 0) {
    return 0xfffffffe;
  }
  uVar1 = *(uint *)(param_1 + 0x10);
  player_data = (void *)(param_1 + 0x10);
  if (uVar1 < 0x61536d54) {
    if (uVar1 == 0x61536d53) {
      update_player_desire(player_data,*(void **)(*(int *)((int)player_data_00 + 0x16c) + 0x65));
      return 0;
    }
    if (uVar1 == 0x46697245) {
      clear_inventory_slot
                ((uint32_t)player_data,
                 *(void **)((int)*(void **)((int)player_data_00 + 0x16c) + 0x65),
                 *(void **)((int)player_data_00 + 0x16c));
      return 0;
    }
    if (uVar1 == 0x61437353) {
      set_player_attributes(player_data,*(int *)(*(int *)((int)player_data_00 + 0x16c) + 0x65));
      return 0;
    }
    if (uVar1 == 0x61535263) {
      update_player_building(player_data,*(void **)(*(int *)((int)player_data_00 + 0x16c) + 0x65));
      return 0;
    }
  }
  else {
    if (uVar1 == 0x61616452) {
      add_player_to_building
                (player_data,*(void **)((int)*(void **)((int)player_data_00 + 0x16c) + 0x65),
                 *(void **)((int)player_data_00 + 0x16c));
      return 0;
    }
    if (uVar1 == 0x61736452) {
      remove_player_from_building
                (player_data,*(void **)((int)*(void **)((int)player_data_00 + 0x16c) + 0x65),
                 *(void **)((int)player_data_00 + 0x16c));
      return 0;
    }
  }
  return 0xfffffffd;
}



// Setting prototype: int get_building_data_size(void *building_data)

int cm_ExGetBuildingDataSize(void *building_data)

{
  char cVar1;
  int iVar2;
  int iVar3;
  
                    // 
                    // Returns the size of a building's data structure based on its type and
                    // properties.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   The size of the building data in bytes.
                    // 
                    // WARNING: Load size is inaccurate
  iVar2 = *(int *)((int)building_data + 0x65);
  cVar1 = *(char *)(DAT_100a8c30 + (uint)*building_data * 0x24d + 0x247);
  if (cVar1 == '\x01') {
    iVar3 = 8;
    if (*(char *)(iVar2 + 0x19) == '\x01') {
      return 0xc;
    }
  }
  else if (cVar1 == '\x02') {
    iVar3 = 0xc;
    if (*(char *)(iVar2 + 0x19) == '\x01') {
      iVar3 = 0x12;
    }
    if (*(char *)(iVar2 + 0x1a) == '\x01') {
      return iVar3 + 2;
    }
  }
  else {
    iVar3 = 0x10;
    if (*(char *)(iVar2 + 0x19) == '\x01') {
      iVar3 = 0x18;
    }
    if (*(char *)(iVar2 + 0x1a) == '\x01') {
      iVar3 = iVar3 + 4;
    }
    if (*(char *)(iVar2 + 0x1b) == '\x01') {
      iVar3 = iVar3 + 2;
    }
  }
  return iVar3;
}



// Setting prototype: int validate_building_data(void *building_data, int data_type)

int cm_ExValidateBuildingData(void *building_data,int data_type)

{
                    // 
                    // Validates specific fields within a building's data structure based on the
                    // data type.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   data_type: The type of data to validate (0, 1, 2, or 3).
                    // 
                    // Return values:
                    //   1 if the data is valid, 0 otherwise.
                    // 
  if (data_type == 0) {
    if ((*(int *)((int)building_data + 8) == 0) || (*(char *)((int)building_data + 0x18) == '\0')) {
      return 0;
    }
  }
  else if (data_type == 1) {
    if ((*(int *)((int)building_data + 0xc) == 0) || (*(char *)((int)building_data + 0x19) == '\0'))
    {
      return 0;
    }
  }
  else if (data_type == 2) {
    if ((*(int *)((int)building_data + 0x10) == 0) || (*(char *)((int)building_data + 0x1a) == '\0')
       ) {
      return 0;
    }
  }
  else if ((data_type == 3) &&
          ((*(int *)((int)building_data + 0x14) == 0 ||
           (*(char *)((int)building_data + 0x1b) == '\0')))) {
    return 0;
  }
  return 1;
}



// Setting prototype: void *get_building_data_ptr(void *building_data, int data_type, uint8_t index)

int cm_ExGetBuildingDataPtr(void *building_data,int data_type,byte index)

{
  int iVar1;
  
                    // 
                    // Retrieves a pointer to specific building data based on its type and index.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   data_type: The type of data to retrieve (0, 1, 2, or 3).
                    //   index: The index within the data type.
                    // 
                    // Return values:
                    //   A pointer to the requested data, or NULL if invalid.
                    // 
  if ((0 < *(int *)((int)building_data + 4)) && (*(int *)((int)building_data + 4) < 4)) {
    if (data_type == 0) {
      iVar1 = cm_ExValidateBuildingData(building_data,0);
      if (iVar1 != 0) {
        iVar1 = *(int *)((int)building_data + 4);
        if ((((iVar1 != 1) || (index < 8)) && ((iVar1 != 2 || (index < 0xc)))) &&
           ((iVar1 != 3 || (index < 0x10)))) {
          return *(int *)((int)building_data + 8) + (uint)index * 0x14;
        }
      }
    }
    else if (data_type == 1) {
      iVar1 = cm_ExValidateBuildingData(building_data,1);
      if (iVar1 != 0) {
        iVar1 = *(int *)((int)building_data + 4);
        if ((((iVar1 != 1) || (index < 4)) && ((iVar1 != 2 || (index < 6)))) &&
           ((iVar1 != 3 || (index < 8)))) {
          return *(int *)((int)building_data + 0xc) + (uint)index * 0x14;
        }
      }
    }
    else if (data_type == 2) {
      iVar1 = cm_ExValidateBuildingData(building_data,2);
      if ((iVar1 != 0) && (iVar1 = *(int *)((int)building_data + 4), iVar1 != 1)) {
        if (((iVar1 != 2) || (index < 2)) && ((iVar1 != 3 || (index < 4)))) {
          return *(int *)((int)building_data + 0x10) + (uint)index * 0x14;
        }
      }
    }
    else if (data_type == 3) {
      iVar1 = cm_ExValidateBuildingData(building_data,3);
      if ((((iVar1 != 0) && (iVar1 = *(int *)((int)building_data + 4), iVar1 != 1)) && (iVar1 != 2))
         && ((iVar1 != 3 || (index < 2)))) {
        return *(int *)((int)building_data + 0x14) + (uint)index * 0x14;
      }
    }
  }
  return 0;
}



// Setting prototype: uint32_t iterate_building_data(void *callback_data, void *building_type_data,
// int start_offset, void *callback, int data_type)

uint32_t cm_ExIterateBuildingData
                   (void *callback_data,void *building_type_data,int start_offset,void *callback,
                   int data_type)

{
  void *building_data;
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
                    // 
                    // Iterates through building data, optionally calling a callback function for
                    // each entry.
                    // 
                    // Parameters:
                    //   callback_data: Data to pass to the callback function.
                    //   building_type_data: Pointer to the building type data.
                    //   start_offset: Starting offset for iteration.
                    //   callback: Optional callback function to execute for each data entry.
                    //   data_type: The type of data to iterate through (0, 1, 2, 3, or 0xFF for
                    // all).
                    // 
                    // Return values:
                    //   The offset of the found data, or 0 if no more data or an error occurs.
                    // 
                    // WARNING: Load size is inaccurate
  iVar2 = DAT_100a8c30 + (uint)*building_type_data * 0x24d;
  building_data = *(void **)((int)building_type_data + 0x65);
  if ((data_type == 0xff) ||
     (iVar1 = cm_ExValidateBuildingData(building_data,data_type), iVar1 != 0)) {
    if (data_type == 0) {
      uVar3 = *(int *)((int)building_data + 8) +
              *(int *)(&DAT_1002577c + (uint)*(byte *)(iVar2 + 0x247) * 4) * 0x14;
    }
    else if (data_type == 1) {
      uVar3 = *(int *)((int)building_data + 0xc) +
              *(int *)(&DAT_1002578c + (uint)*(byte *)(iVar2 + 0x247) * 4) * 0x14;
    }
    else if (data_type == 2) {
      uVar3 = *(int *)((int)building_data + 0x10) +
              *(int *)(&DAT_1002579c + (uint)*(byte *)(iVar2 + 0x247) * 4) * 0x14;
    }
    else if (data_type == 3) {
      uVar3 = *(int *)((int)building_data + 0x14) +
              *(int *)(&DAT_100257ac + (uint)*(byte *)(iVar2 + 0x247) * 4) * 0x14;
    }
    else {
      if (data_type != 0xff) {
        return 0;
      }
      iVar2 = cm_ExGetBuildingDataSize(building_type_data);
      uVar3 = *(int *)((int)building_data + 0x1c) + iVar2 * 0x14;
    }
    if (start_offset == 0) {
      if (data_type == 0) {
        uVar4 = *(uint *)((int)building_data + 8);
      }
      else if (data_type == 1) {
        uVar4 = *(uint *)((int)building_data + 0xc);
      }
      else if (data_type == 2) {
        uVar4 = *(uint *)((int)building_data + 0x10);
      }
      else if (data_type == 3) {
        uVar4 = *(uint *)((int)building_data + 0x14);
      }
      else {
        uVar4 = *(uint *)((int)building_data + 0x1c);
      }
    }
    else {
      uVar4 = start_offset + 0x14;
    }
    for (; uVar4 < uVar3; uVar4 = uVar4 + 0x14) {
      if ((callback == (void *)0x0) ||
         (iVar2 = (*(code *)callback)(callback_data,uVar4), iVar2 != 0)) {
        return uVar4;
      }
    }
  }
  return 0;
}



// Setting prototype: int alloc_graveyard(void *building_type_data, int count)

int cm_ExAllocGraveyard(void *building_type_data,int count)

{
  byte bVar1;
  undefined4 uVar2;
  short sVar3;
  uint32_t uVar4;
  int32_t iVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  
                    // 
                    // Allocates and initializes a graveyard building.
                    // 
                    // Parameters:
                    //   building_type_data: Pointer to the building type data for the graveyard.
                    //   count: The number of graveyards to allocate.
                    // 
                    // Return values:
                    //   The number of graveyards successfully allocated, or 0 on failure.
                    // 
                    // WARNING: Load size is inaccurate
  uVar6 = (uint)*building_type_data;
  if (((*(char *)(DAT_100a8c30 + uVar6 + uVar6 * 0x24c) == '\x1d') &&
      (bVar1 = *(byte *)(DAT_100a8c30 + uVar6 + uVar6 * 0x24c + 0x247), bVar1 != 0)) && (bVar1 < 4))
  {
    iVar7 = 0;
    if (0 < count) {
      do {
        uVar4 = cm_ExIterateBuildingData((void *)0x0,building_type_data,0,&LAB_10010700,0);
        if (uVar4 == 0) {
          return iVar7;
        }
        **(int **)(uVar4 + 0x10) = DAT_10030b6c;
        DAT_10030b6c = DAT_10030b6c + 1;
        uVar2 = **(undefined4 **)(uVar4 + 0x10);
        *(undefined2 *)(uVar4 + 8) = 0x7fff;
        *(undefined4 *)(uVar4 + 4) = uVar2;
        sVar3 = (short)DAT_10035880;
        *(undefined1 *)(uVar4 + 0xc) = 0xff;
        *(short *)(uVar4 + 10) = sVar3 + 5;
        iVar8 = 0;
        do {
          get_random_number(8);
          iVar5 = __ftol();
          iVar8 = iVar8 + 1;
          *(char *)(*(int *)(uVar4 + 0x10) + 0x23 + iVar8) = (char)iVar5;
        } while (iVar8 < 5);
        uVar6 = get_random_number(9);
        *(uint *)(*(int *)(uVar4 + 0x10) + 0x2c) = (uVar6 & 0xffff) + 1;
        uVar6 = get_random_number(2);
        *(uint *)(*(int *)(uVar4 + 0x10) + 0x30) = (uVar6 & 0xffff) + 1;
        uVar6 = get_random_number(0x5e);
        *(uint *)(*(int *)(uVar4 + 0x10) + 0x34) = (uVar6 & 0xffff) + 1;
        uVar6 = get_random_number(4);
        *(uint *)(*(int *)(uVar4 + 0x10) + 0x40) = (DAT_10035880 - (uVar6 & 0xffff)) + -1;
        uVar6 = get_random_number(2);
        *(uint *)(*(int *)(uVar4 + 0x10) + 0x38) = uVar6 & 0xffff;
        get_random_number(0x10);
        get_random_number(0x10);
        get_random_number(0x10);
        iVar7 = iVar7 + 1;
      } while (iVar7 < count);
    }
    return iVar7;
  }
  return 0;
}



// Setting prototype: void *alloc_graveyard_field(void *building_type_data)

undefined4 * cm_ExAllocGraveyardField(byte *building_type_data)

{
  undefined4 *ptr;
  undefined4 *puVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  
                    // 
                    // Allocates and initializes a graveyard field within a building.
                    // 
                    // Parameters:
                    //   building_type_data: Pointer to the building type data.
                    // 
                    // Return values:
                    //   A pointer to the allocated graveyard field data, or NULL on failure.
                    // 
  uVar3 = (uint)*building_type_data;
  iVar5 = DAT_100a8c30 + uVar3 + uVar3 * 0x24c;
  if (((*(char *)(DAT_100a8c30 + uVar3 + uVar3 * 0x24c) == '\x1d') &&
      (*(byte *)(iVar5 + 0x247) != 0)) && (*(byte *)(iVar5 + 0x247) < 4)) {
    ptr = (undefined4 *)mAlloc(0x24,s_gv_AllocGraveyardField_1002d474);
    if (ptr != (undefined4 *)0x0) {
      puVar1 = ptr;
      for (iVar2 = 9; iVar2 != 0; iVar2 = iVar2 + -1) {
        *puVar1 = 0;
        puVar1 = puVar1 + 1;
      }
      *ptr = *(undefined4 *)(building_type_data + 1);
      ptr[1] = (uint)*(byte *)(iVar5 + 0x247);
      puVar1 = (undefined4 *)
               mAlloc(*(int *)(&DAT_1002575c + (uint)*(byte *)(iVar5 + 0x247) * 4) * 0x14,
                      s_gv_Alloc__all_graves_1002d45c);
      ptr[7] = puVar1;
      if (puVar1 != (undefined4 *)0x0) {
        for (uVar3 = *(int *)(&DAT_1002575c + (uint)*(byte *)(iVar5 + 0x247) * 4) * 5 & 0x3fffffff;
            uVar3 != 0; uVar3 = uVar3 - 1) {
          *puVar1 = 0;
          puVar1 = puVar1 + 1;
        }
        for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
          *(undefined1 *)puVar1 = 0;
          puVar1 = (undefined4 *)((int)puVar1 + 1);
        }
        puVar1 = (undefined4 *)
                 mAlloc(*(int *)(&DAT_1002576c + (uint)*(byte *)(iVar5 + 0x247) * 4) * 0x44,
                        s_gv_Alloc__all_zombies_1002d444);
        ptr[8] = puVar1;
        if (puVar1 != (undefined4 *)0x0) {
          for (uVar3 = *(int *)(&DAT_1002576c + (uint)*(byte *)(iVar5 + 0x247) * 4) * 0x11 &
                       0x3fffffff; uVar3 != 0; uVar3 = uVar3 - 1) {
            *puVar1 = 0;
            puVar1 = puVar1 + 1;
          }
          for (iVar2 = 0; iVar2 != 0; iVar2 = iVar2 + -1) {
            *(undefined1 *)puVar1 = 0;
            puVar1 = (undefined4 *)((int)puVar1 + 1);
          }
          iVar2 = 0;
          if (0 < *(int *)(&DAT_1002576c + (uint)*(byte *)(iVar5 + 0x247) * 4)) {
            iVar4 = 0;
            do {
              iVar2 = iVar2 + 1;
              *(undefined4 *)(iVar4 + ptr[8]) = 0xffffffff;
              iVar4 = iVar4 + 0x44;
            } while (iVar2 < *(int *)(&DAT_1002576c + (uint)*(byte *)(iVar5 + 0x247) * 4));
          }
          puVar1 = (undefined4 *)ptr[7];
          iVar5 = ptr[8];
          ptr[2] = puVar1;
          *(undefined1 *)(ptr + 6) = 1;
          *(undefined1 *)((int)ptr + 0x19) = 0;
          *(undefined1 *)((int)ptr + 0x1a) = 0;
          *(undefined1 *)((int)ptr + 0x1b) = 0;
          if (ptr[1] == 1) {
            ptr[4] = 0;
            ptr[3] = puVar1 + 0x28;
            ptr[5] = 0;
            iVar2 = 8;
            do {
              *puVar1 = 0;
              puVar1[4] = iVar5;
              puVar1[1] = 0xffffffff;
              *(undefined2 *)(puVar1 + 2) = 0xffff;
              iVar5 = iVar5 + 0x44;
              puVar1 = puVar1 + 5;
              iVar2 = iVar2 + -1;
            } while (iVar2 != 0);
            iVar2 = 4;
            do {
              *puVar1 = 1;
              puVar1[4] = iVar5;
              puVar1[1] = 0xffffffff;
              *(undefined2 *)(puVar1 + 2) = 0xffff;
              iVar5 = iVar5 + 0x88;
              puVar1 = puVar1 + 5;
              iVar2 = iVar2 + -1;
            } while (iVar2 != 0);
            *(undefined4 **)(building_type_data + 0x65) = ptr;
            return ptr;
          }
          if (ptr[1] == 2) {
            ptr[5] = 0;
            ptr[3] = puVar1 + 0x3c;
            ptr[4] = puVar1 + 0x5a;
            iVar2 = 0xc;
            do {
              *puVar1 = 0;
              puVar1[4] = iVar5;
              puVar1[1] = 0xffffffff;
              *(undefined2 *)(puVar1 + 2) = 0xffff;
              iVar5 = iVar5 + 0x44;
              puVar1 = puVar1 + 5;
              iVar2 = iVar2 + -1;
            } while (iVar2 != 0);
            iVar2 = 6;
            do {
              *puVar1 = 1;
              puVar1[4] = iVar5;
              puVar1[1] = 0xffffffff;
              *(undefined2 *)(puVar1 + 2) = 0xffff;
              iVar5 = iVar5 + 0x88;
              puVar1 = puVar1 + 5;
              iVar2 = iVar2 + -1;
            } while (iVar2 != 0);
            iVar2 = 2;
            do {
              *puVar1 = 2;
              puVar1[4] = iVar5;
              puVar1[1] = 0xffffffff;
              *(undefined2 *)(puVar1 + 2) = 0xffff;
              iVar5 = iVar5 + 0x110;
              puVar1 = puVar1 + 5;
              iVar2 = iVar2 + -1;
            } while (iVar2 != 0);
            *(undefined4 **)(building_type_data + 0x65) = ptr;
            return ptr;
          }
          iVar2 = 0x10;
          ptr[3] = puVar1 + 0x50;
          ptr[4] = puVar1 + 0x78;
          ptr[5] = puVar1 + 0x8c;
          do {
            *puVar1 = 0;
            puVar1[4] = iVar5;
            puVar1[1] = 0xffffffff;
            *(undefined2 *)(puVar1 + 2) = 0xffff;
            iVar5 = iVar5 + 0x44;
            puVar1 = puVar1 + 5;
            iVar2 = iVar2 + -1;
          } while (iVar2 != 0);
          iVar2 = 8;
          do {
            *puVar1 = 1;
            puVar1[4] = iVar5;
            puVar1[1] = 0xffffffff;
            *(undefined2 *)(puVar1 + 2) = 0xffff;
            iVar5 = iVar5 + 0x88;
            puVar1 = puVar1 + 5;
            iVar2 = iVar2 + -1;
          } while (iVar2 != 0);
          iVar2 = 4;
          do {
            *puVar1 = 2;
            puVar1[4] = iVar5;
            puVar1[1] = 0xffffffff;
            *(undefined2 *)(puVar1 + 2) = 0xffff;
            iVar5 = iVar5 + 0x110;
            puVar1 = puVar1 + 5;
            iVar2 = iVar2 + -1;
          } while (iVar2 != 0);
          iVar2 = 2;
          do {
            *puVar1 = 3;
            puVar1[4] = iVar5;
            puVar1[1] = 0xffffffff;
            *(undefined2 *)(puVar1 + 2) = 0xffff;
            iVar5 = iVar5 + 0x220;
            puVar1 = puVar1 + 5;
            iVar2 = iVar2 + -1;
          } while (iVar2 != 0);
          *(undefined4 **)(building_type_data + 0x65) = ptr;
          return ptr;
        }
      }
      if ((void *)ptr[7] != (void *)0x0) {
        m_free((void *)ptr[7]);
        ptr[7] = 0;
      }
      if ((void *)ptr[8] != (void *)0x0) {
        m_free((void *)ptr[8]);
        ptr[8] = 0;
      }
      m_free(ptr);
    }
  }
  return (undefined4 *)0x0;
}



// Setting prototype: int upgrade_graveyard(void *graveyard_data)

int cm_ExUpgradeGraveyard(void *graveyard_data)

{
  void *graveyard_data_00;
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  undefined4 *puVar7;
  undefined4 *puVar8;
  int local_8;
  
                    // 
                    // Upgrades a graveyard to the next level.
                    // This involves allocating a new graveyard field, copying data from the old
                    // field, and freeing the old field.
                    // 
                    // Parameters:
                    //   graveyard_data: Pointer to the graveyard's data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
                    // WARNING: Load size is inaccurate
  uVar2 = (uint)*graveyard_data;
  graveyard_data_00 = *(void **)((int)graveyard_data + 0x65);
  iVar3 = DAT_100a8c30 + uVar2 + uVar2 * 0x24c;
  if ((((*(char *)(DAT_100a8c30 + uVar2 + uVar2 * 0x24c) == '\x1d') &&
       (graveyard_data_00 != (void *)0x0)) && (*(int *)((int)graveyard_data_00 + 4) < 3)) &&
     ((uint)*(byte *)(iVar3 + 0x247) - *(int *)((int)graveyard_data_00 + 4) == 1)) {
    *(undefined4 *)((int)graveyard_data + 0x65) = 0;
    iVar1 = cm_ExAllocGraveyardField(graveyard_data);
    if (iVar1 != 0) {
      if (*(char *)(iVar3 + 0x247) == '\x02') {
        local_8 = 0;
        iVar5 = 8;
        iVar6 = 4;
        puVar7 = *(undefined4 **)(*(int *)((int)graveyard_data_00 + 8) + 0x10);
        puVar8 = *(undefined4 **)(*(int *)(iVar1 + 8) + 0x10);
        for (iVar3 = 0x88; iVar3 != 0; iVar3 = iVar3 + -1) {
          *puVar8 = *puVar7;
          puVar7 = puVar7 + 1;
          puVar8 = puVar8 + 1;
        }
        iVar3 = *(int *)(iVar1 + 0xc);
        puVar7 = *(undefined4 **)(*(int *)((int)graveyard_data_00 + 0xc) + 0x10);
      }
      else {
        local_8 = 2;
        puVar7 = *(undefined4 **)(*(int *)((int)graveyard_data_00 + 8) + 0x10);
        puVar8 = *(undefined4 **)(*(int *)(iVar1 + 8) + 0x10);
        for (iVar3 = 0xcc; iVar3 != 0; iVar3 = iVar3 + -1) {
          *puVar8 = *puVar7;
          puVar7 = puVar7 + 1;
          puVar8 = puVar8 + 1;
        }
        iVar5 = 0xc;
        puVar7 = *(undefined4 **)(*(int *)((int)graveyard_data_00 + 0xc) + 0x10);
        puVar8 = *(undefined4 **)(*(int *)(iVar1 + 0xc) + 0x10);
        for (iVar3 = 0xcc; iVar3 != 0; iVar3 = iVar3 + -1) {
          *puVar8 = *puVar7;
          puVar7 = puVar7 + 1;
          puVar8 = puVar8 + 1;
        }
        iVar3 = *(int *)(iVar1 + 0x10);
        iVar6 = 6;
        puVar7 = *(undefined4 **)(*(int *)((int)graveyard_data_00 + 0x10) + 0x10);
      }
      puVar8 = *(undefined4 **)(iVar3 + 0x10);
      for (iVar4 = 0x88; iVar4 != 0; iVar4 = iVar4 + -1) {
        *puVar8 = *puVar7;
        puVar7 = puVar7 + 1;
        puVar8 = puVar8 + 1;
      }
      if ((*(int *)((int)graveyard_data_00 + 8) != 0) && (iVar5 != 0)) {
        iVar3 = 0;
        do {
          *(undefined4 *)(*(int *)(iVar1 + 8) + iVar3) =
               *(undefined4 *)(iVar3 + *(int *)((int)graveyard_data_00 + 8));
          *(undefined4 *)(*(int *)(iVar1 + 8) + 4 + iVar3) =
               *(undefined4 *)(iVar3 + 4 + *(int *)((int)graveyard_data_00 + 8));
          *(undefined2 *)(*(int *)(iVar1 + 8) + 8 + iVar3) =
               *(undefined2 *)(iVar3 + 8 + *(int *)((int)graveyard_data_00 + 8));
          *(undefined2 *)(*(int *)(iVar1 + 8) + 10 + iVar3) =
               *(undefined2 *)(iVar3 + 10 + *(int *)((int)graveyard_data_00 + 8));
          *(undefined1 *)(*(int *)(iVar1 + 8) + 0xc + iVar3) =
               *(undefined1 *)(iVar3 + 0xc + *(int *)((int)graveyard_data_00 + 8));
          iVar3 = iVar3 + 0x14;
          iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
      }
      if ((*(int *)((int)graveyard_data_00 + 0xc) != 0) && (iVar6 != 0)) {
        iVar3 = 0;
        do {
          *(undefined4 *)(iVar3 + *(int *)(iVar1 + 0xc)) =
               *(undefined4 *)(iVar3 + *(int *)((int)graveyard_data_00 + 0xc));
          *(undefined4 *)(iVar3 + 4 + *(int *)(iVar1 + 0xc)) =
               *(undefined4 *)(iVar3 + 4 + *(int *)((int)graveyard_data_00 + 0xc));
          *(undefined2 *)(iVar3 + 8 + *(int *)(iVar1 + 0xc)) =
               *(undefined2 *)(iVar3 + 8 + *(int *)((int)graveyard_data_00 + 0xc));
          *(undefined2 *)(iVar3 + 10 + *(int *)(iVar1 + 0xc)) =
               *(undefined2 *)(iVar3 + 10 + *(int *)((int)graveyard_data_00 + 0xc));
          *(undefined1 *)(iVar3 + 0xc + *(int *)(iVar1 + 0xc)) =
               *(undefined1 *)(iVar3 + 0xc + *(int *)((int)graveyard_data_00 + 0xc));
          iVar3 = iVar3 + 0x14;
          iVar6 = iVar6 + -1;
        } while (iVar6 != 0);
      }
      if ((*(int *)((int)graveyard_data_00 + 0x10) != 0) && (local_8 != 0)) {
        iVar3 = 0;
        do {
          *(undefined4 *)(iVar3 + *(int *)(iVar1 + 0x10)) =
               *(undefined4 *)(iVar3 + *(int *)((int)graveyard_data_00 + 0x10));
          *(undefined4 *)(iVar3 + 4 + *(int *)(iVar1 + 0x10)) =
               *(undefined4 *)(iVar3 + 4 + *(int *)((int)graveyard_data_00 + 0x10));
          *(undefined2 *)(iVar3 + 8 + *(int *)(iVar1 + 0x10)) =
               *(undefined2 *)(iVar3 + 8 + *(int *)((int)graveyard_data_00 + 0x10));
          *(undefined2 *)(iVar3 + 10 + *(int *)(iVar1 + 0x10)) =
               *(undefined2 *)(iVar3 + 10 + *(int *)((int)graveyard_data_00 + 0x10));
          *(undefined1 *)(iVar3 + 0xc + *(int *)(iVar1 + 0x10)) =
               *(undefined1 *)(iVar3 + 0xc + *(int *)((int)graveyard_data_00 + 0x10));
          iVar3 = iVar3 + 0x14;
          local_8 = local_8 + -1;
        } while (local_8 != 0);
      }
      *(undefined1 *)(iVar1 + 0x18) = *(undefined1 *)((int)graveyard_data_00 + 0x18);
      *(undefined1 *)(iVar1 + 0x19) = *(undefined1 *)((int)graveyard_data_00 + 0x19);
      *(undefined1 *)(iVar1 + 0x1a) = *(undefined1 *)((int)graveyard_data_00 + 0x1a);
      *(undefined1 *)(iVar1 + 0x1b) = *(undefined1 *)((int)graveyard_data_00 + 0x1b);
      cm_ExFreeGraveyard(graveyard_data_00);
      return *(int *)((int)graveyard_data + 0x65);
    }
    *(void **)((int)graveyard_data + 0x65) = graveyard_data_00;
  }
  return 0;
}



// Setting prototype: void free_graveyard(void *graveyard_data)

void cm_ExFreeGraveyard(void *graveyard_data)

{
                    // 
                    // Frees the memory allocated for a graveyard and its associated fields.
                    // 
                    // Parameters:
                    //   graveyard_data: Pointer to the graveyard's data structure.
                    // 
  if (graveyard_data != (void *)0x0) {
    if (*(void **)((int)graveyard_data + 0x1c) != (void *)0x0) {
      m_free(*(void **)((int)graveyard_data + 0x1c));
      *(undefined4 *)((int)graveyard_data + 0x1c) = 0;
    }
    if (*(void **)((int)graveyard_data + 0x20) != (void *)0x0) {
      m_free(*(void **)((int)graveyard_data + 0x20));
      *(undefined4 *)((int)graveyard_data + 0x20) = 0;
    }
    m_free(graveyard_data);
  }
  return;
}



// Setting prototype: int set_zombie_data(void *zombie_data)

int cm_SetZombieData(void *zombie_data)

{
  char cVar1;
  void *building_data;
  void *pvVar2;
  int iVar3;
  int *piVar4;
  uint uVar5;
  uint uVar6;
  int *piVar7;
  int *piVar8;
  char *pcVar9;
  char *pcVar10;
  byte *local_4;
  
                    // 
                    // Sets the data for a zombie, including its properties and associated strings.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   A status code indicating success or failure.
                    // 
  pvVar2 = zombie_data;
  gm_LoadGameData(&local_4,(void **)0x0,(void **)0x0,*(uint32_t *)((int)zombie_data + 8));
  if (((local_4 == (byte *)0x0) || (*(ushort *)(local_4 + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)(local_4 + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
  if (*(char *)(DAT_100a8c30 + (uint)*local_4 * 0x24d) != '\x1d') {
    return -2;
  }
  building_data = *(void **)(local_4 + 0x65);
  if (building_data == (void *)0x0) {
    return -3;
  }
  iVar3 = cm_ExValidateBuildingData(building_data,*(int *)((int)pvVar2 + 0xc));
  if (iVar3 == 0) {
    return -4;
  }
  gm_LoadGameData((void **)0x0,(void **)0x0,&zombie_data,*(uint32_t *)((int)pvVar2 + 4));
  if (zombie_data == (void *)0x0) {
    return -6;
  }
  iVar3 = cm_ExGetBuildingDataPtr
                    (building_data,*(undefined4 *)((int)pvVar2 + 0xc),
                     *(undefined1 *)((int)pvVar2 + 0x10));
  if ((iVar3 == 0) || (*(short *)(iVar3 + 8) != *(short *)((int)zombie_data + 0x50))) {
    return -7;
  }
  piVar8 = *(int **)(iVar3 + 0x10);
  iVar3 = 0;
  piVar4 = piVar8;
  piVar7 = piVar8;
  if (0 < *(int *)(&DAT_1002574c + *(int *)((int)pvVar2 + 0xc) * 4)) {
    do {
      if (*piVar7 == -1) break;
      if (*piVar4 == -1) {
        piVar7 = piVar8 + iVar3 * 0x11;
        break;
      }
      if (piVar4[0x10] < piVar7[0x10]) {
        piVar7 = piVar4;
      }
      iVar3 = iVar3 + 1;
      piVar4 = piVar4 + 0x11;
    } while (iVar3 < *(int *)(&DAT_1002574c + *(int *)((int)pvVar2 + 0xc) * 4));
  }
  *piVar7 = *(int *)((int)zombie_data + 4);
  uVar5 = 0xffffffff;
  pcVar9 = (char *)((int)zombie_data + 0x30);
  do {
    pcVar10 = pcVar9;
    if (uVar5 == 0) break;
    uVar5 = uVar5 - 1;
    pcVar10 = pcVar9 + 1;
    cVar1 = *pcVar9;
    pcVar9 = pcVar10;
  } while (cVar1 != '\0');
  uVar5 = ~uVar5;
  piVar4 = (int *)(pcVar10 + -uVar5);
  piVar8 = piVar7;
  for (uVar6 = uVar5 >> 2; piVar8 = piVar8 + 1, uVar6 != 0; uVar6 = uVar6 - 1) {
    *piVar8 = *piVar4;
    piVar4 = piVar4 + 1;
  }
  for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
    *(char *)piVar8 = (char)*piVar4;
    piVar4 = (int *)((int)piVar4 + 1);
    piVar8 = (int *)((int)piVar8 + 1);
  }
  uVar5 = 0xffffffff;
  pcVar9 = (char *)((int)zombie_data + 0x40);
  do {
    pcVar10 = pcVar9;
    if (uVar5 == 0) break;
    uVar5 = uVar5 - 1;
    pcVar10 = pcVar9 + 1;
    cVar1 = *pcVar9;
    pcVar9 = pcVar10;
  } while (cVar1 != '\0');
  uVar5 = ~uVar5;
  piVar8 = (int *)(pcVar10 + -uVar5);
  piVar4 = piVar7 + 5;
  for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
    *piVar4 = *piVar8;
    piVar8 = piVar8 + 1;
    piVar4 = piVar4 + 1;
  }
  for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
    *(char *)piVar4 = (char)*piVar8;
    piVar8 = (int *)((int)piVar8 + 1);
    piVar4 = (int *)((int)piVar4 + 1);
  }
  piVar7[9] = *(int *)((int)zombie_data + 0x80);
  *(char *)(piVar7 + 10) = *(char *)((int)zombie_data + 0x84);
  piVar7[0xb] = (uint)*(byte *)((int)zombie_data + 0x167);
  piVar7[0xc] = (uint)*(byte *)((int)zombie_data + 0xd);
  piVar7[0xd] = (uint)*(byte *)((int)zombie_data + 0x164);
  piVar7[0xe] = (uint)*(byte *)((int)zombie_data + 9);
  piVar7[0x10] = DAT_10035880;
  piVar7[0xf] = *(int *)((int)zombie_data + 0x18c);
  return 0;
}



// Setting prototype: int create_zombie(void *zombie_data)

int cm_CreateZombie(void *zombie_data)

{
  void *pvVar1;
  int iVar2;
  uint32_t uVar3;
  int32_t iVar4;
  short sVar5;
  int iVar6;
  byte *local_4;
  
                    // 
                    // Creates a new zombie and initializes its data.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar1 = zombie_data;
  gm_LoadGameData(&local_4,(void **)0x0,(void **)0x0,*(uint32_t *)((int)zombie_data + 8));
  if (((local_4 == (byte *)0x0) || (*(ushort *)(local_4 + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)(local_4 + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
  if (*(char *)(DAT_100a8c30 + (uint)*local_4 * 0x24d) != '\x1d') {
    return -2;
  }
  if (*(void **)(local_4 + 0x65) == (void *)0x0) {
    return -3;
  }
  iVar2 = cm_ExValidateBuildingData(*(void **)(local_4 + 0x65),*(int *)((int)pvVar1 + 0xc));
  if (iVar2 == 0) {
    return -4;
  }
  gm_LoadGameData((void **)0x0,(void **)0x0,&zombie_data,*(uint32_t *)((int)pvVar1 + 4));
  if (zombie_data == (void *)0x0) {
    return -6;
  }
  iVar2 = *(int *)((int)pvVar1 + 0xc);
  if ((-1 < iVar2) && (iVar2 < 4)) {
    uVar3 = cm_ExIterateBuildingData(zombie_data,local_4,0,&LAB_10010700,iVar2);
    if (uVar3 == 0) {
      return -7;
    }
    *(undefined4 *)(uVar3 + 4) = *(undefined4 *)((int)zombie_data + 4);
    *(undefined2 *)(uVar3 + 8) = *(undefined2 *)((int)zombie_data + 0x50);
    sVar5 = *(short *)((int)pvVar1 + 0x11) + (short)DAT_10035880;
    *(undefined1 *)(uVar3 + 0xc) = 0xff;
    *(short *)(uVar3 + 10) = sVar5;
    iVar2 = 0;
    if (0 < *(int *)(&DAT_1002574c + *(int *)((int)pvVar1 + 0xc) * 4)) {
      iVar6 = 0;
      do {
        iVar2 = iVar2 + 1;
        *(undefined4 *)(*(int *)(uVar3 + 0x10) + iVar6) = 0xffffffff;
        iVar6 = iVar6 + 0x44;
      } while (iVar2 < *(int *)(&DAT_1002574c + *(int *)((int)pvVar1 + 0xc) * 4));
    }
    if (0 < *(int *)((int)pvVar1 + 0x13)) {
      gm_RemoveObjectNoKill
                (*(uint32_t *)((int)zombie_data + 4),
                 (uint)*(ushort *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),
                 *(int *)((int)pvVar1 + 0x13));
      iVar4 = __ftol();
      gm_AddObject((&DAT_100358a4)[(uint)*(ushort *)(local_4 + 0x27) * 0x87],
                   *(undefined2 *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),iVar4);
    }
    return 0;
  }
  return -5;
}



// Setting prototype: int update_zombie_data(void *zombie_data)

int cm_UpdateZombieData(void *zombie_data)

{
  void *building_data;
  void *pvVar1;
  int iVar2;
  int32_t iVar3;
  byte *local_4;
  
                    // 
                    // Updates the data for a zombie.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar1 = zombie_data;
  gm_LoadGameData(&local_4,(void **)0x0,(void **)0x0,*(uint32_t *)((int)zombie_data + 8));
  if (((local_4 == (byte *)0x0) || (*(ushort *)(local_4 + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)(local_4 + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
  if (*(char *)(DAT_100a8c30 + (uint)*local_4 * 0x24d) != '\x1d') {
    return -2;
  }
  building_data = *(void **)(local_4 + 0x65);
  if (building_data == (void *)0x0) {
    return -3;
  }
  iVar2 = cm_ExValidateBuildingData(building_data,*(int *)((int)pvVar1 + 0xc));
  if (iVar2 == 0) {
    return -4;
  }
  gm_LoadGameData((void **)0x0,(void **)0x0,&zombie_data,*(uint32_t *)((int)pvVar1 + 4));
  if (zombie_data == (void *)0x0) {
    return -6;
  }
  iVar2 = cm_ExGetBuildingDataPtr
                    (building_data,*(undefined4 *)((int)pvVar1 + 0xc),
                     *(undefined1 *)((int)pvVar1 + 0x10));
  if (iVar2 == 0) {
    return -7;
  }
  *(short *)(iVar2 + 10) = *(short *)(iVar2 + 10) + *(short *)((int)pvVar1 + 0x11);
  if (0 < *(int *)((int)pvVar1 + 0x13)) {
    gm_RemoveObjectNoKill
              (*(uint32_t *)((int)zombie_data + 4),
               (uint)*(ushort *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),
               *(int *)((int)pvVar1 + 0x13));
    iVar3 = __ftol();
    gm_AddObject((&DAT_100358a4)[(uint)*(ushort *)(local_4 + 0x27) * 0x87],
                 *(undefined2 *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),iVar3);
  }
  return 0;
}



// Setting prototype: int set_zombie_owner(void *zombie_data)

int cm_SetZombieOwner(void *zombie_data)

{
  void *building_data;
  void *pvVar1;
  int iVar2;
  undefined4 uVar3;
  undefined2 uVar4;
  void *local_4;
  
                    // 
                    // Sets the owner of a zombie.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar1 = zombie_data;
  uVar3 = 0xffffffff;
  uVar4 = 0xffff;
  gm_LoadGameData(&zombie_data,(void **)0x0,(void **)0x0,*(uint32_t *)((int)zombie_data + 8));
  if (((zombie_data == (void *)0x0) || (*(ushort *)((int)zombie_data + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)((int)zombie_data + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
                    // WARNING: Load size is inaccurate
  if (*(char *)(DAT_100a8c30 + (uint)*zombie_data * 0x24d) != '\x1d') {
    return -2;
  }
  building_data = *(void **)((int)zombie_data + 0x65);
  if (building_data == (void *)0x0) {
    return -3;
  }
  iVar2 = cm_ExValidateBuildingData(building_data,*(int *)((int)pvVar1 + 0xc));
  if (iVar2 == 0) {
    return -4;
  }
  if (*(uint32_t *)((int)pvVar1 + 4) != 0xffffffff) {
    gm_LoadGameData((void **)0x0,(void **)0x0,&local_4,*(uint32_t *)((int)pvVar1 + 4));
    if (local_4 == (void *)0x0) {
      return -6;
    }
    uVar3 = *(undefined4 *)((int)pvVar1 + 4);
    uVar4 = *(undefined2 *)((int)local_4 + 0x50);
  }
  iVar2 = cm_ExGetBuildingDataPtr
                    (building_data,*(undefined4 *)((int)pvVar1 + 0xc),
                     *(undefined1 *)((int)pvVar1 + 0x10));
  if (iVar2 == 0) {
    return -7;
  }
  *(undefined2 *)(iVar2 + 8) = uVar4;
  *(undefined4 *)(iVar2 + 4) = uVar3;
  return 0;
}



// Setting prototype: int set_zombie_state(void *zombie_data)

int cm_SetZombieState(void *zombie_data)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  void *local_4;
  
                    // 
                    // Sets the state of a zombie.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar3 = zombie_data;
  gm_LoadGameData(&zombie_data,(void **)0x0,(void **)0x0,*(uint32_t *)((int)zombie_data + 8));
  if (((zombie_data == (void *)0x0) || (*(ushort *)((int)zombie_data + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)((int)zombie_data + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
                    // WARNING: Load size is inaccurate
  if (*(char *)(DAT_100a8c30 + (uint)*zombie_data * 0x24d) != '\x1d') {
    return -2;
  }
  iVar1 = *(int *)((int)zombie_data + 0x65);
  if (iVar1 == 0) {
    return -3;
  }
  gm_LoadGameData((void **)0x0,(void **)0x0,&local_4,*(uint32_t *)((int)pvVar3 + 4));
  if (local_4 == (void *)0x0) {
    return -6;
  }
  iVar2 = *(int *)((int)pvVar3 + 0xc);
  if (iVar2 == 3) {
    if ((*(int *)(iVar1 + 0x14) != 0) && (2 < *(int *)(iVar1 + 4))) {
      *(undefined1 *)(iVar1 + 0x1b) = 1;
      *(undefined1 *)(iVar1 + 0x1a) = 1;
      *(undefined1 *)(iVar1 + 0x19) = 1;
      return 0;
    }
  }
  else if (iVar2 == 2) {
    if ((*(int *)(iVar1 + 0x10) != 0) && (1 < *(int *)(iVar1 + 4))) {
      *(undefined1 *)(iVar1 + 0x1a) = 1;
LAB_10011757:
      *(undefined1 *)(iVar1 + 0x19) = 1;
      return 0;
    }
  }
  else {
    if (iVar2 != 1) {
      return -8;
    }
    if (*(int *)(iVar1 + 0xc) != 0) goto LAB_10011757;
  }
  return -7;
}



// Setting prototype: int zombie_logic(void *zombie_data)

int cm_ZombieLogic(void *zombie_data)

{
  void *building_data;
  void *pvVar1;
  int iVar2;
  uint uVar3;
  
                    // 
                    // Implements the logic for a zombie, including updating its state based on
                    // various factors.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar1 = zombie_data;
  gm_LoadGameData(&zombie_data,(void **)0x0,(void **)0x0,*(uint32_t *)((int)zombie_data + 8));
  if (((zombie_data == (void *)0x0) || (*(ushort *)((int)zombie_data + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)((int)zombie_data + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
                    // WARNING: Load size is inaccurate
  if (*(char *)(DAT_100a8c30 + (uint)*zombie_data * 0x24d) != '\x1d') {
    return -2;
  }
  building_data = *(void **)((int)zombie_data + 0x65);
  if (building_data == (void *)0x0) {
    return -3;
  }
  iVar2 = cm_ExValidateBuildingData(building_data,*(int *)((int)pvVar1 + 0xc));
  if (iVar2 == 0) {
    return -4;
  }
  iVar2 = cm_ExGetBuildingDataPtr
                    (building_data,*(undefined4 *)((int)pvVar1 + 0xc),
                     *(undefined1 *)((int)pvVar1 + 0x10));
  if (iVar2 == 0) {
    return -7;
  }
  uVar3 = *(int *)((int)pvVar1 + 0x13) + (uint)*(byte *)(iVar2 + 0xc);
  uVar3 = uVar3 & ((int)uVar3 < 1) - 1;
  if (0xfe < (int)uVar3) {
    uVar3 = 0xff;
  }
  *(char *)(iVar2 + 0xc) = (char)uVar3;
  return 0;
}



// Setting prototype: int alloc_graveyard_worker(void *worker_data)

int cm_AllocGraveyardWorker(void *worker_data)

{
  void *pvVar1;
  int iVar2;
  
                    // 
                    // Allocates a graveyard worker.
                    // 
                    // Parameters:
                    //   worker_data: Pointer to the worker's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar1 = worker_data;
  gm_LoadGameData(&worker_data,(void **)0x0,(void **)0x0,*(uint32_t *)((int)worker_data + 8));
  if (((worker_data == (void *)0x0) || (*(ushort *)((int)worker_data + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)((int)worker_data + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
                    // WARNING: Load size is inaccurate
  if (*(char *)(DAT_100a8c30 + (uint)*worker_data * 0x24d) != '\x1d') {
    return -2;
  }
  if (*(int *)((int)worker_data + 0x65) == 0) {
    return -3;
  }
  iVar2 = cm_ExAllocGraveyard(worker_data,*(int *)((int)pvVar1 + 0x13));
  return ((iVar2 < 1) - 1 & 4) - 4;
}



// Setting prototype: int move_zombie(void *zombie_data)

int cm_ExMoveZombie(void *zombie_data)

{
  void *building_data;
  void *pvVar1;
  int iVar2;
  int32_t iVar3;
  int *piVar4;
  int *piVar5;
  int *piVar6;
  int *piVar7;
  byte *local_14;
  int *local_10;
  int *local_c;
  int local_8;
  uint32_t local_4;
  
                    // 
                    // Moves a zombie from one location to another within the graveyard.
                    // 
                    // Parameters:
                    //   zombie_data: Pointer to the zombie's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  pvVar1 = zombie_data;
                    // WARNING: Load size is inaccurate
  gm_LoadGameData((void **)0x0,(void **)0x0,&zombie_data,*zombie_data);
  if (zombie_data == (void *)0x0) {
    return -6;
  }
  gm_LoadGameData(&local_14,(void **)0x0,(void **)0x0,*(uint32_t *)((int)pvVar1 + 4));
  if (((local_14 == (byte *)0x0) || (*(ushort *)(local_14 + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)(local_14 + 0x27) * 0x10e == DAT_1003546c)) {
    return -1;
  }
  if (*(char *)(DAT_100a8c30 + (uint)*local_14 * 0x24d) != '\x1d') {
    return -2;
  }
  building_data = *(void **)(local_14 + 0x65);
  if (building_data == (void *)0x0) {
    return -3;
  }
  iVar2 = cm_ExValidateBuildingData(building_data,*(int *)((int)pvVar1 + 8));
  if (iVar2 == 0) {
    return -4;
  }
  iVar2 = cm_ExGetBuildingDataPtr
                    (building_data,*(undefined4 *)((int)pvVar1 + 8),
                     *(undefined1 *)((int)pvVar1 + 0xc));
  if ((iVar2 != 0) && (*(short *)(iVar2 + 8) == *(short *)((int)zombie_data + 0x50))) {
    piVar5 = *(int **)(iVar2 + 0x10);
    local_10 = *(int **)(&DAT_1002574c + *(int *)((int)pvVar1 + 8) * 4);
    local_8 = iVar2;
    local_4 = cm_ExIterateBuildingData
                        (zombie_data,local_14,0,&LAB_10010700,*(int *)((int)pvVar1 + 0xd));
    if (local_4 != 0) {
      piVar4 = *(int **)(local_4 + 0x10);
      local_c = piVar4 + *(int *)(&DAT_1002574c + *(int *)((int)pvVar1 + 0xd) * 4) * 0x11;
      local_10 = piVar5 + (int)local_10 * 0x11;
      for (; piVar4 < local_c; piVar4 = piVar4 + 0x11) {
        if (*piVar4 == -1) {
          while( true ) {
            if (local_10 <= piVar5) goto LAB_10011b0d;
            if (*piVar5 != -1) break;
            piVar5 = piVar5 + 0x11;
          }
          piVar6 = piVar5;
          piVar7 = piVar4;
          for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
            *piVar7 = *piVar6;
            piVar6 = piVar6 + 1;
            piVar7 = piVar7 + 1;
          }
          piVar6 = piVar5;
          for (iVar2 = 0x11; iVar2 != 0; iVar2 = iVar2 + -1) {
            *piVar6 = 0;
            piVar6 = piVar6 + 1;
          }
          *piVar5 = -1;
          iVar2 = local_8;
          if (local_10 <= piVar5) break;
        }
      }
LAB_10011b0d:
      *(undefined4 *)(local_4 + 4) = *(undefined4 *)(iVar2 + 4);
      *(undefined4 *)(iVar2 + 4) = 0xffffffff;
      *(undefined2 *)(local_4 + 8) = *(undefined2 *)(iVar2 + 8);
      *(undefined2 *)(iVar2 + 8) = 0xffff;
      *(short *)(local_4 + 10) = (short)DAT_10035880 + 10;
      *(undefined1 *)(local_4 + 0xc) = 0xff;
      *(undefined2 *)(iVar2 + 10) = 0xff;
      *(undefined4 *)((int)pvVar1 + 0x15) = DAT_10030b6c;
      if (0 < *(int *)((int)pvVar1 + 0x11)) {
        gm_RemoveObjectNoKill
                  (*(uint32_t *)((int)zombie_data + 4),
                   (uint)*(ushort *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),
                   *(int *)((int)pvVar1 + 0x11));
        iVar3 = __ftol();
        gm_AddObject((&DAT_100358a4)[(uint)*(ushort *)(local_14 + 0x27) * 0x87],
                     *(undefined2 *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),iVar3);
      }
      return 0;
    }
  }
  return -7;
}



// Setting prototype: uint32_t alloc_graveyard_worker_2(void *worker_data)

uint32_t handleAllocGraveyardWorker2(void *worker_data)

{
  ushort *puVar1;
  ushort uVar2;
  void *building_data;
  int iVar3;
  int *piVar4;
  short *psVar5;
  char *pcVar6;
  int *piVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  int iVar12;
  undefined4 *puVar13;
  ushort *puVar14;
  int *piVar15;
  undefined4 *puVar16;
  float fVar17;
  int local_c;
  byte *local_8;
  int local_4;
  
                    // 
                    // Allocates and initializes a graveyard worker.
                    // 
                    // Parameters:
                    //   worker_data: Pointer to the worker's data structure.
                    // 
                    // Return values:
                    //   The ID of the allocated worker, or 0xFFFF on failure.
                    // 
  if ((*(int *)((int)worker_data + 0x15) != 0x1b) && (*(int *)((int)worker_data + 0x15) != 0x1c)) {
    return 0xfffffffa;
  }
  iVar12 = 0;
  gm_LoadGameData(&local_8,(void **)0x0,(void **)0x0,*(uint32_t *)((int)worker_data + 8));
  if (((local_8 == (byte *)0x0) || (*(ushort *)(local_8 + 0x27) == 0xffff)) ||
     (&DAT_100358a0 + (uint)*(ushort *)(local_8 + 0x27) * 0x10e == DAT_1003546c)) {
    return 0xffffffff;
  }
  if (*(char *)(DAT_100a8c30 + (uint)*local_8 * 0x24d) != '\x1d') {
    return 0xfffffffe;
  }
  building_data = *(void **)(local_8 + 0x65);
  if (building_data == (void *)0x0) {
    return 0xfffffffd;
  }
  iVar3 = cm_ExValidateBuildingData(building_data,*(int *)((int)worker_data + 0xc));
  if (iVar3 == 0) {
    return 0xfffffffc;
  }
  local_4 = cm_ExGetBuildingDataPtr
                      (building_data,*(undefined4 *)((int)worker_data + 0xc),
                       *(undefined1 *)((int)worker_data + 0x10));
  if (local_4 == 0) {
    return 0xffff;
  }
  iVar3 = 0;
  if (0 < *(int *)(&DAT_1002574c + *(int *)((int)worker_data + 0xc) * 4)) {
    piVar7 = *(int **)(local_4 + 0x10);
    do {
      piVar4 = piVar7;
      if (*piVar4 == *(int *)((int)worker_data + 0x11)) break;
      iVar3 = iVar3 + 1;
      piVar7 = piVar4 + 0x11;
    } while (iVar3 < *(int *)(&DAT_1002574c + *(int *)((int)worker_data + 0xc) * 4));
    if ((piVar4 != (int *)0x0) && (*piVar4 == *(int *)((int)worker_data + 0x11))) {
      iVar3 = 0;
      psVar5 = &DAT_100358a0;
      do {
        if (*psVar5 == -1) break;
        psVar5 = psVar5 + 0x10e;
        iVar3 = iVar3 + 1;
      } while ((int)psVar5 < 0x1009aca0);
      if (iVar3 == 0x300) {
        iVar3 = 0;
        pcVar6 = &DAT_100358a2;
        do {
          if (*pcVar6 == '\x0f') break;
          pcVar6 = pcVar6 + 0x21c;
          iVar3 = iVar3 + 1;
        } while ((int)pcVar6 < 0x1009aca2);
        if (iVar3 == 0x300) {
          logMessage(s_D__Develop_DieGildeAddOn_game_fr_1002d48c,0x6ef,
                     s_gv_ExAllocGraveyardWorker__array_1002d4bc,1);
          return 0xffff;
        }
      }
      iVar11 = iVar3 * 0x21c;
      if ((&DAT_100358a2)[iVar11] == '\x0f') {
        DAT_10035434 = DAT_10035434 + -1;
      }
      puVar1 = &DAT_100358a0 + iVar3 * 0x10e;
      puVar14 = puVar1;
      for (iVar8 = 0x87; iVar8 != 0; iVar8 = iVar8 + -1) {
        puVar14[0] = 0;
        puVar14[1] = 0;
        puVar14 = puVar14 + 2;
      }
      *puVar1 = 0xffff;
      (&DAT_100358a4)[iVar3 * 0x87] = 0xffffffff;
      puVar13 = &DAT_100358fc + iVar3 * 0x87;
      for (iVar8 = 8; iVar8 != 0; iVar8 = iVar8 + -1) {
        *puVar13 = 0xffffffff;
        puVar13 = puVar13 + 1;
      }
      (&DAT_10035a10)[iVar3 * 0x87] = local_8;
      (&DAT_10035a0c)[iVar3 * 0x87] = local_8;
      DAT_10035434 = DAT_10035434 + 1;
      (&DAT_100358a4)[iVar3 * 0x87] = DAT_10030b6c;
      DAT_10030b6c = DAT_10030b6c + 1;
      *puVar1 = (ushort)iVar3;
      (&DAT_100358a2)[iVar11] = 0x14;
      *(undefined4 *)(iVar11 + 0x10035a90) = 0;
      (&DAT_10035ab0)[iVar3 * 0x87] = 0xffffffff;
      *(undefined1 *)(iVar11 + 0x10035ab5) = 0;
      *(undefined1 *)(iVar11 + 0x10035ab6) = 0;
      *(undefined1 *)(iVar11 + 0x10035ab7) = 0;
      *(undefined1 *)(iVar11 + 0x10035ab8) = 1;
      *(undefined4 *)(iVar11 + 0x10035a84) = 0x3f800000;
      (&DAT_100358a8)[iVar11] = 100;
      *(undefined2 *)(&DAT_100358aa + iVar11) = 0x10;
      (&DAT_10035a04)[iVar11] = 0;
      *(undefined1 *)(iVar11 + 0x10035a06) = 0;
      (&DAT_10035a05)[iVar11] = *(undefined1 *)((int)worker_data + 0x15);
      *(undefined1 *)(iVar11 + 0x10035a94) = 0;
      *(undefined4 *)(&DAT_10035a30 + iVar11) = 4;
      *(undefined4 *)(&DAT_10035a34 + iVar11) = 0;
      *(undefined1 *)(iVar11 + 0x100358ad) = 1;
      *(undefined4 *)(iVar11 + 0x10035a2c) = 0xffffffff;
      *(undefined4 *)(&DAT_10035aac + iVar11) = 0xffffffff;
      *(undefined2 *)(&DAT_100358f0 + iVar11) = 0x7fff;
      iVar3 = 0;
      do {
        *(byte *)(iVar3 + 0x80 + (int)puVar1) = *(byte *)((int)piVar4 + iVar3 + 0x24) >> 1;
        iVar3 = iVar3 + 1;
      } while (iVar3 < 5);
      *(char *)(iVar11 + 0x100358a9) = (char)piVar4[0xe];
      uVar9 = 0xffffffff;
      piVar7 = piVar4 + 1;
      do {
        piVar15 = piVar7;
        if (uVar9 == 0) break;
        uVar9 = uVar9 - 1;
        piVar15 = (int *)((int)piVar7 + 1);
        iVar3 = *piVar7;
        piVar7 = piVar15;
      } while ((char)iVar3 != '\0');
      uVar9 = ~uVar9;
      puVar13 = (undefined4 *)((int)piVar15 - uVar9);
      puVar16 = (undefined4 *)(&DAT_100358d0 + iVar11);
      for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
        *puVar16 = *puVar13;
        puVar13 = puVar13 + 1;
        puVar16 = puVar16 + 1;
      }
      for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
        *(undefined1 *)puVar16 = *(undefined1 *)puVar13;
        puVar13 = (undefined4 *)((int)puVar13 + 1);
        puVar16 = (undefined4 *)((int)puVar16 + 1);
      }
      uVar9 = 0xffffffff;
      piVar7 = piVar4 + 5;
      do {
        piVar15 = piVar7;
        if (uVar9 == 0) break;
        uVar9 = uVar9 - 1;
        piVar15 = (int *)((int)piVar7 + 1);
        iVar3 = *piVar7;
        piVar7 = piVar15;
      } while ((char)iVar3 != '\0');
      uVar9 = ~uVar9;
      puVar13 = (undefined4 *)((int)piVar15 - uVar9);
      puVar16 = (undefined4 *)(&DAT_100358e0 + iVar11);
      for (uVar10 = uVar9 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
        *puVar16 = *puVar13;
        puVar13 = puVar13 + 1;
        puVar16 = puVar16 + 1;
      }
      for (uVar9 = uVar9 & 3; uVar9 != 0; uVar9 = uVar9 - 1) {
        *(undefined1 *)puVar16 = *(undefined1 *)puVar13;
        puVar13 = (undefined4 *)((int)puVar13 + 1);
        puVar16 = (undefined4 *)((int)puVar16 + 1);
      }
      *(undefined4 *)(iVar11 + 0x100358b0) = 0;
      fVar17 = get_random_float();
      *(undefined4 *)(iVar11 + 0x100358b8) = 0;
      *(undefined4 *)(iVar11 + 0x100358bc) = 0x447a0000;
      *(undefined4 *)(&DAT_100358c0 + iVar11) = 0;
      *(undefined4 *)(iVar11 + 0x100358c4) = 0;
      *(undefined2 *)(&DAT_100358c8 + iVar11) = 0;
      *(undefined4 *)(iVar11 + 0x100358cc) = 0;
      local_c = 0;
      iVar3 = 0;
      *(float *)(iVar11 + 0x100358b4) = 1000.0 / (fVar17 * 4.0 + 8.0);
      do {
        uVar2 = *puVar1;
        iVar11 = get_random_number(0x40);
        (&DAT_1014d8e0)[(uint)uVar2 + iVar3] = 0;
        (&DAT_100a9820)[(uint)uVar2 + iVar3] = (char)iVar11 + -0x20;
        iVar11 = (uint)*puVar1 * 0x300 + local_c;
        iVar8 = get_random_number(0x40);
        iVar3 = iVar3 + 0x300;
        local_c = local_c + 1;
        (&DAT_100a9820)[iVar11] = (char)iVar8 + -0x20;
        (&DAT_1014d8e0)[iVar11] = 0;
      } while (iVar3 < 0x90000);
      if (*piVar4 == *(int *)(local_4 + 4)) {
        if (0 < *(int *)(&DAT_1002574c + *(int *)((int)worker_data + 0xc) * 4)) {
          piVar7 = *(int **)(local_4 + 0x10);
          do {
            if ((*piVar7 != -1) && (*piVar7 != *piVar4)) {
              *(int *)(local_4 + 4) = *piVar7;
              goto LAB_10011fcd;
            }
            iVar12 = iVar12 + 1;
            piVar7 = piVar7 + 0x11;
          } while (iVar12 < *(int *)(&DAT_1002574c + *(int *)((int)worker_data + 0xc) * 4));
        }
        *(undefined4 *)(local_4 + 4) = 0xffffffff;
        *(undefined2 *)(local_4 + 8) = 0xffff;
      }
LAB_10011fcd:
      piVar7 = piVar4;
      for (iVar12 = 0x11; iVar12 != 0; iVar12 = iVar12 + -1) {
        *piVar7 = 0;
        piVar7 = piVar7 + 1;
      }
      *piVar4 = -1;
      return (uint)*puVar1;
    }
  }
  return 0xffff;
}



// Setting prototype: int load_graveyard_data(void *file_handle, void *building_type_data)

int handleLoadGraveyardData(void *file_handle,void *building_type_data)

{
  bool bVar1;
  void *buffer;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  undefined3 extraout_var_14;
  undefined3 extraout_var_15;
  undefined3 extraout_var_16;
  undefined3 extraout_var_17;
  undefined3 extraout_var_18;
  undefined3 extraout_var_19;
  undefined3 extraout_var_20;
  void *pvVar2;
  int iVar3;
  void *pvVar4;
  
                    // 
                    // Loads graveyard data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    //   building_type_data: Pointer to the building type data for the graveyard.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  buffer = (void *)cm_ExAllocGraveyardField(building_type_data);
  if (buffer == (void *)0x0) {
    return 0;
  }
  bVar1 = handleReadFileData(buffer,4,1,file_handle);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((int *)((int)buffer + 4),4,1,file_handle);
  if (CONCAT31(extraout_var_00,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)buffer + 0x18),1,1,file_handle);
  if (CONCAT31(extraout_var_01,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)buffer + 0x19),1,1,file_handle);
  if (CONCAT31(extraout_var_02,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)buffer + 0x1a),1,1,file_handle);
  if (CONCAT31(extraout_var_03,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)buffer + 0x1b),1,1,file_handle);
  if (CONCAT31(extraout_var_04,bVar1) == 0) {
    return 0;
  }
  pvVar2 = *(void **)((int)buffer + 0x20);
  building_type_data = (void *)0x0;
  if (0 < *(int *)(&DAT_1002576c + *(int *)((int)buffer + 4) * 4)) {
    pvVar4 = (void *)((int)pvVar2 + 0x14);
    do {
      bVar1 = handleReadFileData(pvVar2,4,1,file_handle);
      if (CONCAT31(extraout_var_05,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + -0x10),0x10,1,file_handle);
      if (CONCAT31(extraout_var_06,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData(pvVar4,0x10,1,file_handle);
      if (CONCAT31(extraout_var_07,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x10),5,1,file_handle);
      if (CONCAT31(extraout_var_08,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x18),4,1,file_handle);
      if (CONCAT31(extraout_var_09,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x1c),4,1,file_handle);
      if (CONCAT31(extraout_var_10,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x20),4,1,file_handle);
      if (CONCAT31(extraout_var_11,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x24),4,1,file_handle);
      if (CONCAT31(extraout_var_12,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x28),4,1,file_handle);
      if (CONCAT31(extraout_var_13,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 0x2c),4,1,file_handle);
      if (CONCAT31(extraout_var_14,bVar1) == 0) {
        return 0;
      }
      building_type_data = (void *)((int)building_type_data + 1);
      pvVar2 = (void *)((int)pvVar2 + 0x44);
      pvVar4 = (void *)((int)pvVar4 + 0x44);
    } while ((int)building_type_data < *(int *)(&DAT_1002576c + *(int *)((int)buffer + 4) * 4));
  }
  pvVar2 = *(void **)((int)buffer + 0x1c);
  iVar3 = 0;
  if (0 < *(int *)(&DAT_1002575c + *(int *)((int)buffer + 4) * 4)) {
    pvVar4 = (void *)((int)pvVar2 + 8);
    do {
      bVar1 = handleReadFileData(pvVar2,4,1,file_handle);
      if (CONCAT31(extraout_var_15,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + -4),4,1,file_handle);
      if (CONCAT31(extraout_var_16,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData(pvVar4,2,1,file_handle);
      if (CONCAT31(extraout_var_17,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 2),2,1,file_handle);
      if (CONCAT31(extraout_var_18,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)pvVar4 + 4),1,1,file_handle);
      if (CONCAT31(extraout_var_19,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData(&building_type_data,4,1,file_handle);
      if (CONCAT31(extraout_var_20,bVar1) == 0) {
        return 0;
      }
      pvVar2 = (void *)((int)pvVar2 + 0x14);
      iVar3 = iVar3 + 1;
      *(int *)((int)pvVar4 + 8) = *(int *)((int)buffer + 0x20) + (int)building_type_data * 0x44;
      pvVar4 = (void *)((int)pvVar4 + 0x14);
    } while (iVar3 < *(int *)(&DAT_1002575c + *(int *)((int)buffer + 4) * 4));
  }
  return 1;
}



// Setting prototype: void player_init(int init_type, uint32_t player_id, uint16_t player_type, void
// *player_data)

void handlePlayerInit(int init_type,uint32_t player_id,uint16_t player_type,void *player_data)

{
  int iVar1;
  int32_t iVar2;
  int iVar3;
  undefined4 *puVar4;
  
                    // 
                    // Initializes a player's data structure.
                    // 
                    // Parameters:
                    //   init_type: The type of initialization.
                    //   player_id: The ID of the player.
                    //   player_type: The type of player.
                    //   player_data: Pointer to the player's data structure.
                    // 
  if (init_type == 0x15) {
    *(uint *)((int)player_data + 0x1cc) = *(uint *)((int)player_data + 0x1cc) | 0x1000;
    handleRegisterPlayerForAmt(*(uint32_t *)((int)player_data + 4));
  }
  else {
    *(uint *)((int)player_data + 0x1cc) = *(uint *)((int)player_data + 0x1cc) | 0x2000;
    handleUnregisterPlayerFromAmt(*(uint32_t *)((int)player_data + 4));
  }
  *(uint16_t *)((int)player_data + 10) = player_type;
  _player_type = &DAT_100a9820;
  *(undefined1 *)((int)player_data + 0xc) = 0;
  do {
    iVar3 = 0;
    do {
      iVar1 = get_random_number(0x40);
      _player_type[iVar3] = (char)iVar1 + -0x20;
      _player_type[iVar3 + 0xa40c0] = 0;
      iVar3 = iVar3 + 1;
    } while (iVar3 < 0x300);
    _player_type = _player_type + 0x300;
  } while ((int)_player_type < 0x10139820);
  *(undefined2 *)((int)player_data + 0x50) = 0x7fff;
  *(undefined4 *)((int)player_data + 0x7c) = 0;
  *(undefined1 *)((int)player_data + 0x58) = 0;
  puVar4 = (undefined4 *)((int)player_data + 0x5c);
  for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {
    *puVar4 = 0xffffffff;
    puVar4 = puVar4 + 1;
  }
  *(undefined4 *)((int)player_data + 0x170) = 0;
  *(undefined4 *)((int)player_data + 0x16c) = 0;
  *(undefined4 *)((int)player_data + 0x1c) = 0x447a0000;
  *(undefined4 *)((int)player_data + 0x14) = 0x3f800000;
  *(undefined4 *)((int)player_data + 0x20) = 0x41400000;
  *(undefined4 *)((int)player_data + 0x10) = 0x43a50000;
  *(undefined4 *)((int)player_data + 0x18) = 0x447a0000;
  iVar3 = 0;
  do {
    get_random_number(0x2a);
    iVar2 = __ftol();
    *(char *)(iVar3 + 0x80 + (int)player_data) = (char)iVar2;
    iVar3 = iVar3 + 1;
  } while (iVar3 < 5);
  *(undefined1 *)((int)player_data + 0xd) = 9;
  gm_AddObject(*(undefined4 *)((int)player_data + 4),
               *(undefined2 *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4),16000000);
  get_random_number(2);
  *(undefined1 *)((int)player_data + 2) = 3;
  return;
}



// Setting prototype: bool read_file_data(void *buffer, int element_size, int element_count, void
// *file_data)

bool handleReadFileData(void *buffer,int element_size,int element_count,void *file_data)

{
  uint32_t uVar1;
  
                    // 
                    // Reads data from a file using the VFS (Virtual File System) read function.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the destination buffer.
                    //   element_size: The size of each element to read.
                    //   element_count: The number of elements to read.
                    //   file_data: Pointer to the VFS file data structure.
                    // 
                    // Return values:
                    //   True if data was read successfully, false otherwise.
                    // 
  uVar1 = vfs_read(buffer,element_size,element_count,file_data);
  return uVar1 != 0;
}



// Setting prototype: int load_player_data(void *file_handle, void *player_data)

int handleLoadPlayerData(void *file_handle,void *player_data)

{
  bool bVar1;
  void *buffer;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  undefined3 extraout_var_14;
  undefined3 extraout_var_15;
  undefined3 extraout_var_16;
  undefined3 extraout_var_17;
  undefined3 extraout_var_18;
  undefined3 extraout_var_19;
  undefined3 extraout_var_20;
  undefined3 extraout_var_21;
  void *buffer_00;
  int iVar2;
  
                    // 
                    // Loads player data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  buffer = (void *)mAlloc(0xe100,s_ls_tmp_1002d4fc);
  bVar1 = handleReadFileData(player_data,4,1,file_handle);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    return 0;
  }
                    // WARNING: Load size is inaccurate
  DAT_1002d4ec = *player_data;
  bVar1 = handleReadFileData((void *)((int)player_data + 4),1,1,file_handle);
  if (CONCAT31(extraout_var_00,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)player_data + 5),0x20,1,file_handle);
  if (CONCAT31(extraout_var_01,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)player_data + 0x28),8,1,file_handle);
  if (CONCAT31(extraout_var_02,bVar1) == 0) {
    return 0;
  }
  bVar1 = handleReadFileData((void *)((int)player_data + 0x30),1,1,file_handle);
  if (CONCAT31(extraout_var_03,bVar1) == 0) {
    return 0;
  }
  if ((0x10032 < DAT_1002d4ec) &&
     (bVar1 = handleReadFileData((void *)((int)player_data + 0x31),1,1,file_handle),
     CONCAT31(extraout_var_04,bVar1) == 0)) {
    return 0;
  }
  if (0x10027 < DAT_1002d4ec) {
    bVar1 = handleReadFileData((void *)((int)player_data + 0x32),0xe,1,file_handle);
    if (CONCAT31(extraout_var_05,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x40),0x10,1,file_handle);
    if (CONCAT31(extraout_var_06,bVar1) == 0) {
      return 0;
    }
    if (0x10053 < DAT_1002d4ec) {
      bVar1 = handleReadFileData((void *)((int)player_data + 0x50),0x10,1,file_handle);
      if (CONCAT31(extraout_var_07,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)player_data + 99),1,1,file_handle);
      if (CONCAT31(extraout_var_08,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)player_data + 100),4,1,file_handle);
      if (CONCAT31(extraout_var_09,bVar1) == 0) {
        return 0;
      }
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x60),1,1,file_handle);
    if (CONCAT31(extraout_var_10,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x61),1,1,file_handle);
    if (CONCAT31(extraout_var_11,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x62),1,1,file_handle);
    if (CONCAT31(extraout_var_12,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x68),4,1,file_handle);
    if (CONCAT31(extraout_var_13,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x6c),1,1,file_handle);
    if (CONCAT31(extraout_var_14,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)player_data + 0x6d),1,1,file_handle);
    if (CONCAT31(extraout_var_15,bVar1) == 0) {
      return 0;
    }
    if (DAT_1002d4ec < 0x1002b) {
      *(undefined4 *)((int)player_data + 0x70) = 0xffffffff;
      *(undefined4 *)((int)player_data + 0x74) = 0xffffffff;
    }
    else {
      bVar1 = handleReadFileData((void *)((int)player_data + 0x70),4,1,file_handle);
      if (CONCAT31(extraout_var_16,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)player_data + 0x74),4,1,file_handle);
      if (CONCAT31(extraout_var_17,bVar1) == 0) {
        return 0;
      }
    }
    if (0x10033 < DAT_1002d4ec) {
      iVar2 = 0;
      buffer_00 = (void *)((int)player_data + 0x78);
      do {
        bVar1 = handleReadFileData(buffer_00,4,1,file_handle);
        if (CONCAT31(extraout_var_18,bVar1) == 0) {
          return 0;
        }
        iVar2 = iVar2 + 1;
        buffer_00 = (void *)((int)buffer_00 + 4);
      } while (iVar2 < 8);
    }
    bVar1 = handleReadFileData(buffer,0xe100,1,file_handle);
    if (CONCAT31(extraout_var_19,bVar1) == 0) {
      return 0;
    }
  }
  if (buffer != (void *)0x0) {
    m_free(buffer);
  }
  if (0x10024 < DAT_1002d4ec) {
    if (DAT_1002d4ec < 0x10038) {
      *(undefined4 *)((int)player_data + 0x98) = 2;
    }
    else {
      bVar1 = handleReadFileData((void *)((int)player_data + 0x98),4,1,file_handle);
      if (CONCAT31(extraout_var_20,bVar1) == 0) {
        return 0;
      }
    }
    if (DAT_1002d4ec < 0x10039) {
      *(undefined4 *)((int)player_data + 0x9c) = s_Savegame_1002d4f0._0_4_;
      *(undefined4 *)((int)player_data + 0xa0) = s_Savegame_1002d4f0._4_4_;
      *(char *)((int)player_data + 0xa4) = s_Savegame_1002d4f0[8];
    }
    else {
      bVar1 = handleReadFileData((void *)((int)player_data + 0x9c),0x60,1,file_handle);
      if (CONCAT31(extraout_var_21,bVar1) == 0) {
        return 0;
      }
    }
    return 1;
  }
  return 0;
}



// Setting prototype: int load_building_data(void *file_handle)

int handleLoadBuildingData(void *file_handle)

{
  void *buffer;
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  int iVar2;
  int iVar3;
  int local_4;
  
                    // 
                    // Loads building data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  handleLoadGameData3();
  bVar1 = handleReadFileData(&local_4,4,1,file_handle);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    return 0;
  }
  iVar3 = 0;
  if (0 < local_4) {
    iVar2 = 0;
    do {
      buffer = (void *)(iVar2 + DAT_100a8c34);
      bVar1 = handleReadFileData(buffer,2,1,file_handle);
      if (CONCAT31(extraout_var_00,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 2),4,1,file_handle);
      if (CONCAT31(extraout_var_01,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 6),4,1,file_handle);
      if (CONCAT31(extraout_var_02,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 10),4,1,file_handle);
      if (CONCAT31(extraout_var_03,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 0xe),4,1,file_handle);
      if (CONCAT31(extraout_var_04,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 0x12),1,1,file_handle);
      if (CONCAT31(extraout_var_05,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 0x13),1,1,file_handle);
      if (CONCAT31(extraout_var_06,bVar1) == 0) {
        return 0;
      }
      bVar1 = handleReadFileData((void *)((int)buffer + 0x1c),0x1f,1,file_handle);
      if (CONCAT31(extraout_var_07,bVar1) == 0) {
        return 0;
      }
      iVar3 = iVar3 + 1;
      iVar2 = iVar2 + 0x43;
    } while (iVar3 < local_4);
  }
  DAT_10035450 = local_4;
  return 1;
}



// Setting prototype: int load_game_data(void *file_handle)

int handleLoadGameData(void *file_handle)

{
  int *buffer;
  uint *puVar1;
  char *buffer_00;
  char cVar2;
  void *file_data;
  bool bVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  undefined3 extraout_var_14;
  undefined3 extraout_var_15;
  undefined3 extraout_var_16;
  undefined3 extraout_var_17;
  undefined3 extraout_var_18;
  undefined3 extraout_var_19;
  undefined3 extraout_var_20;
  undefined4 uVar4;
  undefined3 extraout_var_21;
  undefined3 extraout_var_22;
  undefined3 extraout_var_23;
  undefined3 extraout_var_24;
  undefined3 extraout_var_25;
  undefined3 extraout_var_26;
  undefined3 extraout_var_27;
  undefined3 extraout_var_28;
  undefined3 extraout_var_29;
  undefined3 extraout_var_30;
  undefined4 *puVar5;
  undefined3 extraout_var_31;
  undefined3 extraout_var_32;
  undefined3 extraout_var_33;
  undefined3 extraout_var_34;
  undefined3 extraout_var_35;
  undefined3 extraout_var_36;
  int iVar6;
  int iVar7;
  int local_c;
  int local_8;
  undefined1 local_4 [4];
  
                    // 
                    // Loads game data from a file.
                    // This function reads various game-related structures, including player data,
                    // building data, and other game entities.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  file_data = file_handle;
  handleLoadGameData2();
  bVar3 = handleReadFileData(&local_8,4,1,file_handle);
  if (CONCAT31(extraout_var,bVar3) == 0) {
    return 0;
  }
  local_c = 0;
  if (0 < local_8) {
    file_handle = (void *)0x0;
    do {
      buffer_00 = (char *)((int)file_handle + DAT_1014d8c0);
      bVar3 = handleReadFileData(buffer_00,1,1,file_data);
      if (CONCAT31(extraout_var_00,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 1,4,1,file_data);
      if (CONCAT31(extraout_var_01,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 5,0x20,1,file_data);
      if (CONCAT31(extraout_var_02,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x25,2,1,file_data);
      if (CONCAT31(extraout_var_03,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x27,2,1,file_data);
      if (CONCAT31(extraout_var_04,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x29,2,1,file_data);
      if (CONCAT31(extraout_var_05,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x2b,4,1,file_data);
      if (CONCAT31(extraout_var_06,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x2f,1,1,file_data);
      if (CONCAT31(extraout_var_07,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x34,1,1,file_data);
      if (CONCAT31(extraout_var_08,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x35,4,1,file_data);
      if (CONCAT31(extraout_var_09,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x39,4,1,file_data);
      if (CONCAT31(extraout_var_10,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x3d,4,1,file_data);
      if (CONCAT31(extraout_var_11,bVar3) == 0) {
        return 0;
      }
      buffer = (int *)(buffer_00 + 0x41);
      bVar3 = handleReadFileData(buffer,4,1,file_data);
      if (CONCAT31(extraout_var_12,bVar3) == 0) {
        return 0;
      }
      if (4 < *buffer) {
        *buffer = 2;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x45,4,1,file_data);
      if (CONCAT31(extraout_var_13,bVar3) == 0) {
        return 0;
      }
      if ((0x10027 < DAT_1002d4ec) &&
         (bVar3 = handleReadFileData(buffer_00 + 0x49,4,1,file_data),
         CONCAT31(extraout_var_14,bVar3) == 0)) {
        return 0;
      }
      if ((DAT_1002d4ec < 0x10032) &&
         (bVar3 = handleReadFileData(local_4,4,1,file_data), CONCAT31(extraout_var_15,bVar3) == 0))
      {
        return 0;
      }
      if (0x10056 < DAT_1002d4ec) {
        bVar3 = handleReadFileData(buffer_00 + 0x4d,4,1,file_data);
        if (CONCAT31(extraout_var_16,bVar3) == 0) {
          return 0;
        }
        bVar3 = handleReadFileData(buffer_00 + 0x51,4,1,file_data);
        if (CONCAT31(extraout_var_17,bVar3) == 0) {
          return 0;
        }
        bVar3 = handleReadFileData(buffer_00 + 0x55,4,1,file_data);
        if (CONCAT31(extraout_var_18,bVar3) == 0) {
          return 0;
        }
      }
      bVar3 = handleReadFileData(buffer_00 + 0x5a,2,1,file_data);
      if (CONCAT31(extraout_var_19,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData(buffer_00 + 0x5c,1,1,file_data);
      if (CONCAT31(extraout_var_20,bVar3) == 0) {
        return 0;
      }
      cVar2 = *buffer_00;
      if (cVar2 == '\x1e') {
        uVar4 = mAlloc(0x600,s_f3g_PlantMap_1002d510);
        *(undefined4 *)(buffer_00 + 0x71) = uVar4;
        iVar7 = 0;
        do {
          bVar3 = handleReadFileData((void *)(iVar7 + *(int *)(buffer_00 + 0x71)),4,1,file_data);
          if (CONCAT31(extraout_var_21,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 4 + *(int *)(buffer_00 + 0x71)),4,1,file_data)
          ;
          if (CONCAT31(extraout_var_22,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 8 + *(int *)(buffer_00 + 0x71)),1,1,file_data)
          ;
          if (CONCAT31(extraout_var_23,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 9 + *(int *)(buffer_00 + 0x71)),1,1,file_data)
          ;
          if (CONCAT31(extraout_var_24,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 10 + *(int *)(buffer_00 + 0x71)),2,1,file_data
                                    );
          if (CONCAT31(extraout_var_25,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 0x10 + *(int *)(buffer_00 + 0x71)),4,1,
                                     file_data);
          if (CONCAT31(extraout_var_26,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 0xc + *(int *)(buffer_00 + 0x71)),1,1,
                                     file_data);
          if (CONCAT31(extraout_var_27,bVar3) == 0) {
            return 0;
          }
          bVar3 = handleReadFileData((void *)(iVar7 + 0xd + *(int *)(buffer_00 + 0x71)),1,1,
                                     file_data);
          if (CONCAT31(extraout_var_28,bVar3) == 0) {
            return 0;
          }
          iVar6 = iVar7 + 0x18;
          *(undefined4 *)(iVar7 + 0x14 + *(int *)(buffer_00 + 0x71)) = 0;
          iVar7 = iVar6;
        } while (iVar6 < 0x600);
      }
      else {
        if (((cVar2 == 'H') || (cVar2 == 'I')) || (cVar2 == 'J')) {
          if (DAT_1002d4ec < 0x10047) {
            bVar3 = handleReadFileData(buffer_00 + 0x65,0x30,1,file_data);
            if (CONCAT31(extraout_var_31,bVar3) == 0) {
              return 0;
            }
            uVar4 = cm_ExAllocGraveyardField(buffer_00);
            *(undefined4 *)(buffer_00 + 0x65) = uVar4;
            goto LAB_10012d72;
          }
          iVar7 = handleLoadGraveyardData(file_data,buffer_00);
        }
        else if (((cVar2 == 'K') || (cVar2 == 'L')) || (cVar2 == 'M')) {
          if (DAT_1002d4ec < 0x10049) {
            bVar3 = handleReadFileData(buffer_00 + 0x65,0x30,1,file_data);
            if (CONCAT31(extraout_var_30,bVar3) == 0) {
              return 0;
            }
            puVar5 = (undefined4 *)mAlloc(0x3c,s_AHM_INFO_1002d504);
            *(undefined4 **)(buffer_00 + 0x65) = puVar5;
            *puVar5 = 0xffffffff;
            goto LAB_10012d72;
          }
          iVar7 = load_alchemist_data(file_data,buffer_00);
        }
        else {
          bVar3 = handleReadFileData(buffer_00 + 0x65,0x30,1,file_data);
          iVar7 = CONCAT31(extraout_var_29,bVar3);
        }
        if (iVar7 == 0) {
          return 0;
        }
      }
LAB_10012d72:
      if (DAT_1002d4ec < 0x10043) {
        puVar1 = (uint *)(buffer_00 + 0x99);
        *puVar1 = 0;
        buffer_00[0x9d] = '\0';
        buffer_00[0x9e] = '\0';
        buffer_00[0x9f] = '\0';
        buffer_00[0xa0] = '\0';
        buffer_00[0xa1] = '\0';
        buffer_00[0xa2] = '\0';
        buffer_00[0xa3] = '\0';
        buffer_00[0xa4] = '\0';
        buffer_00[0xa5] = '\0';
        buffer_00[0xa6] = '\0';
        buffer_00[0xa7] = '\0';
        buffer_00[0xa8] = '\0';
        buffer_00[0xa5] = -1;
        buffer_00[0xa6] = -1;
        buffer_00[0xa7] = -1;
        buffer_00[0xa8] = -1;
        *puVar1 = *puVar1 | 1;
      }
      else {
        bVar3 = handleReadFileData(buffer_00 + 0x99,0x10,1,file_data);
        if (CONCAT31(extraout_var_32,bVar3) == 0) {
          return 0;
        }
      }
      buffer_00[0x30] = -0x78;
      buffer_00[0x31] = '\x13';
      buffer_00[0x32] = '\0';
      buffer_00[0x33] = '\0';
      buffer_00[0x95] = -1;
      buffer_00[0x96] = -1;
      buffer_00[0x97] = -1;
      buffer_00[0x98] = -1;
      local_c = local_c + 1;
      file_handle = (void *)((int)file_handle + 0xa9);
    } while (local_c < local_8);
  }
  bVar3 = handleReadFileData(&DAT_101de454,4,1,file_data);
  if (CONCAT31(extraout_var_33,bVar3) == 0) {
    return 0;
  }
  DAT_101de55c = realloc_internal(DAT_101de55c,DAT_101de454 * 0x60);
  iVar7 = 0;
  if (0 < DAT_101de454) {
    iVar6 = 0;
    do {
      bVar3 = handleReadFileData((void *)(iVar6 + DAT_101de55c),0x40,1,file_data);
      if (CONCAT31(extraout_var_34,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData((void *)(iVar6 + 0x40 + DAT_101de55c),0x10,1,file_data);
      if (CONCAT31(extraout_var_35,bVar3) == 0) {
        return 0;
      }
      bVar3 = handleReadFileData((void *)(iVar6 + 0x50 + DAT_101de55c),0x10,1,file_data);
      if (CONCAT31(extraout_var_36,bVar3) == 0) {
        return 0;
      }
      iVar7 = iVar7 + 1;
      iVar6 = iVar6 + 0x60;
    } while (iVar7 < DAT_101de454);
  }
  return 1;
}



// Setting prototype: int load_dynasty_data(void *file_handle)

int handleLoadDynastyData(void *file_handle)

{
  void *file_data;
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  undefined3 extraout_var_14;
  undefined3 extraout_var_15;
  undefined3 extraout_var_16;
  undefined3 extraout_var_17;
  undefined3 extraout_var_18;
  undefined3 extraout_var_19;
  undefined3 extraout_var_20;
  undefined3 extraout_var_21;
  undefined3 extraout_var_22;
  undefined3 extraout_var_23;
  undefined3 extraout_var_24;
  undefined3 extraout_var_25;
  undefined3 extraout_var_26;
  undefined3 extraout_var_27;
  int iVar2;
  int iVar3;
  undefined *buffer;
  
                    // 
                    // Loads dynasty data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  file_data = file_handle;
  buffer = &DAT_1009aca2;
  while( true ) {
    bVar1 = handleReadFileData(buffer + -2,2,1,file_data);
    if (((((((CONCAT31(extraout_var,bVar1) == 0) ||
            (bVar1 = handleReadFileData(buffer,0x10,1,file_data),
            CONCAT31(extraout_var_00,bVar1) == 0)) ||
           (bVar1 = handleReadFileData(buffer + 0x12,4,1,file_data),
           CONCAT31(extraout_var_01,bVar1) == 0)) ||
          (((0x1002b < DAT_1002d4ec &&
            (bVar1 = handleReadFileData(buffer + 0x26,4,1,file_data),
            CONCAT31(extraout_var_02,bVar1) == 0)) ||
           ((bVar1 = handleReadFileData(buffer + 0x1a,4,1,file_data),
            CONCAT31(extraout_var_03,bVar1) == 0 ||
            ((bVar1 = handleReadFileData(buffer + 0x1e,4,1,file_data),
             CONCAT31(extraout_var_04,bVar1) == 0 ||
             (bVar1 = handleReadFileData(buffer + 0x2a,4,1,file_data),
             CONCAT31(extraout_var_05,bVar1) == 0)))))))) ||
         ((bVar1 = handleReadFileData(buffer + 0x2e,4,1,file_data),
          CONCAT31(extraout_var_06,bVar1) == 0 ||
          ((((bVar1 = handleReadFileData(buffer + 0x32,4,1,file_data),
             CONCAT31(extraout_var_07,bVar1) == 0 ||
             (bVar1 = handleReadFileData(buffer + 0x36,4,1,file_data),
             CONCAT31(extraout_var_08,bVar1) == 0)) ||
            (bVar1 = handleReadFileData(buffer + 0x3e,4,1,file_data),
            CONCAT31(extraout_var_09,bVar1) == 0)) ||
           ((bVar1 = handleReadFileData(buffer + 0x42,4,1,file_data),
            CONCAT31(extraout_var_10,bVar1) == 0 ||
            (bVar1 = handleReadFileData(buffer + 0x46,4,1,file_data),
            CONCAT31(extraout_var_11,bVar1) == 0)))))))) ||
        ((bVar1 = handleReadFileData(buffer + 0x4a,4,1,file_data),
         CONCAT31(extraout_var_12,bVar1) == 0 ||
         (bVar1 = handleReadFileData(buffer + 0x4e,4,1,file_data),
         CONCAT31(extraout_var_13,bVar1) == 0)))) ||
       ((0x10013 < DAT_1002d4ec &&
        (((bVar1 = handleReadFileData(buffer + 0x52,4,1,file_data),
          CONCAT31(extraout_var_14,bVar1) == 0 ||
          (bVar1 = handleReadFileData(buffer + 0x56,4,1,file_data),
          CONCAT31(extraout_var_15,bVar1) == 0)) ||
         (((bVar1 = handleReadFileData(buffer + 0x5a,4,1,file_data),
           CONCAT31(extraout_var_16,bVar1) == 0 ||
           (((bVar1 = handleReadFileData(buffer + 0x3a,4,1,file_data),
             CONCAT31(extraout_var_17,bVar1) == 0 ||
             (bVar1 = handleReadFileData(buffer + 0x62,4,1,file_data),
             CONCAT31(extraout_var_18,bVar1) == 0)) ||
            (bVar1 = handleReadFileData(buffer + 0x66,4,1,file_data),
            CONCAT31(extraout_var_19,bVar1) == 0)))) ||
          (bVar1 = handleReadFileData(buffer + 0x6a,4,1,file_data),
          CONCAT31(extraout_var_20,bVar1) == 0)))))))) {
      return 0;
    }
    iVar2 = DAT_1002d4ec;
    if (DAT_1002d4ec < 0x10056) {
      *(undefined4 *)(buffer + 0x5e) = 0x3f800000;
    }
    else {
      bVar1 = handleReadFileData(buffer + 0x5e,4,1,file_data);
      iVar2 = DAT_1002d4ec;
      if (CONCAT31(extraout_var_21,bVar1) == 0) {
        return 0;
      }
    }
    if (0x10014 < iVar2) {
      iVar3 = 0;
      iVar2 = ((0x10045 < iVar2) - 1 & 0xfffffffd) + 0x11;
      if (0 < iVar2) {
        file_handle = buffer + 0x72;
        do {
          bVar1 = handleReadFileData(file_handle,1,1,file_data);
          if (CONCAT31(extraout_var_22,bVar1) == 0) {
            return 0;
          }
          iVar3 = iVar3 + 1;
          file_handle = (void *)((int)file_handle + 1);
        } while (iVar3 < iVar2);
      }
    }
    bVar1 = handleReadFileData(buffer + 0x86,4,1,file_data);
    if (CONCAT31(extraout_var_23,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(buffer + 0x8a,0x10,1,file_data);
    if (CONCAT31(extraout_var_24,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(buffer + 0x9a,0xc,1,file_data);
    if (CONCAT31(extraout_var_25,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(buffer + 0xa6,4,1,file_data);
    if (CONCAT31(extraout_var_26,bVar1) == 0) {
      return 0;
    }
    if ((0x10017 < DAT_1002d4ec) &&
       (bVar1 = handleReadFileData(buffer + 0x6e,4,1,file_data),
       CONCAT31(extraout_var_27,bVar1) == 0)) break;
    buffer = buffer + 0xac;
    if (0x1009b761 < (int)buffer) {
      return 1;
    }
  }
  return 0;
}



// Setting prototype: int load_alchemist_data_2(void *file_handle)

int handleLoadAlchemistData2(void *file_handle)

{
  int iVar1;
  void *file_data;
  bool bVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar3;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  undefined3 extraout_var_14;
  undefined3 extraout_var_15;
  undefined3 extraout_var_16;
  undefined3 extraout_var_17;
  undefined3 extraout_var_18;
  undefined3 extraout_var_19;
  undefined3 extraout_var_20;
  undefined3 extraout_var_21;
  undefined3 extraout_var_22;
  undefined3 extraout_var_23;
  undefined3 extraout_var_24;
  undefined3 extraout_var_25;
  undefined3 extraout_var_26;
  undefined3 extraout_var_27;
  undefined3 extraout_var_28;
  undefined3 extraout_var_29;
  undefined3 extraout_var_30;
  undefined3 extraout_var_31;
  undefined3 extraout_var_32;
  undefined3 extraout_var_33;
  undefined3 extraout_var_34;
  undefined3 extraout_var_35;
  undefined3 extraout_var_36;
  undefined3 extraout_var_37;
  int iVar4;
  undefined3 extraout_var_39;
  undefined3 extraout_var_40;
  undefined3 extraout_var_41;
  undefined3 extraout_var_42;
  undefined3 extraout_var_43;
  undefined3 extraout_var_44;
  undefined3 extraout_var_45;
  undefined3 extraout_var_46;
  undefined3 extraout_var_47;
  undefined3 extraout_var_48;
  undefined3 extraout_var_49;
  undefined3 extraout_var_50;
  undefined3 extraout_var_51;
  undefined3 extraout_var_52;
  undefined3 extraout_var_53;
  undefined3 extraout_var_54;
  undefined3 extraout_var_55;
  undefined3 extraout_var_56;
  undefined3 extraout_var_57;
  undefined3 extraout_var_58;
  undefined3 extraout_var_59;
  undefined3 extraout_var_60;
  undefined3 extraout_var_61;
  undefined3 extraout_var_62;
  undefined3 extraout_var_63;
  undefined3 extraout_var_64;
  undefined3 extraout_var_65;
  undefined3 extraout_var_66;
  undefined3 extraout_var_67;
  undefined3 extraout_var_68;
  undefined3 extraout_var_69;
  undefined3 extraout_var_70;
  undefined4 *buffer;
  uint local_c;
  int local_8;
  undefined4 local_4;
  undefined3 extraout_var_38;
  
  file_data = file_handle;
                    // 
                    // Loads alchemist data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  bVar2 = handleReadFileData(&local_c,2,1,file_handle);
  if (CONCAT31(extraout_var,bVar2) == 0) {
    return 0;
  }
  bVar2 = handleReadFileData(&file_handle,4,1,file_data);
  if (CONCAT31(extraout_var_00,bVar2) == 0) {
    return 0;
  }
  DAT_10035434 = file_handle;
  bVar2 = handleReadFileData(&DAT_10035470,4,1,file_data);
  if (CONCAT31(extraout_var_01,bVar2) == 0) {
    return 0;
  }
  bVar2 = handleReadFileData(&DAT_10035474,4,1,file_data);
  if (CONCAT31(extraout_var_02,bVar2) == 0) {
    return 0;
  }
  if (0x10016 < DAT_1002d4ec) {
    buffer = &DAT_10035478;
    do {
      bVar2 = handleReadFileData(buffer,4,1,file_data);
      if (CONCAT31(extraout_var_03,bVar2) == 0) {
        return 0;
      }
      buffer = buffer + 1;
    } while ((int)buffer < 0x10035498);
  }
  local_8 = 0;
  if (0 < (int)file_handle) {
    do {
      bVar2 = handleReadFileData(&local_c,2,1,file_data);
      if (CONCAT31(extraout_var_04,bVar2) == 0) {
        return 0;
      }
      uVar3 = local_c & 0xffff;
      iVar1 = uVar3 * 0x21c;
      (&DAT_100358a0)[uVar3 * 0x10e] = (short)local_c;
      if (DAT_1002d4ec < 0x1003e) {
        *(undefined4 *)(&DAT_10035aac + iVar1) = 0xffffffff;
      }
      else {
        bVar2 = handleReadFileData(&DAT_10035aac + iVar1,4,1,file_data);
        if (CONCAT31(extraout_var_05,bVar2) == 0) {
          return 0;
        }
      }
      bVar2 = handleReadFileData(&DAT_100358a2 + iVar1,1,1,file_data);
      if (CONCAT31(extraout_var_06,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358a4 + uVar3 * 0x87,4,1,file_data);
      if (CONCAT31(extraout_var_07,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358a8 + iVar1,1,1,file_data);
      if (CONCAT31(extraout_var_08,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358a9),1,1,file_data);
      if (CONCAT31(extraout_var_09,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358aa + iVar1,2,1,file_data);
      if (CONCAT31(extraout_var_10,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358ac + iVar1,1,1,file_data);
      if (CONCAT31(extraout_var_11,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358ad),1,1,file_data);
      if (CONCAT31(extraout_var_12,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358b0),4,1,file_data);
      if (CONCAT31(extraout_var_13,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358b4),4,1,file_data);
      if (CONCAT31(extraout_var_14,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358b8),4,1,file_data);
      if (CONCAT31(extraout_var_15,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358bc),4,1,file_data);
      if (CONCAT31(extraout_var_16,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358c0 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_17,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358c4),4,1,file_data);
      if (CONCAT31(extraout_var_18,bVar2) == 0) {
        return 0;
      }
      if (0x1003a < DAT_1002d4ec) {
        bVar2 = handleReadFileData(&DAT_100358c8 + iVar1,2,1,file_data);
        if (CONCAT31(extraout_var_19,bVar2) == 0) {
          return 0;
        }
        bVar2 = handleReadFileData((void *)(iVar1 + 0x100358cc),4,1,file_data);
        if (CONCAT31(extraout_var_20,bVar2) == 0) {
          return 0;
        }
      }
      bVar2 = handleReadFileData(&DAT_100358d0 + iVar1,0x10,1,file_data);
      if (CONCAT31(extraout_var_21,bVar2) == 0) {
        return 0;
      }
      if ((0x10030 < DAT_1002d4ec) &&
         (bVar2 = handleReadFileData(&DAT_100358e0 + iVar1,0x10,1,file_data),
         CONCAT31(extraout_var_22,bVar2) == 0)) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358f0 + iVar1,2,1,file_data);
      if (CONCAT31(extraout_var_23,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358f4 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_24,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x100358f8),1,1,file_data);
      if (CONCAT31(extraout_var_25,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_100358fc + uVar3 * 0x87,0x20,1,file_data);
      if (CONCAT31(extraout_var_26,bVar2) == 0) {
        return 0;
      }
      if ((0x10023 < DAT_1002d4ec) &&
         (bVar2 = handleReadFileData((void *)(iVar1 + 0x1003591c),4,1,file_data),
         CONCAT31(extraout_var_27,bVar2) == 0)) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035920),5,1,file_data);
      if (CONCAT31(extraout_var_28,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035928),0xa8,1,file_data);
      if (CONCAT31(extraout_var_29,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a04 + iVar1,1,1,file_data);
      if (CONCAT31(extraout_var_30,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a05 + iVar1,1,1,file_data);
      if (CONCAT31(extraout_var_31,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a06),1,1,file_data);
      if (CONCAT31(extraout_var_32,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a07),1,1,file_data);
      if (CONCAT31(extraout_var_33,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a08),1,1,file_data);
      if (CONCAT31(extraout_var_34,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a09),1,1,file_data);
      if (CONCAT31(extraout_var_35,bVar2) == 0) {
        return 0;
      }
      (&DAT_10035a0c)[uVar3 * 0x87] = 0;
      bVar2 = handleReadFileData(&DAT_10035a0c + uVar3 * 0x87,4,1,file_data);
      if (CONCAT31(extraout_var_36,bVar2) == 0) {
        return 0;
      }
      (&DAT_10035a10)[uVar3 * 0x87] = 0;
      bVar2 = handleReadFileData(&DAT_10035a10 + uVar3 * 0x87,4,1,file_data);
      if (CONCAT31(extraout_var_37,bVar2) == 0) {
        return 0;
      }
      if (DAT_1002d4ec < 0x10020) {
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a14),2,1,file_data);
        iVar4 = CONCAT31(extraout_var_39,bVar2);
      }
      else {
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a14),4,1,file_data);
        iVar4 = CONCAT31(extraout_var_38,bVar2);
      }
      if (iVar4 == 0) {
        return 0;
      }
      *(undefined4 *)(&DAT_10035a1c + iVar1) = 0;
      bVar2 = handleReadFileData(&DAT_10035a1c + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_40,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a20),1,1,file_data);
      if (CONCAT31(extraout_var_41,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a2c),4,1,file_data);
      if (CONCAT31(extraout_var_42,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a30 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_43,bVar2) == 0) {
        return 0;
      }
      if (DAT_1002d4ec < 0x1003e) {
        *(undefined4 *)(&DAT_10035a30 + iVar1) = 4;
      }
      bVar2 = handleReadFileData(&DAT_10035a34 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_44,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a38 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_45,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a3c + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_46,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a40 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_47,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a44 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_48,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a48 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_49,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a4c),4,1,file_data);
      if (CONCAT31(extraout_var_50,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a50),1,1,file_data);
      if (CONCAT31(extraout_var_51,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a51),1,1,file_data);
      if (CONCAT31(extraout_var_52,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a54),0x10,1,file_data);
      if (CONCAT31(extraout_var_53,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData(&DAT_10035a68 + iVar1,4,1,file_data);
      if (CONCAT31(extraout_var_54,bVar2) == 0) {
        return 0;
      }
      if (DAT_1002d4ec < 0x10049) {
        (&DAT_10035a6c)[uVar3 * 0x87] = 0;
      }
      else {
        bVar2 = handleReadFileData(&DAT_10035a6c + uVar3 * 0x87,4,1,file_data);
        if (CONCAT31(extraout_var_55,bVar2) == 0) {
          return 0;
        }
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a70),4,1,file_data);
      if (CONCAT31(extraout_var_56,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a74),0x10,1,file_data);
      if (CONCAT31(extraout_var_57,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a84),4,1,file_data);
      if (CONCAT31(extraout_var_58,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a88),4,1,file_data);
      if (CONCAT31(extraout_var_59,bVar2) == 0) {
        return 0;
      }
      bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a8c),4,1,file_data);
      if (CONCAT31(extraout_var_60,bVar2) == 0) {
        return 0;
      }
      if ((0x10029 < DAT_1002d4ec) &&
         (bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a90),4,1,file_data),
         CONCAT31(extraout_var_61,bVar2) == 0)) {
        return 0;
      }
      if ((0x10020 < DAT_1002d4ec) &&
         (bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a65),1,1,file_data),
         CONCAT31(extraout_var_62,bVar2) == 0)) {
        return 0;
      }
      bVar2 = handleReadFileData(&local_4,4,1,file_data);
      if (CONCAT31(extraout_var_63,bVar2) == 0) {
        return 0;
      }
      *(undefined4 *)(&DAT_10035a24 + iVar1) = local_4;
      if ((0x10020 < DAT_1002d4ec) &&
         (bVar2 = handleReadFileData((void *)(iVar1 + 0x10035a94),0x18,1,file_data),
         CONCAT31(extraout_var_64,bVar2) == 0)) {
        return 0;
      }
      if (0x10035 < DAT_1002d4ec) {
        bVar2 = handleReadFileData(&DAT_10035ab0 + uVar3 * 0x87,4,1,file_data);
        if (CONCAT31(extraout_var_65,bVar2) == 0) {
          return 0;
        }
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035ab4),1,1,file_data);
        if (CONCAT31(extraout_var_66,bVar2) == 0) {
          return 0;
        }
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035ab5),1,1,file_data);
        if (CONCAT31(extraout_var_67,bVar2) == 0) {
          return 0;
        }
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035ab6),1,1,file_data);
        if (CONCAT31(extraout_var_68,bVar2) == 0) {
          return 0;
        }
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035ab7),1,1,file_data);
        if (CONCAT31(extraout_var_69,bVar2) == 0) {
          return 0;
        }
        bVar2 = handleReadFileData((void *)(iVar1 + 0x10035ab8),1,1,file_data);
        if (CONCAT31(extraout_var_70,bVar2) == 0) {
          return 0;
        }
      }
      local_8 = local_8 + 1;
    } while (local_8 < (int)file_handle);
  }
  return 1;
}



// Setting prototype: int load_town_data(void *file_handle)

int handleLoadTownData(void *file_handle)

{
  void *file_data;
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  undefined3 extraout_var_14;
  undefined3 extraout_var_15;
  undefined3 extraout_var_16;
  undefined3 extraout_var_17;
  undefined3 extraout_var_18;
  undefined3 extraout_var_19;
  undefined3 extraout_var_20;
  undefined3 extraout_var_21;
  undefined3 extraout_var_22;
  undefined3 extraout_var_23;
  undefined3 extraout_var_24;
  undefined3 extraout_var_25;
  undefined3 extraout_var_26;
  undefined3 extraout_var_27;
  undefined3 extraout_var_28;
  undefined3 extraout_var_29;
  undefined3 extraout_var_30;
  undefined3 extraout_var_31;
  undefined3 extraout_var_32;
  undefined3 extraout_var_33;
  undefined3 extraout_var_34;
  undefined3 extraout_var_35;
  undefined3 extraout_var_36;
  undefined3 extraout_var_37;
  undefined3 extraout_var_38;
  undefined3 extraout_var_39;
  undefined3 extraout_var_40;
  undefined3 extraout_var_41;
  undefined3 extraout_var_42;
  undefined4 *buffer;
  int iVar2;
  undefined4 *buffer_00;
  void *pvVar3;
  int local_4;
  
                    // 
                    // Loads town data from a file.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  file_data = file_handle;
  local_4 = 0x3e;
  if ((0x10047 < DAT_1002d4ec) &&
     (bVar1 = handleReadFileData(&local_4,4,1,file_handle), CONCAT31(extraout_var,bVar1) == 0)) {
    return 0;
  }
  buffer = &DAT_1009b768;
  do {
    bVar1 = handleReadFileData(buffer + -2,4,1,file_handle);
    if (CONCAT31(extraout_var_00,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(buffer + -1,4,1,file_handle);
    if (CONCAT31(extraout_var_01,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(buffer,4,1,file_handle);
    if (CONCAT31(extraout_var_02,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(buffer + 1,4,1,file_handle);
    if (CONCAT31(extraout_var_03,bVar1) == 0) {
      return 0;
    }
    iVar2 = 0;
    if (0 < local_4) {
      buffer_00 = buffer + 4;
      do {
        bVar1 = handleReadFileData(buffer_00 + -2,2,1,file_handle);
        if (CONCAT31(extraout_var_04,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + -1,4,1,file_handle);
        if (CONCAT31(extraout_var_05,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00,4,1,file_handle);
        if (CONCAT31(extraout_var_06,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 1,4,1,file_handle);
        if (CONCAT31(extraout_var_07,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 6,4,1,file_handle);
        if (CONCAT31(extraout_var_08,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 7,4,1,file_handle);
        if (CONCAT31(extraout_var_09,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 10,4,1,file_handle);
        if (CONCAT31(extraout_var_10,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 0xb,4,1,file_handle);
        if (CONCAT31(extraout_var_11,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 0xc,4,1,file_handle);
        if (CONCAT31(extraout_var_12,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 0xd,2,1,file_handle);
        if (CONCAT31(extraout_var_13,bVar1) == 0) {
          return 0;
        }
        bVar1 = handleReadFileData(buffer_00 + 9,4,1,file_handle);
        if (CONCAT31(extraout_var_14,bVar1) == 0) {
          return 0;
        }
        iVar2 = iVar2 + 1;
        buffer_00 = buffer_00 + 0x20;
      } while (iVar2 < local_4);
    }
    buffer = buffer + 0xaa4;
  } while ((int)buffer < 0x100a8c38);
  file_handle = &DAT_100a8c88;
  while( true ) {
    bVar1 = handleReadFileData((void *)((int)file_handle + -0x48),0x20,1,file_data);
    if (CONCAT31(extraout_var_15,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + -8),8,1,file_data);
    if (CONCAT31(extraout_var_16,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData(file_handle,1,1,file_data);
    if (CONCAT31(extraout_var_17,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 4),4,1,file_data);
    if (CONCAT31(extraout_var_18,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 8),4,1,file_data);
    if (CONCAT31(extraout_var_19,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xc),2,1,file_data);
    if (CONCAT31(extraout_var_20,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0x10),8,1,file_data);
    if (CONCAT31(extraout_var_21,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0x18),1,1,file_data);
    if (CONCAT31(extraout_var_22,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0x19),1,1,file_data);
    if (CONCAT31(extraout_var_23,bVar1) == 0) {
      return 0;
    }
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0x1c);
    do {
      bVar1 = handleReadFileData(pvVar3,8,1,file_data);
      if (CONCAT31(extraout_var_24,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 8);
    } while (iVar2 < 10);
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0x6c);
    do {
      bVar1 = handleReadFileData(pvVar3,8,1,file_data);
      if (CONCAT31(extraout_var_25,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 8);
    } while (iVar2 < 10);
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xbc),1,1,file_data);
    if (CONCAT31(extraout_var_26,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xbd),1,1,file_data);
    if (CONCAT31(extraout_var_27,bVar1) == 0) {
      return 0;
    }
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0xc0);
    do {
      bVar1 = handleReadFileData(pvVar3,4,1,file_data);
      if (CONCAT31(extraout_var_28,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 4);
    } while (iVar2 < 4);
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0xd0);
    do {
      bVar1 = handleReadFileData(pvVar3,4,1,file_data);
      if (CONCAT31(extraout_var_29,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 4);
    } while (iVar2 < 4);
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xe0),4,1,file_data);
    if (CONCAT31(extraout_var_30,bVar1) == 0) {
      return 0;
    }
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0xe4);
    do {
      bVar1 = handleReadFileData(pvVar3,1,1,file_data);
      if (CONCAT31(extraout_var_31,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 1);
    } while (iVar2 < 0xb);
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xef),1,1,file_data);
    if (CONCAT31(extraout_var_32,bVar1) == 0) {
      return 0;
    }
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0xf0);
    do {
      bVar1 = handleReadFileData(pvVar3,1,1,file_data);
      if (CONCAT31(extraout_var_33,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 1);
    } while (iVar2 < 7);
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xf7),1,1,file_data);
    if (CONCAT31(extraout_var_34,bVar1) == 0) break;
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xf8),1,1,file_data);
    if (CONCAT31(extraout_var_35,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xf9),1,1,file_data);
    if (CONCAT31(extraout_var_36,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0xfa),1,1,file_data);
    if (CONCAT31(extraout_var_37,bVar1) == 0) {
      return 0;
    }
    iVar2 = 0;
    pvVar3 = (void *)((int)file_handle + 0xfc);
    do {
      bVar1 = handleReadFileData(pvVar3,0x12,1,file_data);
      if (CONCAT31(extraout_var_38,bVar1) == 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      pvVar3 = (void *)((int)pvVar3 + 0x12);
    } while (iVar2 < 8);
    bVar1 = handleReadFileData((void *)((int)file_handle + 0x18c),4,1,file_data);
    if (CONCAT31(extraout_var_39,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 400),4,1,file_data);
    if (CONCAT31(extraout_var_40,bVar1) == 0) {
      return 0;
    }
    bVar1 = handleReadFileData((void *)((int)file_handle + 0x194),0xd0,1,file_data);
    if (CONCAT31(extraout_var_41,bVar1) == 0) {
      return 0;
    }
    if ((0x10036 < DAT_1002d4ec) &&
       (bVar1 = handleReadFileData((void *)((int)file_handle + 0x2a4),8,1,file_data),
       CONCAT31(extraout_var_42,bVar1) == 0)) {
      return 0;
    }
    file_handle = (void *)((int)file_handle + 0x2f4);
    if (0x100a9857 < (int)file_handle) {
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int id_to_ptr(void)

int ls_ID2Ptr(void)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  int iVar4;
  int iVar5;
  undefined4 *puVar6;
  void **building_data_ptr;
  int iVar7;
  void *local_c;
  void *local_8;
  void *local_4;
  
                    // 
                    // Converts various IDs stored in game data structures to their corresponding
                    // pointers.
                    // This is typically done after loading data from a file to resolve references.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  DAT_1003546c = handleGetPlayerById(DAT_1003546c);
  if (DAT_1003546c == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,0x1016,
               s_ls_ID2Ptr____Stadtspieler_Id_not_1002d580,1);
    return 0;
  }
  DAT_1003543c = gm_FindObject(1,5,10);
  if (0x10016 < DAT_1002d4ec) {
    puVar6 = &DAT_10035478;
    do {
      uVar3 = handleGetPlayerById(*puVar6);
      *puVar6 = uVar3;
      puVar6 = puVar6 + 1;
    } while ((int)puVar6 < 0x10035498);
  }
  building_data_ptr = (void **)&DAT_10035a10;
  do {
    if (*(short *)(building_data_ptr + -0x5c) != -1) {
      if (building_data_ptr[-1] == (void *)0xffffffff) {
        building_data_ptr[-1] = (void *)0x0;
      }
      else {
        gm_LoadGameData(building_data_ptr + -1,(void **)0x0,(void **)0x0,
                        (uint32_t)building_data_ptr[-1]);
      }
      if (*building_data_ptr == (void *)0xffffffff) {
        *building_data_ptr = (void *)0x0;
      }
      else {
        gm_LoadGameData(building_data_ptr,(void **)0x0,(void **)0x0,(uint32_t)*building_data_ptr);
      }
    }
    building_data_ptr = building_data_ptr + 0x87;
  } while ((int)building_data_ptr < 0x1009ae10);
  iVar5 = 0;
  if (0 < DAT_10035450) {
    iVar7 = 0;
    do {
      iVar1 = iVar7 + DAT_100a8c34;
      if (*(char *)(DAT_101de450 + (uint)*(ushort *)(iVar7 + DAT_100a8c34) * 0x41) == '\x1d') {
        *(undefined4 *)(iVar1 + 0x24) = 0;
      }
      if (*(uint32_t *)(iVar1 + 6) != 0xffffffff) {
        iVar4 = gm_LoadGameData(&local_c,&local_8,&local_4,*(uint32_t *)(iVar1 + 6));
        if (iVar4 == 0) {
          logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,0x1050,
                     s_ls_ID2Ptr____Houston__wir_haben_e_1002d520,1);
        }
        else if (local_c == (void *)0x0) {
          if (local_8 == (void *)0x0) {
            iVar4 = *(int *)((int)local_4 + 0x178);
            if (iVar4 != 0) {
              for (iVar2 = *(int *)(iVar4 + 0x3f); iVar2 != 0; iVar2 = *(int *)(iVar2 + 0x3f)) {
                iVar4 = iVar2;
              }
              goto LAB_10014236;
            }
            *(int *)((int)local_4 + 0x178) = iVar1;
          }
          else {
            iVar4 = *(int *)((int)local_8 + 0x14);
            if (iVar4 == 0) {
              *(int *)((int)local_8 + 0x14) = iVar1;
            }
            else {
              for (iVar2 = *(int *)(iVar4 + 0x3f); iVar2 != 0; iVar2 = *(int *)(iVar2 + 0x3f)) {
                iVar4 = iVar2;
              }
LAB_10014236:
              *(int *)(iVar4 + 0x3f) = iVar1;
            }
          }
        }
        else {
          iVar4 = *(int *)((int)local_c + 0x5d);
          if (iVar4 != 0) {
            for (iVar2 = *(int *)(iVar4 + 0x3f); iVar2 != 0; iVar2 = *(int *)(iVar2 + 0x3f)) {
              iVar4 = iVar2;
            }
            goto LAB_10014236;
          }
          *(int *)((int)local_c + 0x5d) = iVar1;
        }
      }
      iVar5 = iVar5 + 1;
      iVar7 = iVar7 + 0x43;
    } while (iVar5 < DAT_10035450);
  }
  building_management_4();
  return 1;
}



// Setting prototype: int receive_game_state(void *file_handle)

int __cdecl srv_LoadGameState(void *file_handle)

{
  bool bVar1;
  void *file_handle_00;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  int iVar2;
  char *pcVar3;
  
                    // 
                    // Receives and loads the game state from a file.
                    // This function reads various game data structures, including player, building,
                    // dynasty, alchemist, and town data.
                    // 
                    // Parameters:
                    //   file_handle: Handle to the file from which to load data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  file_handle_00 = (void *)vfs_open(DAT_101deae8,DAT_101deac0,&DAT_1002944c);
  if (file_handle_00 == (void *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,0x11fe,
               s_ls_RecvGame____Can_t_open_File_1002d6d8,1);
    m_free(DAT_101de560);
    DAT_101de560 = (void *)0x0;
    return 0;
  }
  handleLoadPlayerData(file_handle_00,&DAT_101de460);
  if ((((DAT_101de464 & 2) == 0) || (0x1005a < DAT_101de460)) || (DAT_101de460 < 0x10013)) {
    pcVar3 = s_srv_RecvGame____Can_t_load_Count_1002d5a8;
    iVar2 = 0x120a;
    goto LAB_100145b2;
  }
  DAT_1003546c = 0;
  bVar1 = handleReadFileData(&DAT_10030b6c,4,1,file_handle_00);
  if (CONCAT31(extraout_var,bVar1) != 0) {
    bVar1 = handleReadFileData(&DAT_1176408c,4,1,file_handle_00);
    if (CONCAT31(extraout_var_00,bVar1) != 0) {
      bVar1 = handleReadFileData(&DAT_10035880,0xe,1,file_handle_00);
      if (CONCAT31(extraout_var_01,bVar1) != 0) {
        bVar1 = handleReadFileData(&DAT_10035439,1,1,file_handle_00);
        if (CONCAT31(extraout_var_02,bVar1) != 0) {
          bVar1 = handleReadFileData(&DAT_1003546c,4,1,file_handle_00);
          if (CONCAT31(extraout_var_03,bVar1) != 0) {
            bVar1 = handleReadFileData(&DAT_1003542c,4,1,file_handle_00);
            if (CONCAT31(extraout_var_04,bVar1) != 0) {
              bVar1 = handleReadFileData(&DAT_10035430,4,1,file_handle_00);
              if (CONCAT31(extraout_var_05,bVar1) != 0) {
                bVar1 = handleReadFileData(&DAT_10035434,4,1,file_handle_00);
                if (CONCAT31(extraout_var_06,bVar1) != 0) {
                  handleReadFileData(&DAT_10035440,4,1,file_handle_00);
                  handleReadFileData(&DAT_101de580,0x18,1,file_handle_00);
                  if (0x1002f < (int)DAT_1002d4ec) {
                    handleReadFileData(&DAT_10030b70,4,1,file_handle_00);
                  }
                  if ((int)DAT_1002d4ec < 0x1003d) {
                    DAT_10035408 = 1000000;
                  }
                  else {
                    handleReadFileData(&DAT_10035408,4,1,file_handle_00);
                  }
                  iVar2 = handleLoadBuildingData(file_handle_00);
                  if (iVar2 != 0) {
                    iVar2 = handleLoadGameData(file_handle_00);
                    if (iVar2 == 0) {
                      pcVar3 = s_LoadGame____Can_t_load_Buildings_1002d690;
                      iVar2 = 0x123d;
LAB_100145b2:
                      logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,iVar2,pcVar3,1);
                      file_read_data(file_handle_00);
                      m_free(DAT_101de560);
                      DAT_101de560 = (void *)0x0;
                      return 0;
                    }
                    iVar2 = handleLoadDynastyData(file_handle_00);
                    if (iVar2 == 0) {
                      pcVar3 = s_srv_RecvGame____Can_t_load_Dynas_1002d668;
                      iVar2 = 0x1246;
                    }
                    else {
                      iVar2 = handleLoadAlchemistData2(file_handle_00);
                      if (iVar2 == 0) {
                        pcVar3 = s_srv_RecvGame____Can_t_load_Playe_1002d644;
                        iVar2 = 0x124f;
                        goto LAB_1001457d;
                      }
                      pcVar3 = &DAT_100358a2;
                      do {
                        if ((*(short *)(pcVar3 + -2) != -1) && (*pcVar3 == '\x06')) {
                          *pcVar3 = '\x05';
                        }
                        pcVar3 = pcVar3 + 0x21c;
                      } while ((int)pcVar3 < 0x1009aca2);
                      iVar2 = handleLoadTownData(file_handle_00);
                      if (iVar2 == 0) {
                        pcVar3 = s_srv_RecvGame____Can_t_load_Towns_1002d620;
                        iVar2 = 0x125b;
                        goto LAB_100145b2;
                      }
                      if (0x10044 < (int)DAT_1002d4ec) {
                        iVar2 = amt_fio_LoadAemter(file_handle_00,DAT_1002d4ec);
                        if (iVar2 == 0) {
                          logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,0x1266,
                                     s_srv_RecvGame____Can_t_load_Aemte_1002d5fc,1);
                          file_read_data(file_handle_00);
                          return 0;
                        }
                      }
                      iVar2 = ls_ID2Ptr();
                      if (iVar2 != 0) {
                        file_read_data(file_handle_00);
                        return 1;
                      }
                      pcVar3 = s_srv_RecvGame____Can_t_convert_ID_1002d5cc;
                      iVar2 = 0x126f;
                    }
                    logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,iVar2,pcVar3,1);
                    file_read_data(file_handle_00);
                    m_free(DAT_101de560);
                    DAT_101de560 = (void *)0x0;
                    return 0;
                  }
                  pcVar3 = s_srv_RecvGame____Can_t_load_Objec_1002d6b4;
                  iVar2 = 0x1234;
                  goto LAB_1001457d;
                }
              }
            }
          }
        }
      }
    }
  }
  pcVar3 = s_srv_RecvGame____Can_t_load_Count_1002d5a8;
  iVar2 = 0x121e;
LAB_1001457d:
  logMessage(s_D__Develop_DieGildeAddOn_loadsav_1002d550,iVar2,pcVar3,1);
  file_read_data(file_handle_00);
  m_free(DAT_101de560);
  DAT_101de560 = (void *)0x0;
  return 0;
}



// Setting prototype: int command_handler(void *client_data, void *command_data)

int lobby_get_player_list(void *client_data,void *command_data)

{
  int iVar1;
  uint *puVar2;
  uint *puVar3;
  uint local_24 [9];
  
                    // 
                    // Handles a specific command, likely related to player lists.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x6000) != 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x244,s_invalid_client_state_1002d740,1);
    *(undefined1 *)command_data = 2;
    iVar1 = client_queue_append_command(client_data,command_data);
    return (iVar1 != -1) - 1;
  }
  puVar2 = local_24;
  for (iVar1 = 9; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  local_24[0] = 0;
  puVar2 = &g_client_slots;
  do {
    if (((*puVar2 & 1) != 0) && ((*puVar2 & 0x200) != 0)) {
      local_24[local_24[0] + 1] = puVar2[1];
      local_24[0] = local_24[0] + 1;
    }
    puVar2 = puVar2 + 0x99099;
  } while ((int)puVar2 < 0x114ffe20);
  puVar2 = local_24;
  puVar3 = (uint *)((int)command_data + 0x14);
  for (iVar1 = 9; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar3 = *puVar2;
    puVar2 = puVar2 + 1;
    puVar3 = puVar3 + 1;
  }
  iVar1 = client_queue_append_command(client_data,command_data);
  if (iVar1 == -1) {
    return -1;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,600,s_Got_lb_ExPlayerlist_1002d6f8,1);
  return 0;
}



// Setting prototype: int command_handler_2(void *client_data, void *command_data)

int lobby_set_player_ready_status(void *client_data,void *command_data)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  uint *client;
  
                    // 
                    // Handles a specific command, likely related to player ready status.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  uVar3 = *client_data;
  if ((uVar3 & 0x6000) == 0) {
    if (*(int *)((int)client_data + 4) != *(int *)((int)command_data + 0x14)) {
      *(undefined1 *)command_data = 2;
      iVar2 = client_queue_append_command(client_data,command_data);
      return (iVar2 != -1) - 1;
    }
    uVar1 = *(uint *)((int)command_data + 0x18);
    if (uVar1 < 2) {
      *(uint *)((int)client_data + 0x264210) = uVar1;
      if (uVar1 == 0) {
        uVar3 = uVar3 & 0xfffff7ff;
      }
      else {
        uVar3 = uVar3 | 0x800;
      }
      *(uint *)client_data = uVar3;
      client = &g_client_slots;
      do {
        if (((*client & 1) != 0) && ((*client & 0x200) != 0)) {
          iVar2 = client_queue_append_command(client,command_data);
          if (iVar2 == -1) {
            return -1;
          }
        }
        client = client + 0x99099;
      } while ((int)client < 0x114ffe20);
      logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x28c,
                 s_Got_lb_ExPlayerReadyStatus_1002d758,1);
      return 0;
    }
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x279,s_invalid_client_data_1002d774,1);
    *(undefined1 *)command_data = 2;
  }
  else {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x264,s_invalid_client_state_1002d740,1);
    *(undefined1 *)command_data = 2;
  }
  iVar2 = client_queue_append_command(client_data,command_data);
  return (iVar2 != -1) - 1;
}



// Setting prototype: int command_handler_3(void *client_data, void *command_data)

int lobby_join_game(void *client_data,void *command_data)

{
  uint uVar1;
  undefined4 uVar2;
  uint *puVar3;
  int *piVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  int iVar7;
  int local_120 [8];
  CHAR local_100 [256];
  
                    // 
                    // Handles a specific command, likely related to player joining the game.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x4000) == 0) {
    if ((*client_data & 0x2000) != 0) {
      iVar7 = 0;
      puVar3 = &g_client_slots;
      do {
        uVar1 = *puVar3;
        if ((((uVar1 & 1) != 0) && ((uVar1 & 0x200) != 0)) && ((uVar1 & 0x2000) == 0)) {
          iVar7 = iVar7 + 1;
        }
        puVar3 = puVar3 + 0x99099;
      } while ((int)puVar3 < 0x114ffe20);
      if (g_max_players <= iVar7) {
        logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x2b1,s_Game_is_full_1002d848,1);
        *(undefined1 *)command_data = 2;
        iVar7 = client_queue_append_command(client_data,command_data);
        if (iVar7 == -1) {
          return -1;
        }
        close_connection(client_data);
        return 0;
      }
      puVar3 = &g_client_slots;
      *(undefined4 *)((int)command_data + 0x18) = 0;
      while ((((*puVar3 & 1) == 0 || ((*puVar3 & 0x200) == 0)) ||
             ((puVar3 == (uint *)client_data ||
              (puVar3[0x99086] != *(uint *)((int)command_data + 0x20)))))) {
        puVar3 = puVar3 + 0x99099;
        if (0x114ffe1f < (int)puVar3) goto LAB_1001494d;
      }
      local_120[0] = 0;
      local_120[1] = 0;
      local_120[2] = 0;
      local_120[3] = 0;
      local_120[4] = 0;
      local_120[5] = 0;
      local_120[6] = 0;
      local_120[7] = 0;
      piVar4 = local_120;
      puVar3 = &g_client_slots;
      do {
        if ((((*puVar3 & 1) != 0) && ((*puVar3 & 0x200) != 0)) &&
           ((puVar3 != (uint *)client_data &&
            ((-1 < (int)puVar3[0x99086] && ((int)puVar3[0x99086] < 8)))))) {
          *piVar4 = 1;
        }
        puVar3 = puVar3 + 0x99099;
        piVar4 = piVar4 + 1;
      } while ((int)puVar3 < 0x114ffe20);
      iVar7 = 0;
      piVar4 = local_120;
      do {
        if (*piVar4 == 0) {
          *(int *)((int)command_data + 0x20) = iVar7;
          break;
        }
        iVar7 = iVar7 + 1;
        piVar4 = piVar4 + 1;
      } while (iVar7 < 8);
LAB_1001494d:
                    // WARNING: Load size is inaccurate
      printf_wrapper(local_100,s_lb_ExPlayerHasJoined__before_<<m_1002d81c,*client_data);
      logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x2dd,local_100,1);
      puVar5 = (undefined4 *)((int)command_data + 0x14);
      puVar6 = (undefined4 *)((int)client_data + 0x26420c);
      for (iVar7 = 0x15; iVar7 != 0; iVar7 = iVar7 + -1) {
        *puVar6 = *puVar5;
        puVar5 = puVar5 + 1;
        puVar6 = puVar6 + 1;
      }
                    // WARNING: Load size is inaccurate
      uVar2 = *client_data;
      *(undefined2 *)puVar6 = *(undefined2 *)puVar5;
      *(undefined1 *)((int)puVar6 + 2) = *(undefined1 *)((int)puVar5 + 2);
      printf_wrapper(local_100,s_lb_ExPlayerHasJoined__after_<<me_1002d7f0,uVar2);
      logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x2e2,local_100,1);
                    // WARNING: Load size is inaccurate
      uVar1 = *client_data;
      *(uint *)client_data = uVar1 & 0xffffdfff;
      printf_wrapper(local_100,s_lb_ExPlayerHasJoined__before_<<s_1002d7b4,uVar1 & 0xffffdfff);
      logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x2e7,local_100,1);
      puVar3 = &g_client_slots;
      while ((((*puVar3 & 1) == 0 || ((*puVar3 & 0x200) == 0)) ||
             (iVar7 = client_queue_append_command(puVar3,command_data), iVar7 != -1))) {
        puVar3 = puVar3 + 0x99099;
        if (0x114ffe1f < (int)puVar3) {
                    // WARNING: Load size is inaccurate
          printf_wrapper(local_100,s_lb_ExPlayerHasJoined__status_on_e_1002d788,*client_data);
          logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x2ef,local_100,1);
          return 0;
        }
      }
      return -1;
    }
    iVar7 = 0x2a4;
  }
  else {
    iVar7 = 0x29a;
  }
  logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,iVar7,s_invalid_client_state_1002d740,1);
  *(undefined1 *)command_data = 2;
  iVar7 = client_queue_append_command(client_data,command_data);
  return (iVar7 != -1) - 1;
}



// Setting prototype: int command_handler_4(void *client_data, void *command_data)

int lobby_update_player_status(void *client_data,void *command_data)

{
  int iVar1;
  uint *client;
  
                    // 
                    // Handles a specific command, likely related to player status updates.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x6000) != 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x2fc,s_invalid_client_state_1002d740,1);
    *(undefined1 *)command_data = 2;
    iVar1 = client_queue_append_command(client_data,command_data);
    return (iVar1 != -1) - 1;
  }
  *(uint *)client_data = *client_data | 0x3000;
  *(undefined4 *)((int)command_data + 0x14) = *(undefined4 *)((int)client_data + 4);
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x400) == 0) {
    *(undefined4 *)((int)command_data + 0x18) = 0;
  }
  else {
    *(undefined4 *)((int)command_data + 0x18) = 1;
  }
  client = &g_client_slots;
  do {
    if (((*client & 1) != 0) && ((*client & 0x200) != 0)) {
      iVar1 = client_queue_append_command(client,command_data);
      if (iVar1 == -1) {
        return -1;
      }
    }
    client = client + 0x99099;
  } while ((int)client < 0x114ffe20);
  return 0;
}



// Setting prototype: int command_handler_5(void *client_data, void *command_data)

int lobby_forward_command(void *client_data,void *command_data)

{
  int iVar1;
  uint *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  
                    // 
                    // Handles a specific command, likely related to player information exchange.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x6000) != 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x31d,s_invalid_client_state_1002d740,1);
    *(undefined1 *)command_data = 2;
    iVar1 = client_queue_append_command(client_data,command_data);
    return (iVar1 != -1) - 1;
  }
  if (*(int *)((int)client_data + 4) != *(int *)((int)command_data + 0x14)) {
    *(undefined1 *)command_data = 2;
    iVar1 = client_queue_append_command(client_data,command_data);
    return (iVar1 != -1) - 1;
  }
  puVar2 = &g_client_slots;
  while (((((*puVar2 & 1) == 0 || ((*puVar2 & 0x200) == 0)) || (puVar2 == (uint *)client_data)) ||
         (puVar2[0x99086] != *(uint *)((int)command_data + 0x20)))) {
    puVar2 = puVar2 + 0x99099;
    if (0x114ffe1f < (int)puVar2) {
LAB_10014b94:
      *(undefined4 *)((int)command_data + 0x18) = *(undefined4 *)((int)client_data + 0x264210);
      puVar3 = (undefined4 *)((int)command_data + 0x14);
      puVar4 = (undefined4 *)((int)client_data + 0x26420c);
      for (iVar1 = 0x15; iVar1 != 0; iVar1 = iVar1 + -1) {
        *puVar4 = *puVar3;
        puVar3 = puVar3 + 1;
        puVar4 = puVar4 + 1;
      }
      *(undefined2 *)puVar4 = *(undefined2 *)puVar3;
      *(undefined1 *)((int)puVar4 + 2) = *(undefined1 *)((int)puVar3 + 2);
      puVar2 = &g_client_slots;
      while ((((*puVar2 & 1) == 0 || ((*puVar2 & 0x200) == 0)) ||
             (iVar1 = client_queue_append_command(puVar2,command_data), iVar1 != -1))) {
        puVar2 = puVar2 + 0x99099;
        if (0x114ffe1f < (int)puVar2) {
          return 0;
        }
      }
      return -1;
    }
  }
  *(undefined4 *)((int)command_data + 0x20) = *(undefined4 *)((int)client_data + 0x264218);
  goto LAB_10014b94;
}



// Setting prototype: int command_handler_6(void *client_data, void *command_data)

int lobby_get_player_data(void *client_data,void *command_data)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  
                    // 
                    // Handles a specific command, likely related to player data requests.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x6000) != 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x354,s_invalid_client_state_1002d740,1);
    *(undefined1 *)command_data = 2;
    iVar1 = client_queue_append_command(client_data,command_data);
    return (iVar1 != -1) - 1;
  }
  iVar1 = 0;
  piVar2 = &DAT_101deb04;
  do {
    if (*piVar2 == *(int *)((int)command_data + 0x14)) {
      puVar4 = (undefined4 *)(&DAT_10442d0c + iVar1 * 0x132132);
      puVar5 = (undefined4 *)((int)command_data + 0x14);
      for (iVar3 = 0x15; iVar3 != 0; iVar3 = iVar3 + -1) {
        *puVar5 = *puVar4;
        puVar4 = puVar4 + 1;
        puVar5 = puVar5 + 1;
      }
      *(undefined2 *)puVar5 = *(undefined2 *)puVar4;
      *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
      goto LAB_10014c56;
    }
    piVar2 = piVar2 + 0x99099;
    iVar1 = iVar1 + 1;
  } while ((int)piVar2 < 0x114ffe24);
  *(undefined1 *)command_data = 2;
LAB_10014c56:
  iVar1 = client_queue_append_command(client_data,command_data);
  return (iVar1 != -1) - 1;
}



// Setting prototype: int command_handler_7(void *client_data, void *command_data)

int lobby_chat_message(void *client_data,void *command_data)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  uint *client;
  
                    // 
                    // Handles a specific command, likely related to sending data to all or a
                    // specific client.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, -1 on error.
                    // 
                    // WARNING: Load size is inaccurate
  if ((*client_data & 0x6000) != 0) {
    logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x37b,s_invalid_client_state_1002d740,1);
    *(undefined1 *)command_data = 2;
    iVar1 = client_queue_append_command(client_data,command_data);
    return (iVar1 != -1) - 1;
  }
  if (*(int *)((int)command_data + 0x18) == 0) {
    client = &g_client_slots;
    do {
      if ((((*client & 1) != 0) && ((*client & 0x200) != 0)) &&
         (iVar1 = client_queue_append_command(client,command_data), iVar1 == -1)) {
        return -1;
      }
      client = client + 0x99099;
    } while ((int)client < 0x114ffe20);
  }
  else {
    iVar1 = 0;
    piVar2 = &DAT_101deb04;
    while (*piVar2 != *(int *)((int)command_data + 0x18)) {
      piVar2 = piVar2 + 0x99099;
      iVar1 = iVar1 + 1;
      if (0x114ffe23 < (int)piVar2) {
        *(undefined1 *)command_data = 2;
        iVar1 = client_queue_append_command(client_data,command_data);
        return (iVar1 != -1) - 1;
      }
    }
    iVar3 = client_queue_append_command(&g_client_slots + iVar1 * 0x99099,command_data);
    if (iVar3 == -1) {
      return -1;
    }
    if (((&DAT_101deb04)[iVar1 * 0x99099] != *(int *)((int)client_data + 4)) &&
       (iVar1 = client_queue_append_command(client_data,command_data), iVar1 == -1)) {
      return -1;
    }
  }
  return 0;
}



// Setting prototype: int command_handler_8(void *client_data, void *command_data)

int dispatch_lobby_command(void *client_data,void *command_data)

{
  int iVar1;
  CHAR local_80 [128];
  
                    // 
                    // Dispatches lobby server commands to specific handlers based on the command
                    // type.
                    // 
                    // Parameters:
                    //   client_data: Pointer to the client's data structure.
                    //   command_data: Pointer to the command data.
                    // 
                    // Return values:
                    //   0 if successful, 1 on unknown command type.
                    // 
  printf_wrapper(local_80,s_lb_ExLobbyServerCommand___i_1002d858,
                 (uint)*(byte *)((int)command_data + 0x10));
  logMessage(s_D__Develop_DieGildeAddOn_command_1002d70c,0x3a5,local_80,1);
  switch(*(undefined4 *)((int)command_data + 0x10)) {
  case 0:
    iVar1 = lobby_get_player_list(client_data,command_data);
    return iVar1;
  case 1:
    iVar1 = lobby_set_player_ready_status(client_data,command_data);
    return iVar1;
  case 2:
    iVar1 = lobby_join_game(client_data,command_data);
    return iVar1;
  case 3:
    iVar1 = lobby_update_player_status(client_data,command_data);
    return iVar1;
  case 4:
    iVar1 = lobby_forward_command(client_data,command_data);
    return iVar1;
  case 5:
    iVar1 = lobby_get_player_data(client_data,command_data);
    return iVar1;
  case 6:
    iVar1 = lobby_chat_message(client_data,command_data);
    return iVar1;
  default:
    return 1;
  }
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: void *get_plant_map(uint32_t map_id)

undefined * handleGetPlantMap(uint map_id)

{
  ushort *puVar1;
  uint uVar2;
  undefined *puVar3;
  int iVar4;
  
                    // 
                    // Retrieves a plant map by its ID.
                    // 
                    // Parameters:
                    //   map_id: The ID of the plant map.
                    // 
                    // Return values:
                    //   A pointer to the plant map data, or NULL if not found.
                    // 
  iVar4 = 0;
  if ((short)_DAT_1002d878 != 0) {
    puVar3 = &DAT_1002d878;
    uVar2 = _DAT_1002d878;
    do {
      if ((uVar2 & 0xffff) == map_id) {
        return &DAT_1002d878 + iVar4 * 0x46;
      }
      puVar1 = (ushort *)(puVar3 + 0x46);
      uVar2 = (uint)*puVar1;
      puVar3 = puVar3 + 0x46;
      iVar4 = iVar4 + 1;
    } while (*puVar1 != 0);
  }
  return (undefined *)0x0;
}



// Setting prototype: void *find_free_plant_map_slot(void *plant_map, uint32_t x_coord, uint32_t
// y_coord)

int handleFindFreePlantMapSlot(int plant_map,uint x_coord,uint y_coord)

{
  byte *pbVar1;
  int iVar2;
  
                    // 
                    // Finds a free slot in the plant map at the specified coordinates.
                    // 
                    // Parameters:
                    //   plant_map: Pointer to the plant map data.
                    //   x_coord: The X-coordinate.
                    //   y_coord: The Y-coordinate.
                    // 
                    // Return values:
                    //   A pointer to the free slot, or NULL if no free slot is found.
                    // 
  iVar2 = 0;
  pbVar1 = (byte *)(plant_map + 9);
  while (((pbVar1[-1] != x_coord || (*pbVar1 != y_coord)) || (pbVar1[4] == 0xff))) {
    iVar2 = iVar2 + 1;
    pbVar1 = pbVar1 + 0x18;
    if (0x3f < iVar2) {
      return 0;
    }
  }
  return plant_map + iVar2 * 0x18;
}



// Setting prototype: void *find_plant_map_slot_by_coords(void *plant_map, int x_coord, int y_coord)

int handleFindPlantMapSlotByCoords(int plant_map,int x_coord,int y_coord)

{
  int iVar1;
  byte *pbVar2;
  int iVar3;
  
                    // 
                    // Finds a plant map slot by its coordinates.
                    // 
                    // Parameters:
                    //   plant_map: Pointer to the plant map data.
                    //   x_coord: The X-coordinate.
                    //   y_coord: The Y-coordinate.
                    // 
                    // Return values:
                    //   A pointer to the plant map slot, or NULL if not found.
                    // 
  iVar3 = 0;
  pbVar2 = (byte *)(plant_map + 8);
  do {
    if (pbVar2[5] != 0xff) {
      iVar1 = (int)(char)pbVar2[4] / 2;
      if (((((int)((uint)*pbVar2 - iVar1) <= x_coord) && (x_coord <= (int)((uint)*pbVar2 + iVar1)))
          && ((int)((uint)pbVar2[1] - iVar1) <= y_coord)) &&
         (y_coord <= (int)((uint)pbVar2[1] + iVar1))) {
        return plant_map + iVar3 * 0x18;
      }
    }
    iVar3 = iVar3 + 1;
    pbVar2 = pbVar2 + 0x18;
    if (0x3f < iVar3) {
      return 0;
    }
  } while( true );
}



// Setting prototype: int is_plant_map_slot_free(void *plant_map, uint32_t x_coord, uint32_t
// y_coord, int size)

int handleIsPlantMapSlotFree(void *plant_map,uint32_t x_coord,uint32_t y_coord,int size)

{
  bool bVar1;
  byte *pbVar2;
  int iVar3;
  int iVar4;
  int local_4;
  
                    // 
                    // Checks if a plant map slot at the specified coordinates and size is free.
                    // 
                    // Parameters:
                    //   plant_map: Pointer to the plant map data.
                    //   x_coord: The X-coordinate.
                    //   y_coord: The Y-coordinate.
                    //   size: The size of the area to check.
                    // 
                    // Return values:
                    //   1 if the slot is free, 0 otherwise.
                    // 
  bVar1 = false;
  iVar4 = 0;
  pbVar2 = (byte *)((int)plant_map + 8);
  do {
    if (pbVar2[5] == 0xff) {
      bVar1 = true;
    }
    else if ((*pbVar2 == x_coord) && (pbVar2[1] == y_coord)) {
      return 0;
    }
    iVar4 = iVar4 + 1;
    pbVar2 = pbVar2 + 0x18;
    if (0x3f < iVar4) {
      if (!bVar1) {
        return 0;
      }
      local_4 = 0;
      if (0 < size) {
        do {
          iVar4 = 0;
          do {
            iVar3 = handleFindPlantMapSlotByCoords
                              (plant_map,(iVar4 - size / 2) + x_coord,(local_4 - size / 2) + y_coord
                              );
            if (iVar3 != 0) {
              return 0;
            }
            iVar4 = iVar4 + 1;
          } while (iVar4 < size);
          local_4 = local_4 + 1;
        } while (local_4 < size);
      }
      return 1;
    }
  } while( true );
}



// Setting prototype: void *set_plant_map_slot(void *plant_map, uint32_t x_coord, uint32_t y_coord,
// int map_id, int plant_type)

int handleSetPlantMapSlot(int plant_map,uint x_coord,uint y_coord,int map_id,int plant_type)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  byte *pbVar4;
  
                    // 
                    // Sets a specific slot in the plant map.
                    // 
                    // Parameters:
                    //   plant_map: Pointer to the plant map data.
                    //   x_coord: The X-coordinate of the slot.
                    //   y_coord: The Y-coordinate of the slot.
                    //   map_id: The ID of the map.
                    //   plant_type: The type of plant to set.
                    // 
                    // Return values:
                    //   A pointer to the modified slot, or NULL on failure.
                    // 
  iVar1 = handleGetPlantMap(map_id);
  if (plant_map == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_auxilla_1002d9c0,0x83,
               s_plt_SetPlantMap____Map_is_not_al_1002d9ec,1);
    return 0;
  }
  iVar3 = 0;
  pbVar4 = (byte *)(plant_map + 9);
  do {
    if (((pbVar4[-1] == x_coord) && (*pbVar4 == y_coord)) && (pbVar4[4] != 0xff)) goto LAB_10015155;
    iVar3 = iVar3 + 1;
    pbVar4 = pbVar4 + 0x18;
  } while (iVar3 < 0x40);
  iVar3 = 0;
  pcVar2 = (char *)(plant_map + 0xd);
  while (*pcVar2 != -1) {
    iVar3 = iVar3 + 1;
    pcVar2 = pcVar2 + 0x18;
    if (0x3f < iVar3) {
      logMessage(s_D__Develop_DieGildeAddOn_auxilla_1002d9c0,0x9b,
                 s_plt_SetPlantMap____Could_not_fin_1002d990,1);
      return 0;
    }
  }
  *(int *)(plant_map + iVar3 * 0x18) = DAT_1003540c;
  DAT_1003540c = DAT_1003540c + 1;
LAB_10015155:
  plant_map = plant_map + iVar3 * 0x18;
  *(short *)(plant_map + 10) = (short)map_id;
  if (plant_type == 0) {
    *(undefined4 *)(plant_map + 0x10) = 0xffffffff;
    if (map_id == 0) {
      *(undefined1 *)(plant_map + 0xd) = 0xff;
    }
    else {
      *(undefined1 *)(plant_map + 0xd) = 1;
    }
  }
  *(undefined1 *)(plant_map + 9) = (undefined1)y_coord;
  *(undefined1 *)(plant_map + 8) = (undefined1)x_coord;
  if (iVar1 != 0) {
    *(undefined1 *)(plant_map + 0xc) = *(undefined1 *)(iVar1 + 0x42);
    return plant_map;
  }
  *(undefined1 *)(plant_map + 0xc) = 0;
  return plant_map;
}



// Setting prototype: int get_resource_data(int resource_id, void *resource_data)

int handleGetResourceData(int resource_id,void *resource_data)

{
                    // 
                    // Retrieves resource data based on the resource ID.
                    // 
                    // Parameters:
                    //   resource_id: The ID of the resource.
                    //   resource_data: Pointer to a buffer to store the resource data.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  if (0x57 < resource_id) {
    return 0;
  }
  *(undefined4 *)resource_data = *(undefined4 *)(&DAT_1002da30 + resource_id * 8);
  *(undefined4 *)((int)resource_data + 4) = *(undefined4 *)(&DAT_1002da34 + resource_id * 8);
  return 1;
}



// Setting prototype: uint32_t create_citizen(void *game_data)

uint32_t handleCreateCitizen(void *game_data)

{
  uint16_t uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int *piVar5;
  undefined2 extraout_var;
  int iVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  uint local_20;
  int local_18 [6];
  
                    // 
                    // Creates a new citizen in the game.
                    // 
                    // Parameters:
                    //   game_data: Pointer to the game's data structure.
                    // 
                    // Return values:
                    //   The ID of the created citizen, or 0 on failure.
                    // 
  iVar9 = 0;
  local_18[0] = 0x60;
  local_18[1] = 0x4b;
  local_18[2] = 0x28;
  local_18[3] = 0x17;
  local_18[4] = 9;
  local_18[5] = 0;
  uVar7 = 0x300;
  do {
    uVar2 = get_random_number((uint16_t)uVar7);
    uVar3 = uVar2 & 0xffff;
    uVar4 = uVar3 * 0xf;
    iVar6 = uVar3 * 0x21c;
    if ((&DAT_100358a0)[uVar3 * 0x10e] == -1) {
      uVar4 = (int)(uVar7 * 3 + ((int)(uVar7 * 3) >> 0x1f & 3U)) >> 2;
      uVar7 = uVar4;
    }
    else if (((5 < (byte)(&DAT_100358a2)[iVar6]) ||
             (uVar4 = 0,
             (float)*(ushort *)(&DAT_100358aa + iVar6) < *(float *)(&DAT_100358c0 + iVar6))) ||
            (uVar4 = 0, (&DAT_100358a8)[iVar6] == '\0')) {
      uVar2 = 0xffff;
    }
    else {
      piVar5 = (int *)(&DAT_10035908 + iVar6);
      iVar8 = 0;
      iVar6 = 5;
      do {
        if (*piVar5 != -1) {
          iVar8 = iVar8 + 1;
        }
        piVar5 = piVar5 + 1;
        iVar6 = iVar6 + -1;
      } while (iVar6 != 0);
      uVar4 = get_random_number(0x100);
      uVar4 = (uVar4 & 0xffff) + 1;
      if ((int)uVar4 < local_18[iVar8]) break;
    }
    iVar9 = iVar9 + 1;
  } while (iVar9 < 0x10);
  if ((short)uVar2 == -1) {
    return uVar4 & 0xffff0000;
  }
  local_20 = 0;
  do {
    uVar4 = get_random_number((uint16_t)uVar7);
    iVar9 = (uVar4 & 0xffff) * 0x21c;
    if ((&DAT_100358a0)[(uVar4 & 0xffff) * 0x10e] == -1) {
      uVar7 = (int)(uVar7 * 3 + ((int)(uVar7 * 3) >> 0x1f & 3U)) >> 2;
    }
    else if (((5 < (byte)(&DAT_100358a2)[iVar9]) ||
             ((float)*(ushort *)(&DAT_100358aa + iVar9) < *(float *)(&DAT_100358c0 + iVar9))) ||
            ((&DAT_100358a8)[iVar9] == '\0')) {
      uVar4 = 0xffff;
    }
    else {
      piVar5 = (int *)(&DAT_10035908 + iVar9);
      iVar6 = 0;
      iVar9 = 5;
      do {
        if (*piVar5 != -1) {
          iVar6 = iVar6 + 1;
        }
        piVar5 = piVar5 + 1;
        iVar9 = iVar9 + -1;
      } while (iVar9 != 0);
      uVar3 = get_random_number(0x100);
      uVar3 = (uVar3 & 0xffff) + 1;
      if ((int)uVar3 < local_18[iVar6]) break;
    }
    uVar3 = local_20 + 1;
    local_20 = uVar3;
  } while ((int)uVar3 < 0x10);
  if ((short)uVar4 != -1) {
    uVar1 = gm_AllocPlayer(0,(&DAT_100358a4)[(uVar2 & 0xffff) * 0x87],
                           (&DAT_100358a4)[(uVar4 & 0xffff) * 0x87],game_data,(void *)0x0,'\0',0,2);
    return CONCAT22(extraout_var,uVar1);
  }
  return uVar3 & 0xffff0000;
}



// Setting prototype: void add_citizen_to_building(void *building_data, void *citizen_data)

void handleAddCitizenToBuilding(void *building_data,void *citizen_data)

{
  int iVar1;
  ushort local_8 [4];
  
                    // 
                    // Adds a citizen to a building.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   citizen_data: Pointer to the citizen's data structure.
                    // 
                    // WARNING: Load size is inaccurate
  handleGetResourceData((uint)*citizen_data,local_8);
  if (*(byte *)((int)citizen_data + 0x65) < local_8[0]) {
    iVar1 = *(int *)((int)building_data + 0x170);
    if ((iVar1 != 0) && (*(char *)(iVar1 + 0x65) != '\0')) {
      *(char *)(iVar1 + 0x65) = *(char *)(iVar1 + 0x65) + -1;
    }
    *(void **)((int)building_data + 0x170) = citizen_data;
    *(char *)((int)citizen_data + 0x65) = *(char *)((int)citizen_data + 0x65) + '\x01';
  }
  return;
}



// Setting prototype: void remove_citizen_from_building(void *citizen_data)

void handleRemoveCitizenFromBuilding(void *citizen_data)

{
  char cVar1;
  
                    // 
                    // Removes a citizen from a building.
                    // 
                    // Parameters:
                    //   citizen_data: Pointer to the citizen's data structure.
                    // 
                    // WARNING: Load size is inaccurate
  cVar1 = *(char *)(DAT_100a8c30 + (uint)*citizen_data * 0x24d);
  if (cVar1 == '\x01') {
    handleFindObjectInList(*(undefined4 *)((int)citizen_data + 0x5d),1,0,0x12);
    return;
  }
  if (cVar1 == '\x02') {
    handleFindObjectInList(*(undefined4 *)((int)citizen_data + 0x5d),1,0,0x13);
    return;
  }
  if (cVar1 == '\x1d') {
    handleFindObjectInList(*(undefined4 *)((int)citizen_data + 0x5d),1,0,0xfd);
    return;
  }
  if (cVar1 == '\x16') {
    handleFindObjectInList(*(undefined4 *)((int)citizen_data + 0x5d),1,0,0x120);
  }
  return;
}



// Setting prototype: void *create_citizen_2(uint8_t flags, uint32_t player_id, void *game_data,
// uint8_t gender, uint8_t age)

undefined2 *
handleCreateCitizen2(byte flags,uint32_t player_id,void *game_data,uint8_t gender,byte age)

{
  uint16_t uVar1;
  uint32_t uVar2;
  uint uVar3;
  
                    // 
                    // Creates a new citizen with specified properties.
                    // 
                    // Parameters:
                    //   flags: Flags for citizen creation.
                    //   player_id: The ID of the player.
                    //   game_data: Pointer to the game's data structure.
                    //   gender: The gender of the citizen.
                    //   age: The age of the citizen.
                    // 
                    // Return values:
                    //   A pointer to the created citizen's data, or NULL on failure.
                    // 
  if ((flags & 1) == 0) {
    uVar1 = gm_AllocPlayer(player_id,0xffffffff,0xffffffff,game_data,(void *)0x0,gender,(uint)age,2)
    ;
    uVar3 = (uint)uVar1;
  }
  else {
    uVar2 = handleCreateCitizen(game_data);
    uVar3 = uVar2 & 0xffff;
    if (uVar3 == 0xffff) goto LAB_10015585;
    if ((flags & 2) != 0) {
      (&DAT_10035a05)[uVar3 * 0x21c] = age;
      (&DAT_10035a04)[uVar3 * 0x21c] = gender;
    }
  }
  if (uVar3 != 0xffff) {
    return &DAT_100358a0 + uVar3 * 0x10e;
  }
LAB_10015585:
  logMessage(s_D__Develop_DieGildeAddOn_game_si_1002dcf4,0x127d,
             s_sim_CreateCitizen____could_not_a_1002dd18,1);
  return (undefined2 *)0x0;
}



// Setting prototype: int update_citizen_age(void *citizen_data, int days, int months, int years)

int sim_UpdateCitizenAge(void *citizen_data,int days,int months,int years)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
                    // 
                    // Updates a citizen's age by adding days, months, and years.
                    // 
                    // Parameters:
                    //   citizen_data: Pointer to the citizen's data structure.
                    //   days: Number of days to add.
                    //   months: Number of months to add.
                    //   years: Number of years to add.
                    // 
                    // Return values:
                    //   The updated age in years.
                    // 
  iVar1 = years + *(int *)((int)citizen_data + 10);
  *(int *)((int)citizen_data + 6) = *(int *)((int)citizen_data + 6) + iVar1 / 0x3c;
  *(int *)((int)citizen_data + 10) = iVar1 % 0x3c;
  iVar1 = *(int *)((int)citizen_data + 6) + months;
  *(short *)((int)citizen_data + 4) =
       *(short *)((int)citizen_data + 4) +
       (((short)(iVar1 / 0x3c) + (short)(iVar1 >> 0x1f)) -
       (short)((longlong)iVar1 * 0x88888889 >> 0x3f));
  iVar2 = iVar1 / 0x3c;
  *(int *)((int)citizen_data + 6) = iVar1 % 0x3c;
  uVar4 = (uint)*(ushort *)((int)citizen_data + 4) + days;
  if (0x17 < (int)uVar4) {
    uVar3 = uVar4 / 0x18;
    uVar4 = uVar4 % 0x18;
    do {
                    // WARNING: Load size is inaccurate
      iVar2 = *citizen_data + 1;
      uVar3 = uVar3 - 1;
      *(int *)citizen_data = iVar2;
    } while (uVar3 != 0);
  }
  if ((int)uVar4 < 0) {
    uVar3 = (0x17 - uVar4) / 0x18;
    iVar1 = uVar4 + uVar3 * 0x18;
    do {
                    // WARNING: Load size is inaccurate
      uVar3 = uVar3 - 1;
      *(int *)citizen_data = *citizen_data + -1;
    } while (uVar3 != 0);
    *(short *)((int)citizen_data + 4) = (short)iVar1;
    return iVar1;
  }
  *(short *)((int)citizen_data + 4) = (short)uVar4;
  return iVar2;
}



// Setting prototype: void set_citizen_data(void *citizen_data, uint8_t gender, uint32_t age,
// uint32_t birth_year)

void sim_SetCitizenData(void *citizen_data,uint8_t gender,uint32_t age,uint32_t birth_year)

{
                    // 
                    // Sets various data fields for a citizen.
                    // 
                    // Parameters:
                    //   citizen_data: Pointer to the citizen's data structure.
                    //   gender: The gender of the citizen.
                    //   age: The age of the citizen.
                    //   birth_year: The birth year of the citizen.
                    // 
  *(ushort *)((int)citizen_data + 4) = (ushort)gender;
  *(uint32_t *)((int)citizen_data + 10) = birth_year & 0xff;
  *(uint32_t *)((int)citizen_data + 6) = age & 0xff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void init_object_manufacturer(void)

void handleInitObjectManufacturer(void)

{
  char *pcVar1;
  char cVar2;
  char cVar3;
  uint uVar4;
  int iVar5;
  int *piVar6;
  int iVar7;
  int iVar8;
  byte *pbVar9;
  char *pcVar10;
  undefined4 *puVar11;
  int iVar12;
  int local_24;
  int local_20;
  ushort *local_1c;
  int local_18;
  int local_c;
  int local_8;
  
  puVar11 = &DAT_10139820;
                    // 
                    // Initializes the object manufacturer, setting up various parameters and data
                    // structures related to object creation.
                    // 
  for (iVar7 = 0x19; iVar7 != 0; iVar7 = iVar7 + -1) {
    *puVar11 = 0;
    puVar11 = puVar11 + 1;
  }
  local_24 = 0;
  local_20 = 0;
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x458,
             s_gm_InitObjektHersteller____fill_t_1003102c,1);
  _DAT_10139840 = 0x2f;
  _DAT_1013983c = 0x32;
  _DAT_10139838 = 0x29;
  _DAT_10139848 = 0x21;
  _DAT_10139858 = 0x1e;
  _DAT_1013985c = 0x1f;
  _DAT_10139860 = 0x20;
  _DAT_1013984c = 0x17;
  _DAT_10139850 = 0x35;
  _DAT_10139844 = 0x14;
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x46d,
             s_gm_InitObjektHersteller____Initi_10030fb0,1);
  iVar7 = DAT_100a8c30;
  puVar11 = &DAT_101dd8e0;
  for (iVar8 = 0x2dc; iVar8 != 0; iVar8 = iVar8 + -1) {
    *puVar11 = 0x58;
    puVar11 = puVar11 + 1;
  }
  local_18 = 0;
  local_8 = 0;
  cVar3 = 'X';
  do {
    pcVar1 = (char *)(iVar7 + local_8);
    cVar2 = *pcVar1;
    if (cVar2 == cVar3) {
      local_24 = local_24 + 1;
      cVar2 = cVar3;
    }
    else {
      local_24 = 0;
      local_20 = 0;
      iVar7 = local_18;
      pcVar10 = pcVar1;
      if (local_8 < 0xca78) {
        do {
          if (*pcVar10 != cVar2) break;
          local_20 = local_20 + 1;
          iVar7 = iVar7 + 1;
          pcVar10 = pcVar10 + 0x24d;
        } while (iVar7 < 0x58);
      }
    }
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x490,&DAT_10030f54,1);
    iVar7 = DAT_100a8c30;
    local_c = 0;
    if (pcVar1[0x22] != '\0') {
      local_1c = (ushort *)(pcVar1 + 0x23);
      do {
        if (*local_1c != 0xffff) {
          uVar4 = *local_1c & 0x7fff;
          iVar8 = (&DAT_10139820)[*(byte *)(uVar4 * 0x41 + 0x21 + DAT_101de450)];
          pcVar10 = (char *)(iVar7 + iVar8 * 0x24d);
          cVar3 = *pcVar10;
          iVar5 = 0;
          iVar12 = iVar8;
          for (; (iVar12 < 0x58 && (*pcVar10 == cVar3)); pcVar10 = pcVar10 + 0x24d) {
            iVar5 = iVar5 + 1;
            iVar12 = iVar12 + 1;
          }
          iVar8 = iVar8 + (iVar5 * local_24) / local_20;
          if (iVar8 < (int)(&DAT_101dd8e0)[uVar4]) {
            (&DAT_101dd8e0)[uVar4] = iVar8;
          }
        }
        local_c = local_c + 1;
        local_1c = local_1c + 1;
      } while (local_c < (int)(uint)(byte)pcVar1[0x22]);
    }
    local_8 = local_8 + 0x24d;
    local_18 = local_18 + 1;
    cVar3 = cVar2;
    if (0xca77 < local_8) {
      logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x4ae,
                 s_gm_InitObjektHersteller____Initi_10030eec,1);
      piVar6 = &DAT_101dd8e0;
      pbVar9 = (byte *)(DAT_101de450 + 0x21);
      do {
        if (*piVar6 == 0x58) {
          *piVar6 = (&DAT_10139820)[*pbVar9];
        }
        piVar6 = piVar6 + 1;
        pbVar9 = pbVar9 + 0x41;
      } while ((int)piVar6 < 0x101de450);
      return;
    }
  } while( true );
}



// Setting prototype: int open_game_data(const char *game_path)

undefined4 load_game_data(undefined4 game_path)

{
  char cVar1;
  ushort uVar2;
  undefined4 uVar3;
  char cVar4;
  undefined4 *puVar5;
  undefined1 *puVar6;
  int iVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  int iVar10;
  undefined4 *puVar11;
  ushort *puVar12;
  int local_204;
  undefined1 local_200 [512];
  
                    // 
                    // Opens game data files and initializes various game-related data structures.
                    // This includes loading building prototypes, object prototypes, and setting up
                    // the object manufacturer.
                    // 
                    // Parameters:
                    //   game_path: Path to the game data directory.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x4d3,s_gm_Open____enter_10031218,1);
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x4d6,&DAT_10031204,1);
  puVar8 = &DAT_100a8cf8;
  puVar5 = &DAT_1009b764;
  do {
    puVar11 = puVar5 + 3;
    puVar5[-1] = puVar8[-0x14];
    uVar3 = *puVar8;
    *puVar5 = 1000;
    puVar5[1] = uVar3;
    puVar5[2] = 1000;
    puVar8 = puVar8 + 0xbd;
    puVar5 = puVar5 + 0xaa4;
    puVar9 = &DAT_1002dde0;
    for (iVar7 = 0xaa0; iVar7 != 0; iVar7 = iVar7 + -1) {
      *puVar11 = *puVar9;
      puVar9 = puVar9 + 1;
      puVar11 = puVar11 + 1;
    }
  } while ((int)puVar8 < 0x100a9bbc);
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x4e3,&DAT_100311f0,1);
  DAT_100a8c30 = (void *)mAlloc(0xca78,s_f3_gm_lpGebaeudePROT_100311d8);
  if (DAT_100a8c30 == (void *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x4e8,
               s_Memory_could_not_be_allocated__100311b8,1);
    return 0xffffffff;
  }
  DAT_1014d8c0 = (undefined4 *)mAlloc(0xa900,s_f3_gm_lpGebaeudeINST_100311a0);
  puVar5 = DAT_1014d8c0;
  for (iVar7 = 0x2a40; iVar7 != 0; iVar7 = iVar7 + -1) {
    *puVar5 = 0;
    puVar5 = puVar5 + 1;
  }
  if (DAT_1014d8c0 == (undefined4 *)0x0) {
    return 0xfffffffe;
  }
  printf_wrapper(local_200,&DAT_1003118c,game_path,s_A_Geb_dat_10031194);
  puVar6 = local_200;
  open_file_wrapper(puVar6,&DAT_1002944c);
  if (puVar6 == (undefined1 *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x4f5,&DAT_10031154,1);
    return 0xfffffffd;
  }
  file_read_3(DAT_100a8c30,0x24d,0x58,puVar6);
  fclose_wrapper(puVar6);
  DAT_101de450 = (void *)mAlloc(0xb9dc,s_f3_gm_lpObjektePROT_10031140);
  if (DAT_101de450 == (void *)0x0) {
    return 0xfffffffc;
  }
  DAT_100a8c34 = (undefined4 *)mAlloc(0x14f218,s_f3_gm_lpObjekteINST_1003112c);
  if (DAT_100a8c34 == (undefined4 *)0x0) {
    return 0xfffffffb;
  }
  puVar5 = DAT_100a8c34;
  for (iVar7 = 0x53c86; iVar7 != 0; iVar7 = iVar7 + -1) {
    *puVar5 = 0;
    puVar5 = puVar5 + 1;
  }
  printf_wrapper(local_200,&DAT_1003118c,game_path,s_A_Obj_dat_10031120);
  puVar6 = local_200;
  open_file_wrapper(puVar6,&DAT_1002944c);
  if (puVar6 == (undefined1 *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x52d,
               s_Objekt_Daten_konnten_nicht_gelad_100310e8,1);
    return 0xfffffffa;
  }
  file_read_3(DAT_101de450,0x41,0x2dc,puVar6);
  fclose_wrapper(puVar6);
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x536,
             s_gm_Open____gm_InitObjektHerstell_100310c4,1);
  handleInitObjectManufacturer();
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x53a,
             s_gm_Open____gm_KillAllSpieler_100310a4,1);
  remove_all_players();
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x53e,
             s_gm_Open_________Das_dusselige_Da_10031064,1);
  iVar7 = 0;
  do {
    cVar4 = '\0';
    local_204 = 0x40;
    puVar12 = (ushort *)(iVar7 + 0x23 + (int)DAT_100a8c30);
    do {
      uVar2 = *puVar12;
      if (uVar2 != 0xffff) {
        cVar1 = *(char *)((int)DAT_101de450 + (uVar2 & 0x7fff) * 0x41);
        if ((((cVar1 == '\x02') || (cVar1 == '\x06')) && ((uVar2 & 0x7fff) != 0xfd)) &&
           ((uVar2 & 0x8000) != 0)) {
          cVar4 = cVar4 + '\x01';
        }
      }
      puVar12 = puVar12 + 1;
      local_204 = local_204 + -1;
    } while (local_204 != 0);
    iVar10 = iVar7 + 0x24d;
    *(char *)(iVar7 + 0x21 + (int)DAT_100a8c30) =
         *(char *)(iVar7 + 0x21 + (int)DAT_100a8c30) + cVar4;
    iVar7 = iVar10;
  } while (iVar10 < 0xca78);
  init_random();
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x588,s_gm_Open____exit_10031054,1);
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void load_game_data_2(void)

void handleLoadGameData2(void)

{
  int iVar1;
  undefined4 *puVar2;
  
                    // 
                    // Loads game data, specifically related to building instances.
                    // This function appears to reset and reinitialize building instance data.
                    // 
  iVar1 = 0;
  do {
    if (*(char *)((int)DAT_1014d8c0 + iVar1) != '\0') {
      gm_FreeBuilding((char *)((int)DAT_1014d8c0 + iVar1));
    }
    iVar1 = iVar1 + 0xa9;
  } while (iVar1 < 0xa900);
  puVar2 = DAT_1014d8c0;
  for (iVar1 = 0x2a40; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void load_game_data_3(void)

void handleLoadGameData3(void)

{
  void *list_ptr;
  int iVar1;
  undefined4 *puVar2;
  void *local_c;
  void *local_8;
  void *local_4;
  
                    // 
                    // Loads game data, specifically related to object instances.
                    // This function appears to clean up and reinitialize object instance data.
                    // 
  iVar1 = 0;
  do {
    if (*(short *)(iVar1 + (int)DAT_100a8c34) != 0) {
      gm_LoadGameData(&local_c,&local_8,&local_4,*(uint32_t *)(iVar1 + 6 + (int)DAT_100a8c34));
      if (local_c == (void *)0x0) {
        if (local_8 != (void *)0x0) {
          list_ptr = (void *)((int)local_8 + 0x14);
          goto LAB_10015d4a;
        }
        if (local_4 != (void *)0x0) {
          list_ptr = (void *)((int)local_4 + 0x178);
          goto LAB_10015d4a;
        }
      }
      else {
        list_ptr = (void *)((int)local_c + 0x5d);
LAB_10015d4a:
        if (list_ptr != (void *)0x0) {
          handleRemoveObjectFromList(list_ptr,(uint)*(ushort *)(iVar1 + (int)DAT_100a8c34));
          goto LAB_10015d8e;
        }
      }
      handleNoop2();
      *(undefined2 *)(iVar1 + (int)DAT_100a8c34) = 0;
      DAT_10035450 = DAT_10035450 + -1;
    }
LAB_10015d8e:
    iVar1 = iVar1 + 0x43;
    if (0x14f217 < iVar1) {
      puVar2 = DAT_100a8c34;
      for (iVar1 = 0x53c86; iVar1 != 0; iVar1 = iVar1 + -1) {
        *puVar2 = 0;
        puVar2 = puVar2 + 1;
      }
      return;
    }
  } while( true );
}



// Setting prototype: void *load_game_data_4(uint32_t object_id)

int handleLoadGameData4(int object_id)

{
  int iVar1;
  short *psVar2;
  
                    // 
                    // Loads game data, specifically an object instance by its ID.
                    // 
                    // Parameters:
                    //   object_id: The ID of the object to load.
                    // 
                    // Return values:
                    //   A pointer to the object's data, or NULL if not found.
                    // 
  iVar1 = 0;
  psVar2 = DAT_100a8c34;
  while ((*psVar2 == 0 || (*(int *)(psVar2 + 1) != object_id))) {
    iVar1 = iVar1 + 1;
    psVar2 = (short *)((int)psVar2 + 0x43);
    if (0x5007 < iVar1) {
      return 0;
    }
  }
  return (int)DAT_100a8c34 + iVar1 * 0x43;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void load_game_data_5(void)

void handleLoadGameData5(void)

{
  void *building_data;
  
                    // 
                    // Loads game data, specifically related to clearing and freeing memory
                    // associated with buildings and objects.
                    // 
  building_data = (void *)gm_FindObject(1,6);
  while (building_data != (void *)0x0) {
    gm_FreeBuilding(building_data);
    building_data = (void *)handleGetNextBuilding();
  }
  if (DAT_100a8c30 != (void *)0x0) {
    m_free(DAT_100a8c30);
    DAT_100a8c30 = (void *)0x0;
  }
  if (DAT_1014d8c0 != (void *)0x0) {
    m_free(DAT_1014d8c0);
    DAT_1014d8c0 = (void *)0x0;
  }
  if (DAT_101de450 != (void *)0x0) {
    m_free(DAT_101de450);
    DAT_101de450 = (void *)0x0;
  }
  if (DAT_100a8c34 != (void *)0x0) {
    m_free(DAT_100a8c34);
    DAT_100a8c34 = (void *)0x0;
  }
  return;
}



// Setting prototype: int load_game_data_6(void **building_data_ptr, void **object_data_ptr, void
// **alchemist_data_ptr, uint32_t id)

int gm_LoadGameData(void **building_data_ptr,void **object_data_ptr,void **alchemist_data_ptr,
                   uint32_t id)

{
  short *psVar1;
  char *pcVar2;
  int iVar3;
  
                    // 
                    // Loads game data by ID, returning pointers to different data structures.
                    // 
                    // Parameters:
                    //   building_data_ptr: Pointer to store the building data.
                    //   object_data_ptr: Pointer to store the object data.
                    //   alchemist_data_ptr: Pointer to store the alchemist data.
                    //   id: The ID of the data to retrieve.
                    // 
                    // Return values:
                    //   A status code indicating which data type was found (1 for building, 2 for
                    // object, 3 for alchemist), or 0 if not found.
                    // 
  if (DAT_101de450 != 0) {
    if (building_data_ptr != (void **)0x0) {
      *building_data_ptr = (void *)0x0;
    }
    if (object_data_ptr != (void **)0x0) {
      *object_data_ptr = (void *)0x0;
    }
    if (alchemist_data_ptr != (void **)0x0) {
      *alchemist_data_ptr = (void *)0x0;
      psVar1 = &DAT_100358a0;
      iVar3 = 0;
      do {
        if ((*psVar1 != -1) && (*(uint32_t *)(psVar1 + 2) == id)) {
          *alchemist_data_ptr = psVar1;
          return 3;
        }
        psVar1 = psVar1 + 0x10e;
        iVar3 = iVar3 + 1;
      } while (iVar3 < 0x300);
    }
    if (building_data_ptr != (void **)0x0) {
      iVar3 = 0;
      pcVar2 = DAT_1014d8c0;
      do {
        if ((*pcVar2 != '\0') && (*(uint32_t *)(pcVar2 + 1) == id)) {
          *building_data_ptr = pcVar2;
          return 1;
        }
        iVar3 = iVar3 + 1;
        pcVar2 = pcVar2 + 0xa9;
      } while (iVar3 < 0x100);
    }
    if ((object_data_ptr != (void **)0x0) && (iVar3 = 0, psVar1 = DAT_100a8c34, 0 < DAT_10035450)) {
      do {
        if (*psVar1 != 0) {
          if (*(uint32_t *)(psVar1 + 1) == id) {
            *object_data_ptr = psVar1;
            return 2;
          }
          iVar3 = iVar3 + 1;
        }
        psVar1 = (short *)((int)psVar1 + 0x43);
      } while (iVar3 < DAT_10035450);
    }
  }
  return 0;
}



// Setting prototype: void load_game_data_7(uint32_t game_data_id)

void handleLoadGameData7(uint32_t game_data_id)

{
  undefined4 *puVar1;
  byte *pbVar2;
  int iVar3;
  int iVar4;
  ushort *puVar5;
  ushort *puVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  ushort *puVar10;
  ushort *puVar11;
  undefined4 local_20;
  int local_1c [7];
  
                    // 
                    // Loads game data, specifically related to object availability and market
                    // information.
                    // 
                    // Parameters:
                    //   game_data_id: The ID of the game data to load.
                    // 
  local_20 = 0x92;
  local_1c[0] = 0x93;
  local_1c[1] = 0x94;
  local_1c[2] = 0x95;
  local_1c[3] = 0x96;
  local_1c[4] = 0x97;
  local_1c[5] = 0x2db;
  local_1c[6] = 0;
  DAT_1003543c = gm_FindObject(1,5,10);
  if (DAT_1003543c != 0) {
    puVar10 = (ushort *)(&DAT_1009b770 + game_data_id * 0xaa4);
    if (game_data_id == DAT_10035439) {
      puVar1 = (undefined4 *)(&DAT_1009b774 + game_data_id * 0x2a90);
      iVar4 = 0x55;
      do {
        *puVar1 = 0;
        puVar1 = puVar1 + 0x20;
        iVar4 = iVar4 + -1;
      } while (iVar4 != 0);
      pbVar2 = (byte *)gm_FindObject(1,6);
      while (pbVar2 != (byte *)0x0) {
        if (*(char *)(DAT_100a8c30 + (uint)*pbVar2 * 0x24d) != '\n') {
          iVar4 = handleFindObjectInList(*(undefined4 *)(pbVar2 + 0x5d),1,0,0xff);
          game_data_id = 0;
          puVar11 = puVar10;
          if (iVar4 != 0) {
            for (; (int)game_data_id < 0x55; game_data_id = game_data_id + 1) {
              if ((*puVar11 != 0) &&
                 (iVar3 = handleFindObjectInList(*(undefined4 *)(iVar4 + 0x14),1,0,*puVar11),
                 iVar3 != 0)) {
                puVar11[2] = 1;
                puVar11[3] = 0;
                iVar7 = 0x55;
                iVar3 = DAT_101de450 + (uint)*puVar11 * 0x41;
                puVar6 = puVar10;
                do {
                  puVar5 = (ushort *)(iVar3 + 0x2e);
                  iVar9 = 4;
                  do {
                    if (*puVar6 == *puVar5) {
                      puVar6[2] = 1;
                      puVar6[3] = 0;
                    }
                    puVar5 = puVar5 + 1;
                    iVar9 = iVar9 + -1;
                  } while (iVar9 != 0);
                  puVar6 = puVar6 + 0x40;
                  iVar7 = iVar7 + -1;
                } while (iVar7 != 0);
              }
              puVar11 = puVar11 + 0x40;
            }
          }
        }
        pbVar2 = (byte *)handleGetNextBuilding();
      }
      iVar4 = 0x55;
      do {
        iVar3 = handleFindObjectInList(*(undefined4 *)(DAT_1003543c + 0x5d),1,0,puVar10[0x1e]);
        if (((iVar3 != 0) &&
            (iVar3 = handleFindObjectInList(*(undefined4 *)(iVar3 + 0x14),1,0,0xff),
            *(int *)(puVar10 + 2) != 0)) &&
           (iVar7 = handleFindObjectInList(*(undefined4 *)(iVar3 + 0x14),1,0,*puVar10), iVar7 == 0))
        {
          gm_AllocObject(*(undefined4 *)(iVar3 + 2),*puVar10,1);
        }
        puVar10 = puVar10 + 0x40;
        iVar4 = iVar4 + -1;
      } while (iVar4 != 0);
      iVar4 = 0x92;
      puVar1 = &local_20;
      do {
        uVar8 = 0;
        iVar4 = handleFindObjectInList(*(undefined4 *)(DAT_1003543c + 0x5d),1,0,iVar4);
        if ((iVar4 != 0) &&
           (iVar3 = handleFindObjectInList(*(undefined4 *)(iVar4 + 0x14),1,0,0xff), iVar3 != 0)) {
          iVar3 = handleFindObjectInList(*(undefined4 *)(iVar3 + 0x14),1,5);
          while (iVar3 != 0) {
            uVar8 = uVar8 + 1;
            iVar3 = handleGetNextObjectFromList();
          }
          iVar4 = handleFindObjectInList(*(undefined4 *)(iVar4 + 0x14),1,4,0x11);
          if ((iVar4 != 0) && (*(byte *)(iVar4 + 0x1c) != uVar8)) {
            *(char *)(iVar4 + 0x1c) = (char)uVar8;
          }
        }
        iVar4 = puVar1[1];
        puVar1 = puVar1 + 1;
      } while (iVar4 != 0);
    }
    return;
  }
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,1999,
             s_gm_ObjectsAvailble____Kein_Markt_1003122c,1);
  return;
}



// Setting prototype: void *get_object_from_list(uint32_t list_id, uint32_t object_id)

undefined4 * gm_GetObjectFromList(int list_id,uint object_id)

{
  ushort *puVar1;
  int iVar2;
  
                    // 
                    // Retrieves an object from a specific list by its ID.
                    // 
                    // Parameters:
                    //   list_id: The ID of the list to search.
                    //   object_id: The ID of the object to retrieve.
                    // 
                    // Return values:
                    //   A pointer to the object's data, or NULL if not found.
                    // 
  iVar2 = 0;
  puVar1 = (ushort *)(&DAT_1009b770 + list_id * 0xaa4);
  do {
    if (*puVar1 == object_id) {
      return &DAT_1009b770 + iVar2 * 0x20 + list_id * 0xaa4;
    }
    iVar2 = iVar2 + 1;
    puVar1 = puVar1 + 0x40;
  } while (iVar2 < 0x55);
  return (undefined4 *)0x0;
}



// Setting prototype: void *get_next_object_from_list(void)

ushort * handleGetNextObjectFromList(void)

{
  ushort uVar1;
  uint16_t uVar2;
  ushort *puVar3;
  ushort *puVar4;
  ushort *puVar5;
  uint16_t uVar6;
  int iVar7;
  bool bVar8;
  
                    // 
                    // Retrieves the next object from the current iteration list.
                    // 
                    // Return values:
                    //   A pointer to the next object's data, or NULL if no more objects.
                    // 
  puVar4 = DAT_10035468;
  puVar5 = (ushort *)0x0;
  bVar8 = false;
  if (DAT_10035468 == (ushort *)0x0) {
    return (ushort *)0x0;
  }
  if (((DAT_10035454 != '\0') && (DAT_10035454 = '\0', DAT_1003545d != '\0')) &&
     (*(int *)(DAT_10035468 + 10) != 0)) {
    *(int *)(&DAT_101398a0 + DAT_100a8c38 * 4) = *(int *)(DAT_10035468 + 10);
    DAT_100a8c38 = DAT_100a8c38 + 1;
  }
  iVar7 = DAT_100a8c38;
  uVar6 = DAT_10030b9c;
  if (DAT_10035458 < DAT_10035450) {
    do {
      if (puVar4 == (ushort *)0x0) {
        return puVar5;
      }
      if (bVar8) {
        return puVar5;
      }
      uVar1 = *puVar4;
      puVar3 = DAT_10035468;
      while (DAT_10035468 = puVar4, uVar1 == 0) {
        puVar3 = (ushort *)((int)DAT_10035468 + 0x43);
        puVar4 = puVar3;
        uVar1 = *puVar3;
      }
      if (DAT_1003545e != '\0') {
        bVar8 = true;
      }
      if (DAT_10030b94 == 0x7fff) {
LAB_10016345:
        if (DAT_10030b98 != -1) {
          if (*(int *)(DAT_10035468 + 1) != DAT_10030b98) goto LAB_10016382;
          bVar8 = true;
        }
        if (uVar6 != 0xffff) {
          puVar4 = DAT_10035468;
          DAT_10035468 = puVar3;
          uVar2 = get_player_child(puVar4);
          iVar7 = DAT_100a8c38;
          uVar6 = DAT_10030b9c;
          if (uVar2 != DAT_10030b9c) {
            bVar8 = false;
            goto LAB_100163bc;
          }
          bVar8 = true;
        }
        if (DAT_10030b9e != -1) {
          bVar8 = *(char *)(DAT_101de450 + (uint)*DAT_10035468 * 0x41) == DAT_10030b9e;
        }
      }
      else {
        if (*DAT_10035468 == DAT_10030b94) {
          bVar8 = true;
          goto LAB_10016345;
        }
LAB_10016382:
        bVar8 = false;
      }
LAB_100163bc:
      if (DAT_1003545c == '\0') {
        if (bVar8) {
          puVar5 = DAT_10035468;
        }
        puVar4 = *(ushort **)((int)DAT_10035468 + 0x3f);
        DAT_10035468 = puVar4;
        if (puVar4 == (ushort *)0x0) {
          if ((DAT_1003545d != '\0') && (iVar7 != 0)) {
            puVar4 = *(ushort **)(&DAT_1013989c + iVar7 * 4);
            iVar7 = iVar7 + -1;
            DAT_10035468 = puVar4;
            DAT_100a8c38 = iVar7;
            if (*(int *)(puVar4 + 10) != 0) {
              *(int *)(&DAT_101398a0 + iVar7 * 4) = *(int *)(puVar4 + 10);
              goto LAB_1001643e;
            }
          }
        }
        else if ((*(int *)(puVar4 + 10) != 0) && (DAT_1003545d != '\0')) {
          *(int *)(&DAT_101398a0 + iVar7 * 4) = *(int *)(puVar4 + 10);
LAB_1001643e:
          iVar7 = iVar7 + 1;
          DAT_100a8c38 = iVar7;
        }
      }
      else {
        if (bVar8) {
          puVar5 = DAT_10035468;
        }
        puVar4 = (ushort *)((int)DAT_10035468 + 0x43);
        DAT_10035458 = DAT_10035458 + 1;
        DAT_10035468 = puVar4;
      }
    } while (DAT_10035458 < DAT_10035450);
  }
  return puVar5;
}



// Setting prototype: void *find_object_in_list(uint32_t list_id, uint32_t filter_flags)

int handleFindObjectInList(int list_id,int filter_flags)

{
  ushort *puVar1;
  ushort *puVar2;
  char cVar3;
  char cVar4;
  int iVar5;
  
                    // 
                    // Finds an object within a specified list based on various filter flags.
                    // 
                    // Parameters:
                    //   list_id: The ID of the list to search.
                    //   filter_flags: Flags to filter the search (e.g., object type, ID, etc.).
                    // 
                    // Return values:
                    //   A pointer to the found object's data, or NULL if not found.
                    // 
  if (DAT_101de450 == 0) {
    return 0;
  }
  cVar3 = '\0';
  cVar4 = '\0';
  DAT_10030b94 = 0x7fff;
  DAT_10030b98 = 0xffffffff;
  DAT_10030b9c = 0xffff;
  DAT_10030b9e = 0xff;
  DAT_1003545e = 0;
  DAT_1003545c = '\0';
  DAT_1003545d = '\0';
  DAT_10035454 = 1;
  DAT_10035458 = 0;
  DAT_100a8c38 = 0;
  if (0 < filter_flags) {
    puVar1 = (ushort *)&filter_flags;
    iVar5 = filter_flags;
    do {
      puVar2 = puVar1 + 2;
      switch((char)*puVar2) {
      case '\0':
        puVar2 = puVar1 + 4;
        DAT_10030b94 = (uint)*puVar2;
        break;
      case '\x01':
        DAT_10030b98 = *(undefined4 *)(puVar1 + 4);
        puVar2 = puVar1 + 4;
        break;
      case '\x03':
        DAT_10030b9c = puVar1[4];
        puVar2 = puVar1 + 4;
        break;
      case '\x04':
        DAT_10030b9e = (undefined1)puVar1[4];
        puVar2 = puVar1 + 4;
        break;
      case '\x05':
        DAT_1003545e = 1;
        break;
      case '\x06':
        cVar4 = '\x01';
        break;
      case '\a':
        cVar3 = '\x01';
      }
      iVar5 = iVar5 + -1;
      puVar1 = puVar2;
    } while (iVar5 != 0);
    DAT_1003545c = cVar3;
    DAT_1003545d = cVar4;
    if (cVar3 != '\0') {
      list_id = DAT_100a8c34;
      if (cVar4 != '\0') {
        logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xb66,
                   s_gm_ff_Objekt__Invalid_Combinatio_10031250,1);
        return 0;
      }
      goto LAB_10016566;
    }
  }
  if (list_id == 0) {
    return list_id;
  }
LAB_10016566:
  DAT_10035468 = list_id;
  iVar5 = handleGetNextObjectFromList();
  return iVar5;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void object_management(void)

void handleObjectManagement(void)

{
  short *psVar1;
  short *psVar2;
  short *psVar3;
  int iVar4;
  bool bVar5;
  
                    // 
                    // Manages objects, likely iterating through them and performing some
                    // operations.
                    // 
  iVar4 = 0;
  psVar1 = (short *)0x0;
  psVar2 = DAT_100a8c34;
  do {
    if (0x5007 < iVar4) {
      return;
    }
    psVar3 = psVar2;
    if (*psVar2 != 0) {
      iVar4 = iVar4 + 1;
      psVar3 = (short *)((int)psVar2 + 0x43);
      psVar2 = psVar1;
    }
    bVar5 = psVar2 == (short *)0x0;
    psVar1 = psVar2;
    psVar2 = psVar3;
  } while (bVar5);
  return;
}



// Setting prototype: int remove_object_from_list(void *list_ptr, uint32_t object_id)

int handleRemoveObjectFromList(void *list_ptr,uint32_t object_id)

{
  undefined4 *puVar1;
  ushort *puVar2;
  ushort *puVar3;
  int iVar4;
  
                    // 
                    // Removes an object from a linked list by its ID.
                    // 
                    // Parameters:
                    //   list_ptr: Pointer to the head of the linked list.
                    //   object_id: The ID of the object to remove.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  if (list_ptr == (void *)0x0) {
    return -1;
  }
                    // WARNING: Load size is inaccurate
  if (*list_ptr == (ushort *)0x0) {
    return -1;
  }
  iVar4 = 0;
  puVar2 = (ushort *)0x0;
  puVar3 = *list_ptr;
  do {
    if (*puVar3 == object_id) {
      if (puVar3 == (ushort *)0x0) {
        return -2;
      }
      if (*(int *)(puVar3 + 10) != 0) {
        handleFreeObjectList(puVar3 + 10);
      }
      handleNoop2();
      if (iVar4 == 0) {
        *(undefined4 *)list_ptr = *(undefined4 *)((int)puVar3 + 0x3f);
      }
      else {
        *(undefined4 *)((int)puVar2 + 0x3f) = *(undefined4 *)((int)puVar3 + 0x3f);
      }
      *puVar3 = 0;
      DAT_10035450 = DAT_10035450 + -1;
      return 0;
    }
    puVar1 = (undefined4 *)((int)puVar3 + 0x3f);
    iVar4 = iVar4 + 1;
    puVar2 = puVar3;
    puVar3 = (ushort *)*puVar1;
  } while ((ushort *)*puVar1 != (ushort *)0x0);
  return -2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void noop_2(void)

void handleNoop2(void)

{
                    // 
                    // This is a no-operation function, it does nothing.
                    // 
  return;
}



// Setting prototype: int remove_object_from_list_by_id(void *list_ptr, uint32_t object_id)

int handleRemoveObjectFromListById(void *list_ptr,uint32_t object_id)

{
  undefined4 *puVar1;
  undefined2 *puVar2;
  undefined2 *puVar3;
  int iVar4;
  
                    // 
                    // Removes an object from a linked list by its ID.
                    // 
                    // Parameters:
                    //   list_ptr: Pointer to the head of the linked list.
                    //   object_id: The ID of the object to remove.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
                    // WARNING: Load size is inaccurate
  if (*list_ptr == (undefined2 *)0x0) {
    return -1;
  }
  iVar4 = 0;
  puVar2 = (undefined2 *)0x0;
  puVar3 = *list_ptr;
  do {
    if (*(uint32_t *)(puVar3 + 1) == object_id) {
      if (puVar3 == (undefined2 *)0x0) {
        return -2;
      }
      if (*(int *)(puVar3 + 10) != 0) {
        handleFreeObjectList(puVar3 + 10);
      }
      handleNoop2();
      if (iVar4 == 0) {
        *(undefined4 *)list_ptr = *(undefined4 *)((int)puVar3 + 0x3f);
      }
      else {
        *(undefined4 *)((int)puVar2 + 0x3f) = *(undefined4 *)((int)puVar3 + 0x3f);
      }
      *puVar3 = 0;
      DAT_10035450 = DAT_10035450 + -1;
      return 0;
    }
    puVar1 = (undefined4 *)((int)puVar3 + 0x3f);
    iVar4 = iVar4 + 1;
    puVar2 = puVar3;
    puVar3 = (undefined2 *)*puVar1;
  } while ((undefined2 *)*puVar1 != (undefined2 *)0x0);
  return -2;
}



// Setting prototype: int free_object_list(void *list_ptr)

int handleFreeObjectList(void *list_ptr)

{
  int iVar1;
  
                    // 
                    // Frees all objects in a linked list and the list itself.
                    // 
                    // Parameters:
                    //   list_ptr: Pointer to the head of the linked list.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  if (list_ptr != (void *)0x0) {
                    // WARNING: Load size is inaccurate
    iVar1 = *list_ptr;
    if (iVar1 == 0) {
      return -1;
    }
    do {
      *(undefined4 *)list_ptr = *(undefined4 *)(iVar1 + 0x3f);
      if (*(int *)(iVar1 + 0x14) != 0) {
        handleFreeObjectList((void *)(iVar1 + 0x14));
      }
      handleNoop2();
                    // WARNING: Load size is inaccurate
      iVar1 = *list_ptr;
    } while (iVar1 != 0);
  }
  return 0;
}



// Setting prototype: void *alloc_object(uint32_t parent_id, uint32_t object_type, uint32_t flags)

ushort * gm_AllocObject(uint32_t parent_id,uint object_type,undefined4 flags)

{
  char cVar1;
  ushort *puVar2;
  ushort *puVar3;
  undefined4 *puVar4;
  ushort *puVar5;
  int iVar6;
  char *pcVar7;
  void *local_410;
  void *local_40c;
  void *local_408;
  char *local_404;
  CHAR local_400 [1024];
  
                    // 
                    // Allocates a new object and initializes its data.
                    // 
                    // Parameters:
                    //   parent_id: The ID of the parent object.
                    //   object_type: The type of object to allocate.
                    //   flags: Flags for object creation.
                    // 
                    // Return values:
                    //   A pointer to the allocated object's data, or NULL on failure.
                    // 
  puVar3 = (ushort *)0x0;
  local_40c = (void *)0x0;
  local_410 = (void *)0x0;
  local_408 = (void *)0x0;
  if (DAT_101de450 == 0) {
    return (ushort *)0x0;
  }
  if (parent_id == 0xffffffff) {
    pcVar7 = &DAT_10031310;
    iVar6 = 0xcb2;
LAB_1001679d:
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,iVar6,pcVar7,1);
    return (ushort *)0x0;
  }
  iVar6 = gm_LoadGameData(&local_410,&local_40c,&local_408,parent_id);
  if (iVar6 == 0) {
    pcVar7 = s_gm_AllocObjekt____Parent_not_fou_100312ec;
    iVar6 = 0xcb8;
    goto LAB_1001679d;
  }
  if (local_410 == (void *)0x0) {
    if (local_40c == (void *)0x0) {
      if (local_408 == (void *)0x0) {
        return (ushort *)0x0;
      }
      puVar4 = (undefined4 *)((int)local_408 + 0x178);
    }
    else {
      puVar4 = (undefined4 *)((int)local_40c + 0x14);
    }
  }
  else {
    puVar4 = (undefined4 *)((int)local_410 + 0x5d);
  }
  if (puVar4 != (undefined4 *)0x0) {
    puVar3 = (ushort *)*puVar4;
    if (puVar3 == (ushort *)0x0) {
      handleObjectManagement();
      if (puVar3 == (ushort *)0x0) {
        pcVar7 = s_gm_AllocObjekt____Kein_Platz_meh_100312c8;
        iVar6 = 0xcdd;
        goto LAB_1001679d;
      }
      *puVar4 = puVar3;
    }
    else {
      do {
        puVar2 = puVar3;
        puVar3 = *(ushort **)((int)puVar2 + 0x3f);
      } while (puVar3 != (ushort *)0x0);
      handleObjectManagement();
      if (puVar3 == (ushort *)0x0) {
        pcVar7 = s_gm_AllocObjekt____Kein_Platz_meh_100312c8;
        iVar6 = 0xcd4;
        goto LAB_1001679d;
      }
      *(ushort **)((int)puVar2 + 0x3f) = puVar3;
    }
  }
  local_404 = (char *)(DAT_101de450 + object_type * 0x41);
  *puVar3 = (ushort)object_type;
  printf_wrapper(local_400,s______>ObjID___i_ObjProt___i_100312ac,DAT_10030b6c,object_type & 0xffff)
  ;
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xcee,local_400,8);
  *(int *)(puVar3 + 1) = DAT_10030b6c;
  DAT_10030b6c = DAT_10030b6c + 1;
  if (local_410 == (void *)0x0) {
    if (local_40c == (void *)0x0) {
      if (local_408 != (void *)0x0) {
        *(undefined4 *)(puVar3 + 5) = *(undefined4 *)((int)local_408 + 4);
      }
    }
    else {
      *(undefined4 *)(puVar3 + 5) = *(undefined4 *)((int)local_40c + 10);
    }
  }
  else {
    *(undefined4 *)(puVar3 + 5) = *(undefined4 *)((int)local_410 + 1);
  }
  *(uint32_t *)(puVar3 + 3) = parent_id;
  *(undefined4 *)(puVar3 + 7) = flags;
  *(char *)(puVar3 + 9) = 'd';
  *(char *)((int)puVar3 + 0x13) = '\0';
  puVar3[10] = 0;
  puVar3[0xb] = 0;
  pcVar7 = (char *)((int)puVar3 + 0x3f);
  pcVar7[0] = '\0';
  pcVar7[1] = '\0';
  pcVar7[2] = '\0';
  pcVar7[3] = '\0';
  puVar2 = puVar3 + 0xe;
  DAT_10035450 = DAT_10035450 + 1;
  puVar5 = puVar2;
  for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {
    puVar5[0] = 0;
    puVar5[1] = 0;
    puVar5 = puVar5 + 2;
  }
  *puVar5 = 0;
  *(char *)(puVar5 + 1) = '\0';
  if (0x160 < (int)object_type) {
    switch(object_type) {
    case 0x174:
    case 0x176:
      puVar3[0x10] = 6;
      puVar3[0x11] = 0;
      break;
    case 0x24b:
    case 0x256:
    case 0x266:
      puVar2[0] = 0;
      puVar2[1] = 0;
      puVar3[0x10] = 0;
      puVar3[0x11] = 0;
    }
    goto switchD_1001695f_caseD_b9;
  }
  if (object_type == 0x160) {
switchD_1001695f_caseD_15e:
    puVar3[0x10] = 0xf;
    puVar3[0x11] = 0;
  }
  else {
    switch(object_type) {
    case 0xb8:
      *(char *)puVar2 = '\x06';
      break;
    case 300:
      puVar2[0] = 0xffff;
      puVar2[1] = 0xffff;
      puVar3[0x10] = 0xffff;
      puVar3[0x11] = 0xffff;
      puVar3[0x12] = 0xffff;
      puVar3[0x13] = 0xffff;
      *(int *)(puVar3 + 0x14) = DAT_10035880 + -1;
      break;
    case 0x12d:
      puVar2[0] = 0xffff;
      puVar2[1] = 0xffff;
      puVar3[0x10] = 0xffff;
      puVar3[0x11] = 0xffff;
      puVar3[0x12] = 0xffff;
      puVar3[0x13] = 0xffff;
      puVar3[0x14] = 0xffff;
      puVar3[0x15] = 0xffff;
      break;
    case 0x134:
    case 0x135:
    case 0x136:
      if (local_410 == (void *)0x0) {
        if (local_40c == (void *)0x0) {
          if (local_408 != (void *)0x0) {
            *(undefined4 *)(puVar3 + 5) = *(undefined4 *)((int)local_408 + 4);
          }
        }
        else {
          iVar6 = gm_GetPlayerSpouse(local_40c);
          *(undefined4 *)(puVar3 + 5) = *(undefined4 *)(iVar6 + 4);
        }
      }
      else {
        *(undefined4 *)(puVar3 + 5) =
             (&DAT_100358a4)[(uint)*(ushort *)((int)local_410 + 0x27) * 0x87];
      }
      iVar6 = gm_LoadGameData(&local_410,&local_40c,&local_408,parent_id);
      while ((iVar6 != 0 && (local_410 == (void *)0x0))) {
        if (local_40c == (void *)0x0) {
          if (local_408 != (void *)0x0) {
            logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xd3d,
                       s_gm_AllocObjekt____Karren_in_Spie_1003127c,1);
          }
        }
        else {
          parent_id = *(uint32_t *)((int)local_40c + 6);
        }
        iVar6 = gm_LoadGameData(&local_410,&local_40c,&local_408,parent_id);
      }
      *(char *)(puVar3 + 0x14) = '\0';
      *(char *)((int)puVar3 + 0x31) = '\x02';
      if (local_410 == (void *)0x0) {
        puVar2[0] = 0xffff;
        puVar2[1] = 0xffff;
      }
      else {
        *(undefined4 *)puVar2 = *(undefined4 *)((int)local_410 + 1);
      }
      iVar6 = gm_AllocObject(*(undefined4 *)(puVar3 + 1),0x1dd,1);
      *(uint *)(iVar6 + 0xe) = *puVar3 - 0x133;
      *(char *)(iVar6 + 0x1c) = (char)*puVar3 + -0x33;
      break;
    case 0x15e:
      goto switchD_1001695f_caseD_15e;
    }
  }
switchD_1001695f_caseD_b9:
  cVar1 = *local_404;
  if (((cVar1 == '\x17') || (cVar1 == ' ')) || (cVar1 == '%')) {
    puVar2[0] = 0;
    puVar2[1] = 0;
  }
  return puVar3;
}



// Setting prototype: void *add_object_to_list(uint32_t parent_id, uint32_t object_id, int count)

int gm_AddObject(uint32_t parent_id,int object_id,int count)

{
  int iVar1;
  undefined4 *puVar2;
  void *local_20c;
  void *local_208;
  void *local_204;
  CHAR local_200 [512];
  
                    // 
                    // Adds an object to a list, or updates its count if it already exists.
                    // 
                    // Parameters:
                    //   parent_id: The ID of the parent object or list.
                    //   object_id: The ID of the object to add.
                    //   count: The count of the object to add.
                    // 
                    // Return values:
                    //   A pointer to the object's data, or NULL on failure.
                    // 
  if (object_id == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xdf4,
               s_gm_AddObjekt____obj____ob_NULL_10031390,1);
    return 0;
  }
  iVar1 = gm_LoadGameData(&local_208,&local_20c,&local_204,parent_id);
  if (iVar1 == 0) {
    printf_wrapper(local_200,s_gm_AddObjekt____Parent_not_found_10031358,object_id,count);
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xdfd,local_200,8);
    return 0;
  }
  if (local_208 == (void *)0x0) {
    if (local_20c == (void *)0x0) {
      if (local_204 == (void *)0x0) {
        return 0;
      }
      puVar2 = (undefined4 *)((int)local_204 + 0x178);
    }
    else {
      puVar2 = (undefined4 *)((int)local_20c + 0x14);
    }
  }
  else {
    puVar2 = (undefined4 *)((int)local_208 + 0x5d);
  }
  local_20c = (void *)handleFindObjectInList(*puVar2,1,0,object_id);
  if (local_20c != (void *)0x0) {
    *(int *)((int)local_20c + 0xe) = *(int *)((int)local_20c + 0xe) + count;
    return (int)local_20c;
  }
  iVar1 = gm_AllocObject(parent_id,object_id,count);
  return iVar1;
}



// Setting prototype: int remove_object_from_list_3(uint32_t parent_id, uint32_t object_id, int
// count)

int gm_RemoveObject(uint32_t parent_id,uint32_t object_id,int count)

{
  uint32_t object_id_00;
  int iVar1;
  undefined4 *list_ptr;
  void *local_8;
  void *local_4;
  
                    // 
                    // Removes a specified count of an object from a list.
                    // If the count becomes zero or less, the object is fully removed from the list.
                    // 
                    // Parameters:
                    //   parent_id: The ID of the parent object or list.
                    //   object_id: The ID of the object to remove.
                    //   count: The number of objects to remove.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  iVar1 = gm_LoadGameData(&local_8,(void **)&parent_id,&local_4,parent_id);
  object_id_00 = object_id;
  if (iVar1 == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xe2d,
               s_gm_SubObjekt____Parent_not_found_100313b0,1);
  }
  else {
    if (local_8 == (void *)0x0) {
      if (parent_id == 0) {
        if (local_4 == (void *)0x0) {
          return 0;
        }
        list_ptr = (undefined4 *)((int)local_4 + 0x178);
      }
      else {
        list_ptr = (undefined4 *)(parent_id + 0x14);
      }
    }
    else {
      list_ptr = (undefined4 *)((int)local_8 + 0x5d);
    }
    parent_id = handleFindObjectInList(*list_ptr,1,0,object_id);
    if ((parent_id != 0) && (count <= *(int *)(parent_id + 0xe))) {
      *(int *)(parent_id + 0xe) = *(int *)(parent_id + 0xe) - count;
      if (*(int *)(parent_id + 0xe) < 1) {
        handleRemoveObjectFromList(list_ptr,object_id_00);
      }
      return 1;
    }
  }
  return 0;
}



// Setting prototype: int remove_object_from_list_no_kill(uint32_t parent_id, uint32_t object_id,
// int count)

int gm_RemoveObjectNoKill(uint32_t parent_id,uint32_t object_id,int count)

{
  uint32_t uVar1;
  uint32_t object_id_00;
  int iVar2;
  undefined4 *list_ptr;
  void *local_8;
  void *local_4;
  
  uVar1 = parent_id;
                    // 
                    // Removes a specified count of an object from a list without fully deallocating
                    // it.
                    // If the count becomes zero, the object is removed from the list.
                    // 
                    // Parameters:
                    //   parent_id: The ID of the parent object or list.
                    //   object_id: The ID of the object to remove.
                    //   count: The number of objects to remove.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  iVar2 = gm_LoadGameData(&local_8,(void **)&parent_id,&local_4,parent_id);
  object_id_00 = object_id;
  if (iVar2 == 0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0xe5c,
               s_gm_SubObjectNoKill____Parent_not_100313d4,1);
    return 0;
  }
  if (local_8 == (void *)0x0) {
    if (parent_id == 0) {
      if (local_4 == (void *)0x0) {
        return 0;
      }
      list_ptr = (undefined4 *)((int)local_4 + 0x178);
    }
    else {
      list_ptr = (undefined4 *)(parent_id + 0x14);
    }
  }
  else {
    list_ptr = (undefined4 *)((int)local_8 + 0x5d);
  }
  parent_id = handleFindObjectInList(*list_ptr,1,0,object_id);
  if (parent_id == 0) {
    parent_id = gm_AllocObject(uVar1,object_id_00,1);
    *(undefined4 *)(parent_id + 0xe) = 0;
  }
  *(int *)(parent_id + 0xe) = *(int *)(parent_id + 0xe) - count;
  if (*(int *)(parent_id + 0xe) == 0) {
    handleRemoveObjectFromList(list_ptr,object_id_00);
  }
  return 1;
}



// Setting prototype: void *get_next_building(void)

byte * handleGetNextBuilding(void)

{
  byte *pbVar1;
  byte *pbVar2;
  bool bVar3;
  
                    // 
                    // Retrieves the next building from the current iteration.
                    // 
                    // Return values:
                    //   A pointer to the next building's data, or NULL if no more buildings.
                    // 
  bVar3 = false;
  pbVar1 = (byte *)(DAT_1014d8c0 + 0xa900);
  if (DAT_100a8c30 == 0) {
    return (byte *)0x0;
  }
  if (0x100 < DAT_1003544c) {
    return (byte *)0x0;
  }
  if (DAT_10035449 == '\0') {
    do {
      DAT_10035464 = DAT_10035464 + 0xa9;
      if (pbVar1 <= DAT_10035464) {
        return (byte *)0x0;
      }
    } while (*DAT_10035464 == 0);
  }
  else {
    DAT_10035449 = '\0';
    if (pbVar1 <= DAT_10035464) {
      DAT_10035449 = 0;
      return (byte *)0x0;
    }
    do {
      if (*DAT_10035464 != 0) break;
      DAT_10035464 = DAT_10035464 + 0xa9;
    } while (DAT_10035464 < pbVar1);
  }
  pbVar2 = DAT_10035464;
  if (pbVar1 <= DAT_10035464) {
    return (byte *)0x0;
  }
  do {
    if (DAT_10035448 != '\0') {
      bVar3 = true;
    }
    if (DAT_10030b84 == 0xff) {
LAB_10017030:
      if (DAT_10030b88 != -1) {
        if (*(int *)(pbVar2 + 1) != DAT_10030b88) goto LAB_100170c6;
        bVar3 = true;
      }
      if (DAT_10030b8c != 0x7fff) {
        if (*(short *)(pbVar2 + 0x25) != DAT_10030b8c) goto LAB_100170c6;
        bVar3 = true;
      }
      if (DAT_10030b8e != 0x7fff) {
        if (*(short *)(pbVar2 + 0x27) != DAT_10030b8e) goto LAB_100170c6;
        bVar3 = true;
      }
      if (DAT_10030b90 != -1) {
        bVar3 = *(char *)(DAT_100a8c30 + (uint)*pbVar2 * 0x24d) == DAT_10030b90;
      }
    }
    else {
      if (*pbVar2 == DAT_10030b84) {
        bVar3 = true;
        goto LAB_10017030;
      }
LAB_100170c6:
      bVar3 = false;
    }
    DAT_1003544c = DAT_1003544c + 1;
    if (!bVar3) {
      do {
        pbVar2 = pbVar2 + 0xa9;
        if (pbVar1 <= pbVar2) goto LAB_100170ce;
        DAT_10035464 = pbVar2;
      } while (*pbVar2 == 0);
    }
    if (pbVar1 <= pbVar2) {
      if (!bVar3) {
LAB_100170ce:
        pbVar2 = (byte *)0x0;
        DAT_10035464 = (byte *)0x0;
      }
      return pbVar2;
    }
    if (bVar3) {
      return pbVar2;
    }
  } while( true );
}



// Setting prototype: void *find_object(uint32_t filter_flags)

undefined4 gm_FindObject(int filter_flags)

{
  char cVar1;
  undefined4 uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  int iVar7;
  char *pcVar8;
  char *pcVar9;
  
                    // 
                    // Finds an object based on various filter flags.
                    // 
                    // Parameters:
                    //   filter_flags: Flags to filter the search (e.g., object type, ID, etc.).
                    // 
                    // Return values:
                    //   A pointer to the found object's data, or NULL if not found.
                    // 
  if (DAT_100a8c30 == 0) {
    return 0;
  }
  DAT_10030b8c = 0x7fff;
  DAT_10030b8e = 0x7fff;
  DAT_10030b84 = 0xff;
  DAT_10030b88 = 0xffffffff;
  DAT_10035444 = (char *)0x0;
  DAT_10030b90 = 0xff;
  DAT_10035449 = 1;
  DAT_1003544c = 0;
  DAT_10035448 = 0;
  if (0 < filter_flags) {
    puVar5 = &filter_flags;
    iVar7 = filter_flags;
    do {
      puVar6 = puVar5 + 1;
      switch(*(undefined1 *)puVar6) {
      case 0:
        DAT_10030b84 = *(undefined1 *)(puVar5 + 2);
        puVar6 = puVar5 + 2;
        break;
      case 1:
        DAT_10030b88 = puVar5[2];
        puVar6 = puVar5 + 2;
        break;
      case 2:
        puVar6 = puVar5 + 2;
        uVar3 = 0xffffffff;
        pcVar8 = (char *)puVar5[2];
        do {
          pcVar9 = pcVar8;
          if (uVar3 == 0) break;
          uVar3 = uVar3 - 1;
          pcVar9 = pcVar8 + 1;
          cVar1 = *pcVar8;
          pcVar8 = pcVar9;
        } while (cVar1 != '\0');
        uVar3 = ~uVar3;
        pcVar8 = pcVar9 + -uVar3;
        pcVar9 = DAT_10035444;
        for (uVar4 = uVar3 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
          *(undefined4 *)pcVar9 = *(undefined4 *)pcVar8;
          pcVar8 = pcVar8 + 4;
          pcVar9 = pcVar9 + 4;
        }
        for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
          *pcVar9 = *pcVar8;
          pcVar8 = pcVar8 + 1;
          pcVar9 = pcVar9 + 1;
        }
        break;
      case 3:
        DAT_10030b8c = *(undefined2 *)(puVar5 + 2);
        puVar6 = puVar5 + 2;
        break;
      case 4:
        DAT_10030b8e = *(undefined2 *)(puVar5 + 2);
        puVar6 = puVar5 + 2;
        break;
      case 5:
        DAT_10030b90 = *(undefined1 *)(puVar5 + 2);
        puVar6 = puVar5 + 2;
        break;
      case 6:
        DAT_10035448 = 1;
      }
      iVar7 = iVar7 + -1;
      puVar5 = puVar6;
    } while (iVar7 != 0);
  }
  DAT_10035464 = DAT_1014d8c0;
  uVar2 = handleGetNextBuilding();
  return uVar2;
}



// Setting prototype: void *get_free_building_slot(void)

char * gm_GetFreeBuildingSlot(void)

{
  char *pcVar1;
  char *pcVar2;
  
                    // 
                    // Retrieves a free building slot.
                    // 
                    // Return values:
                    //   A pointer to the free building slot, or NULL if no free slot is found.
                    // 
  pcVar1 = DAT_1014d8c0 + 0xa900;
  pcVar2 = DAT_1014d8c0;
  if (DAT_1014d8c0 < pcVar1) {
    while (*pcVar2 != '\0') {
      pcVar2 = pcVar2 + 0xa9;
      if (pcVar1 <= pcVar2) {
        return (char *)0x0;
      }
    }
    if (pcVar2 < pcVar1) {
      return pcVar2;
    }
  }
  return (char *)0x0;
}



// Setting prototype: int free_building_slot(void *building_data)

int gm_FreeBuilding(void *building_data)

{
  int *piVar1;
  
                    // 
                    // Frees a building slot and its associated data.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  if (building_data == (void *)0x0) {
    return -1;
  }
                    // WARNING: Load size is inaccurate
  if (*building_data == '\0') {
    return -2;
  }
  switch(*building_data) {
  case '\x1e':
    if (*(void **)((int)building_data + 0x71) != (void *)0x0) {
      m_free(*(void **)((int)building_data + 0x71));
      *(undefined4 *)((int)building_data + 0x71) = 0;
    }
    *(undefined4 *)((int)building_data + 0x71) = 0;
  default:
    goto switchD_10017275_caseD_1f;
  case 'H':
  case 'I':
  case 'J':
    cm_ExFreeGraveyard(*(void **)((int)building_data + 0x65));
    break;
  case 'K':
  case 'L':
  case 'M':
    m_free(*(void **)((int)building_data + 0x65));
  }
  *(undefined4 *)((int)building_data + 0x65) = 0;
switchD_10017275_caseD_1f:
  piVar1 = &DAT_10035a0c;
  do {
    if ((void *)piVar1[1] == building_data) {
      piVar1[1] = 0;
    }
    if ((void *)*piVar1 == building_data) {
      *piVar1 = 0;
    }
    piVar1 = piVar1 + 0x87;
  } while ((int)piVar1 < 0x1009ae0c);
  if (*(int *)((int)building_data + 0x5d) != 0) {
    handleFreeObjectList((void *)((int)building_data + 0x5d));
  }
  *(undefined1 *)building_data = 0;
  return 0;
}



// Setting prototype: void building_management(void *building_data)

void handleBuildingManagement(void *building_data)

{
  int iVar1;
  int iVar2;
  int iVar3;
  short *psVar4;
  short *local_4;
  
                    // 
                    // Manages buildings, including allocating new objects within them based on
                    // predefined types.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
  local_4 = &DAT_10030861;
  do {
                    // WARNING: Load size is inaccurate
    if (*building_data == *(char *)((int)local_4 + -1)) {
      iVar1 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),2,6,0,0xff);
      if ((iVar1 == 0) &&
         (iVar1 = gm_AllocObject(*(undefined4 *)((int)building_data + 1),0xff,1), iVar1 == 0)) {
        logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x107f,
                   s_gm_AllocGebaeude____Missing_pote_100313fc,1);
      }
      else {
        iVar3 = 10;
        psVar4 = local_4;
        do {
          if ((*psVar4 != 0) &&
             (iVar2 = handleFindObjectInList(*(undefined4 *)(iVar1 + 0x14),1,0,*psVar4), iVar2 == 0)
             ) {
            gm_AllocObject(*(undefined4 *)(iVar1 + 2),*psVar4,2);
          }
          psVar4 = psVar4 + 1;
          iVar3 = iVar3 + -1;
        } while (iVar3 != 0);
      }
    }
    local_4 = (short *)((int)local_4 + 0x15);
  } while ((int)local_4 < 0x10030b6a);
  return;
}



// Setting prototype: void building_management_2(void *building_data)

void handleBuildingManagement2(void *building_data)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  
                    // 
                    // Manages buildings, specifically updating properties of objects within them
                    // based on building type data.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // WARNING: Load size is inaccurate
  iVar3 = DAT_100a8c30 + (uint)*building_data * 0x24d;
  iVar1 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),2,0,0x2a,6);
  if (iVar1 != 0) {
    bVar2 = *(byte *)(iVar3 + 0x23d);
    if (((bVar2 == 0) && (*(char *)(iVar3 + 0x23e) == '\0')) && (*(char *)(iVar3 + 0x23f) != '\0'))
    {
      *(char *)(iVar1 + 0x1c) = *(char *)(iVar3 + 0x23f);
    }
    else {
      if (bVar2 < 2) {
        bVar2 = 2;
      }
      *(byte *)(iVar1 + 0x1c) = bVar2;
      bVar2 = *(byte *)(iVar3 + 0x23e);
      if (bVar2 < 2) {
        bVar2 = 2;
      }
      *(byte *)(iVar1 + 0x1d) = bVar2;
    }
  }
  iVar1 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),2,0,0x116,6);
  if (((iVar1 != 0) && (*(char *)(iVar3 + 0x23d) == '\0')) &&
     ((*(char *)(iVar3 + 0x23e) == '\0' && (*(char *)(iVar3 + 0x23f) != '\0')))) {
    *(char *)(iVar1 + 0x1c) = *(char *)(iVar3 + 0x23f);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: void *alloc_building(uint8_t building_type, uint16_t owner_id)

byte * gm_AllocBuilding(byte building_type,ushort owner_id)

{
  uint *puVar1;
  char cVar2;
  ushort uVar3;
  byte *building_data;
  short *psVar4;
  int iVar5;
  undefined4 uVar6;
  undefined4 *puVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  ushort *puVar13;
  CHAR local_414 [1024];
  byte *local_14;
  uint local_10;
  int local_c;
  int local_8;
  
                    // 
                    // Allocates and initializes a new building.
                    // 
                    // Parameters:
                    //   building_type: The type of building to allocate.
                    //   owner_id: The ID of the building's owner.
                    // 
                    // Return values:
                    //   A pointer to the allocated building data, or NULL on failure.
                    // 
  if (DAT_100a8c30 == 0) {
    return (byte *)0x0;
  }
  local_8 = 0;
  building_data = (byte *)gm_GetFreeBuildingSlot();
  local_c = DAT_100a8c30;
  if (building_data == (byte *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x10cb,
               s_gm_AllocGebaeude____geb_overflow_10031454,1);
    return (byte *)0x0;
  }
  local_10 = (uint)building_type;
  *building_data = building_type;
  local_c = local_c + local_10 * 0x24d;
  printf_wrapper(local_414,s______>GebID___i_GebProt___i_10031438,DAT_10030b6c,local_10);
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x10d8,local_414,8);
  *(int *)(building_data + 1) = DAT_10030b6c;
  DAT_10030b6c = DAT_10030b6c + 1;
  *(ushort *)(building_data + 0x25) = owner_id;
  *(ushort *)(building_data + 0x27) = owner_id;
  building_data[0x3d] = 100;
  building_data[0x3e] = 0;
  building_data[0x3f] = 0;
  building_data[0x40] = 0;
  building_data[0x45] = 100;
  building_data[0x46] = 0;
  building_data[0x47] = 0;
  building_data[0x48] = 0;
  building_data[0x5c] = 100;
  puVar1 = (uint *)(building_data + 0x99);
  building_data[0x29] = 0;
  building_data[0x2a] = 0;
  building_data[0x2b] = 0;
  building_data[0x2c] = 0;
  building_data[0x2d] = 0;
  building_data[0x2e] = 0;
  building_data[0x2f] = 0;
  building_data[0x5d] = 0;
  building_data[0x5e] = 0;
  building_data[0x5f] = 0;
  building_data[0x60] = 0;
  building_data[0x61] = 0;
  building_data[0x62] = 0;
  building_data[99] = 0;
  building_data[100] = 0;
  building_data[0x30] = 0;
  building_data[0x31] = 0;
  building_data[0x32] = 0;
  building_data[0x33] = 0;
  building_data[0x39] = 0;
  building_data[0x3a] = 0x7d;
  building_data[0x3b] = 0;
  building_data[0x3c] = 0;
  building_data[0x41] = 2;
  building_data[0x42] = 0;
  building_data[0x43] = 0;
  building_data[0x44] = 0;
  building_data[0x49] = 0;
  building_data[0x4a] = 0;
  building_data[0x4b] = 0x80;
  building_data[0x4c] = 0x3f;
  building_data[0x95] = 0xff;
  building_data[0x96] = 0xff;
  building_data[0x97] = 0xff;
  building_data[0x98] = 0xff;
  *puVar1 = 0;
  building_data[0x9d] = 0;
  building_data[0x9e] = 0;
  building_data[0x9f] = 0;
  building_data[0xa0] = 0;
  building_data[0xa1] = 0;
  building_data[0xa2] = 0;
  building_data[0xa3] = 0;
  building_data[0xa4] = 0;
  building_data[0xa5] = 0;
  building_data[0xa6] = 0;
  building_data[0xa7] = 0;
  building_data[0xa8] = 0;
  building_data[0xa5] = 0xff;
  building_data[0xa6] = 0xff;
  building_data[0xa7] = 0xff;
  building_data[0xa8] = 0xff;
  *puVar1 = *puVar1 | 1;
  local_14 = building_data + 0x65;
  uVar8 = (int)local_14 * 3 & 3;
  uVar10 = 0x30 - uVar8;
  uVar11 = uVar10;
  pbVar12 = local_14;
  if (uVar10 != 0 && uVar8 < 0x31) {
    for (; uVar8 != 0; uVar8 = uVar8 - 1) {
      *pbVar12 = 0;
      pbVar12 = pbVar12 + 1;
    }
    uVar11 = uVar10 & 3;
    for (uVar8 = uVar10 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
      pbVar12[0] = 0;
      pbVar12[1] = 0;
      pbVar12[2] = 0;
      pbVar12[3] = 0;
      pbVar12 = pbVar12 + 4;
    }
  }
  for (iVar9 = uVar8 + uVar11; iVar9 != 0; iVar9 = iVar9 + -1) {
    *pbVar12 = 0;
    pbVar12 = pbVar12 + 1;
  }
  _building_type = 0;
  puVar13 = (ushort *)(local_c + 0x23);
  do {
    uVar3 = *puVar13;
    if (uVar3 == 0) break;
    if (uVar3 != 0xffff) {
      uVar11 = uVar3 & 0x7fff;
      cVar2 = *(char *)(DAT_101de450 + uVar11 * 0x41);
      if ((cVar2 == '\x02') || (cVar2 == '\x06')) {
        local_8 = 1;
      }
      if ((uVar3 & 0x8000) != 0) {
        if ((cVar2 == '\x02') || (cVar2 == '\x06')) {
          local_8 = 1;
          gm_AllocRoom(building_data,uVar11);
        }
        else if (local_8 == 0) {
          gm_AllocObject(*(undefined4 *)(building_data + 1),uVar11,1);
        }
      }
    }
    puVar13 = puVar13 + 1;
    _building_type = _building_type + 1;
  } while (_building_type < 0x40);
  psVar4 = (short *)handleFindObjectInList(*(undefined4 *)(building_data + 0x5d),1,4,2);
  while (psVar4 != (short *)0x0) {
    if (*psVar4 != 0xfd) {
      *(short *)(building_data + 0x29) = *psVar4;
      break;
    }
    psVar4 = (short *)handleGetNextObjectFromList();
  }
  handleBuildingManagement3(building_data);
  if (psVar4 != (short *)0x0) {
    *(short *)(building_data + 0x29) = *psVar4;
  }
  iVar9 = handleIsResidence(building_data);
  if (iVar9 != 0) {
    building_data[0x30] = 0x88;
    building_data[0x31] = 0x13;
    building_data[0x32] = 0;
    building_data[0x33] = 0;
  }
  switch(local_10) {
  case 4:
  case 5:
  case 6:
  case 7:
    *(undefined4 *)(building_data + 0x69) = DAT_10035880;
    *(undefined4 *)(building_data + 0x6d) = _DAT_10035884;
    *(undefined4 *)(building_data + 0x71) = DAT_10035888;
    *(undefined2 *)(building_data + 0x75) = DAT_1003588c;
    if (owner_id != 0xffff) {
      *(undefined4 *)(building_data + 0x65) = (&DAT_100358a4)[(uint)owner_id * 0x87];
      break;
    }
  case 0xb:
  case 0xc:
  case 0xd:
    building_data[0x65] = 0xff;
    building_data[0x66] = 0xff;
    building_data[0x67] = 0xff;
    building_data[0x68] = 0xff;
    break;
  case 0xe:
  case 0xf:
  case 0x10:
    building_data[0x65] = 10;
    building_data[0x66] = 0;
    building_data[0x67] = 0;
    building_data[0x68] = 0;
    building_data[0x69] = 3;
    building_data[0x6a] = 0;
    building_data[0x6b] = 0;
    building_data[0x6c] = 0;
    building_data[0x6d] = 5;
    building_data[0x6e] = 0;
    building_data[0x6f] = 0;
    building_data[0x70] = 0;
    break;
  case 0x14:
  case 0x15:
  case 0x16:
    iVar9 = gm_AllocObject(*(undefined4 *)(building_data + 1),0x1b5,1);
    if (iVar9 != 0) {
      *(undefined1 *)(iVar9 + 0x22) = 0;
      *(undefined1 *)(iVar9 + 0x1c) = 0xff;
      *(undefined1 *)(iVar9 + 0x1d) = 0xff;
      *(undefined4 *)(iVar9 + 0x1e) = 0xffffffff;
    }
    break;
  case 0x1e:
    uVar6 = mAlloc(0x600,s_f3_gm_PlantMap_10031428);
    *(undefined4 *)(building_data + 0x71) = uVar6;
    iVar9 = 0;
    do {
      iVar5 = iVar9 + 0x18;
      *(undefined1 *)(iVar9 + 0xd + *(int *)(building_data + 0x71)) = 0xff;
      *(undefined4 *)(iVar9 + 0x14 + *(int *)(building_data + 0x71)) = 0;
      iVar9 = iVar5;
    } while (iVar5 < 0x600);
  case 0x1f:
  case 0x20:
    building_data[0x30] = 100;
    building_data[0x31] = 0;
    building_data[0x32] = 0;
    building_data[0x33] = 0;
    building_data[0x49] = 0xcd;
    building_data[0x4a] = 0xcc;
    building_data[0x4b] = 0x4c;
    building_data[0x4c] = 0x3f;
    break;
  case 0x35:
  case 0x36:
  case 0x37:
    building_data[0x65] = 0;
    building_data[0x66] = 0;
    building_data[0x67] = 0;
    building_data[0x68] = 0;
    building_data[0x69] = 0;
    building_data[0x6a] = 0;
    building_data[0x6b] = 0;
    building_data[0x6c] = 0;
    building_data[0x6d] = 0;
    building_data[0x6e] = 0;
    building_data[0x6f] = 0;
    building_data[0x70] = 0;
    break;
  case 0x47:
    building_data[0x30] = 0x80;
    building_data[0x31] = 0x38;
    building_data[0x32] = 1;
    building_data[0x33] = 0;
    break;
  case 0x48:
  case 0x49:
  case 0x4a:
    uVar6 = cm_ExAllocGraveyardField(building_data);
    *(undefined4 *)(building_data + 0x65) = uVar6;
    cm_ExAllocGraveyard(building_data,3);
    break;
  case 0x4b:
  case 0x4c:
  case 0x4d:
    puVar7 = (undefined4 *)mAlloc(0x3c,s_AHM_INFO_1002d504);
    *(undefined4 **)(building_data + 0x65) = puVar7;
    *puVar7 = 0xffffffff;
  }
  if (*building_data == 0x26) {
    building_data[0x29] = 0xe;
    building_data[0x2a] = 1;
  }
  handleBuildingManagement2(building_data);
  handleGetBuildingType((uint)*building_data);
  handleBuildingManagement(building_data);
  return building_data;
}



// Setting prototype: void building_management_3(void *building_data)

void handleBuildingManagement3(void *building_data)

{
  char *pcVar1;
  int iVar2;
  short *psVar3;
  
                    // 
                    // Manages buildings, specifically handling residence logic and object searching
                    // within the building.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // WARNING: Load size is inaccurate
  handleGetBuildingType((uint)*building_data);
                    // WARNING: Load size is inaccurate
  pcVar1 = (char *)(DAT_100a8c30 + (uint)*building_data * 0x24d);
  iVar2 = handleIsResidence(building_data);
  if (iVar2 != 0) {
    handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),1,0,0xfd);
    return;
  }
  if (*pcVar1 != '\x04') {
    psVar3 = (short *)handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),1,4,2);
    while ((psVar3 != (short *)0x0 && (*psVar3 == 0xfd))) {
      psVar3 = (short *)handleGetNextObjectFromList();
    }
    return;
  }
  handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),1,0,0x54);
  return;
}



// Setting prototype: uint32_t get_building_type(uint32_t building_id)

uint32_t handleGetBuildingType(uint32_t building_id)

{
                    // 
                    // Retrieves the type of a building based on its ID.
                    // 
                    // Parameters:
                    //   building_id: The ID of the building.
                    // 
                    // Return values:
                    //   The type of the building.
                    // 
  switch(*(undefined1 *)(DAT_100a8c30 + building_id * 0x24d)) {
  case 1:
  case 3:
  case 6:
  case 0xf:
    return 3;
  case 2:
  case 0x1e:
    return 6;
  case 4:
  case 5:
  case 9:
    return 8;
  case 7:
    return 4;
  case 8:
  case 0xe:
  case 0x12:
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x1d:
  case 0x1f:
  case 0x20:
    return 1;
  default:
    return 0;
  case 0xb:
  case 0xc:
  case 0xd:
    return 2;
  case 0x13:
    return 7;
  case 0x17:
  case 0x18:
  case 0x19:
  case 0x1a:
    return 5;
  case 0x21:
    return 9;
  }
}



// Setting prototype: void *get_player_building(uint32_t player_id)

char * handleGetPlayerBuilding(int player_id)

{
  int iVar1;
  char *pcVar2;
  
                    // 
                    // Retrieves a player's building data by player ID.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player.
                    // 
                    // Return values:
                    //   A pointer to the building data, or NULL if not found.
                    // 
  iVar1 = 0;
  pcVar2 = DAT_1014d8c0;
  while ((*pcVar2 == '\0' || (*(int *)(pcVar2 + 1) != player_id))) {
    iVar1 = iVar1 + 1;
    pcVar2 = pcVar2 + 0xa9;
    if (0xff < iVar1) {
      return (char *)0x0;
    }
  }
  return DAT_1014d8c0 + iVar1 * 0xa9;
}



// Setting prototype: void *is_residence(void *building_data)

byte * handleIsResidence(byte *building_data)

{
  char cVar1;
  
                    // 
                    // Checks if a given building is a residence type.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   A non-NULL pointer if it is a residence, NULL otherwise.
                    // 
  if (building_data == (byte *)0x0) {
    return building_data;
  }
  cVar1 = *(char *)(DAT_100a8c30 + (uint)*building_data * 0x24d);
  if ((((cVar1 != '\v') && (cVar1 != '\r')) && (cVar1 != '\f')) &&
     (((cVar1 != '\x10' && (cVar1 != '\x1c')) && ((cVar1 != '\x1d' && (cVar1 != '\x1f')))))) {
    return (byte *)0x0;
  }
  return (byte *)0x1;
}



// Setting prototype: void set_building_owner(void *building_data, uint16_t owner_id, uint32_t
// new_owner_id)

void handleSetBuildingOwner(void *building_data,uint16_t owner_id,uint32_t new_owner_id)

{
  char cVar1;
  ushort uVar2;
  int iVar3;
  ushort *puVar4;
  char *pcVar5;
  
                    // 
                    // Sets the owner of a building and updates related player and object data.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   owner_id: The current owner's ID.
                    //   new_owner_id: The ID of the new owner.
                    // 
                    // WARNING: Load size is inaccurate
  pcVar5 = (char *)(DAT_100a8c30 + (uint)*building_data * 0x24d);
  *(uint16_t *)((int)building_data + 0x25) = owner_id;
  if (new_owner_id != 0xffff) {
    uVar2 = *(ushort *)((int)building_data + 0x27);
    if ((uVar2 != 0xffff) && ((void *)(&DAT_10035a10)[(uint)uVar2 * 0x87] == building_data)) {
      (&DAT_10035a10)[(uint)uVar2 * 0x87] = 0;
    }
    *(short *)((int)building_data + 0x27) = (short)new_owner_id;
    if (*pcVar5 == '\x02') {
                    // WARNING: Load size is inaccurate
      if (((byte *)(&DAT_10035a10)[(new_owner_id & 0xffff) * 0x87] == (byte *)0x0) ||
         (*(byte *)(&DAT_10035a10)[(new_owner_id & 0xffff) * 0x87] <= *building_data)) {
        (&DAT_10035a10)[(new_owner_id & 0xffff) * 0x87] = building_data;
      }
    }
    if ((((&DAT_100358a2)[new_owner_id * 0x21c] == '\x06') ||
        ((&DAT_100358a2)[new_owner_id * 0x21c] == '\a')) &&
       (iVar3 = get_player_residence_2(building_data), iVar3 != 0)) {
      *(undefined1 *)(iVar3 + 0x165) = 0;
      *(uint *)(iVar3 + 0x1b4) = *(uint *)(iVar3 + 0x1b4) & 0xfffffffe;
      cVar1 = *pcVar5;
      if ((cVar1 == '\x05') || (cVar1 == '\t')) {
        *(undefined4 *)(iVar3 + 0x16c) = 0;
      }
    }
    iVar3 = 0x5008;
    puVar4 = DAT_100a8c34;
    do {
      if (((*puVar4 != 0) && (*(char *)(DAT_101de450 + (uint)*puVar4 * 0x41) == '\x1d')) &&
         (*(int *)(puVar4 + 0xe) == *(int *)((int)building_data + 1))) {
        *(undefined4 *)(puVar4 + 5) = (&DAT_100358a4)[new_owner_id * 0x87];
        if (*(int *)(puVar4 + 10) != 0) {
          *(undefined4 *)(*(int *)(puVar4 + 10) + 10) = (&DAT_100358a4)[new_owner_id * 0x87];
        }
      }
      puVar4 = (ushort *)((int)puVar4 + 0x43);
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
  }
  return;
}



// Setting prototype: void *alloc_room(void *building_data, uint32_t room_type)

ushort * gm_AllocRoom(byte *building_data,uint room_type)

{
  ushort *puVar1;
  char cVar2;
  byte bVar3;
  ushort uVar4;
  undefined4 uVar5;
  ushort *puVar6;
  int iVar7;
  int iVar8;
  byte bVar9;
  uint uVar10;
  int *piVar11;
  int iVar12;
  undefined4 *puVar13;
  
                    // 
                    // Allocates a new room within a building and initializes its properties.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   room_type: The type of room to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated room data, or NULL on failure.
                    // 
  if (((DAT_101de450 == 0) || (DAT_100a8c30 == 0)) || (0x5007 < DAT_10035450 + 0x40)) {
    return (ushort *)0x0;
  }
  puVar6 = (ushort *)gm_AllocObject(*(undefined4 *)(building_data + 1),room_type,1);
  iVar12 = 0;
  iVar7 = DAT_100a8c30 + (uint)*building_data * 0x24d;
  iVar8 = iVar7 + 0x23;
  uVar4 = *(ushort *)(iVar7 + 0x23);
  while ((uVar4 & 0x7fff) != room_type) {
    puVar1 = (ushort *)(iVar8 + 2);
    iVar8 = iVar8 + 2;
    iVar12 = iVar12 + 1;
    uVar4 = *puVar1;
  }
  while (iVar12 = iVar12 + 1, iVar12 < 0x40) {
    uVar4 = *(ushort *)(iVar7 + 0x23 + iVar12 * 2);
    if (uVar4 == 0) break;
    if (uVar4 != 0xffff) {
      cVar2 = *(char *)(DAT_101de450 + (uVar4 & 0x7fff) * 0x41);
      if ((cVar2 == '\x02') || (cVar2 == '\x06')) {
        iVar12 = 0x40;
      }
      else if ((uVar4 & 0x8000) != 0) {
        gm_AllocObject(*(undefined4 *)(puVar6 + 1),uVar4 & 0x7fff,1);
      }
    }
  }
  iVar8 = handleFindObjectInList(*(undefined4 *)(puVar6 + 10),1,0,0x2a);
  if (iVar8 != 0) {
    uVar5 = *(undefined4 *)(building_data + 1);
    *(undefined4 *)(iVar8 + 0xe) = 2;
    *(undefined4 *)(iVar8 + 6) = uVar5;
    bVar9 = *(byte *)(iVar7 + 0x23d);
    if (((bVar9 == 0) && (*(char *)(iVar7 + 0x23e) == '\0')) && (*(char *)(iVar7 + 0x23f) != '\0'))
    {
      *(char *)(iVar8 + 0x1c) = *(char *)(iVar7 + 0x23f);
    }
    else {
      if (bVar9 < 2) {
        bVar9 = 2;
      }
      *(byte *)(iVar8 + 0x1c) = bVar9;
      bVar9 = *(byte *)(iVar7 + 0x23e);
      if (bVar9 < 2) {
        bVar9 = 2;
      }
      *(byte *)(iVar8 + 0x1d) = bVar9;
    }
  }
  iVar8 = handleFindObjectInList(*(undefined4 *)(puVar6 + 10),2,0,0x116,6);
  if (iVar8 != 0) {
    uVar5 = *(undefined4 *)(puVar6 + 1);
    *(undefined4 *)(iVar8 + 0xe) = 2;
    *(undefined4 *)(iVar8 + 6) = uVar5;
    bVar9 = *(byte *)(iVar7 + 0x23d);
    if (((bVar9 == 0) && (*(char *)(iVar7 + 0x23e) == '\0')) &&
       (bVar3 = *(byte *)(iVar7 + 0x23f), bVar3 != 0)) {
      if (bVar3 < 6) {
        *(undefined1 *)(iVar8 + 0x1c) = 6;
      }
      else {
        *(byte *)(iVar8 + 0x1c) = bVar3;
      }
    }
    else {
      if (bVar9 < 6) {
        bVar9 = 6;
      }
      *(byte *)(iVar8 + 0x1c) = bVar9;
      bVar9 = *(byte *)(iVar7 + 0x23e);
      if (bVar9 < 6) {
        bVar9 = 6;
      }
      *(byte *)(iVar8 + 0x1d) = bVar9;
    }
  }
  uVar4 = *puVar6;
  if (((0x91 < uVar4) && (uVar4 < 0x98)) || (uVar4 == 0x2db)) {
    uVar10 = (uint)DAT_10035439;
    iVar8 = handleFindObjectInList(*(undefined4 *)(puVar6 + 10),1,0,0x116);
    if (iVar8 == 0) {
      showMessage(s_gm_AllocRaum____ob_LAGERFLAECHE__100314b8);
    }
    else {
      *(undefined1 *)(iVar8 + 0x1c) = 0xc;
      *(undefined1 *)(iVar8 + 0x1d) = 0;
      *(undefined4 *)(iVar8 + 0xe) = 3;
    }
    iVar8 = gm_AllocObject(*(undefined4 *)(puVar6 + 1),0xff,1);
    iVar12 = 0;
    puVar13 = &DAT_1002dde0;
    piVar11 = (int *)(&DAT_1009b774 + uVar10 * 0x2a90);
    do {
      if ((*(ushort *)(piVar11 + 0xe) == *puVar6) && (*piVar11 != 0)) {
        if (iVar12 < 0x10) {
          gm_AllocObject(*(undefined4 *)(iVar8 + 2),*(undefined2 *)puVar13);
          iVar12 = iVar12 + 1;
        }
        else {
          logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x16a6,
                     s_gm_AllocRaum____Too_many_objects_10031484,1);
        }
      }
      puVar13 = puVar13 + 0x20;
      piVar11 = piVar11 + 0x20;
    } while ((int)puVar13 < 0x10030860);
  }
  return puVar6;
}



// Setting prototype: int remove_object_from_list_4(void *building_data, uint32_t object_id)

int handleRemoveObjectFromList4(void *building_data,uint32_t object_id)

{
  int iVar1;
  
                    // 
                    // Removes an object from a building's object list.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   object_id: The ID of the object to remove.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  iVar1 = handleRemoveObjectFromList((void *)((int)building_data + 0x5d),object_id);
  return (-(uint)(iVar1 != -2) & 3) - 3;
}



// Setting prototype: void detach_object_from_parent(void *object_data)

void __cdecl handleDetachObjectFromParent(void *object_data)

{
  int parent_ptr;
  
                    // 
                    // Detaches an object from its parent object.
                    // 
                    // Parameters:
                    //   object_data: Pointer to the object's data structure.
                    // 
  parent_ptr = gm_GetPlayerParent(object_data);
  if (parent_ptr != 0) {
    handleRemoveObjectFromListById((void *)(parent_ptr + 0x5d),*(uint32_t *)((int)object_data + 2));
  }
  return;
}



// Setting prototype: void remove_player_from_amt_wrapper(void *player_data)

void __cdecl handleRemovePlayerFromAmtWrapper(void *player_data)

{
                    // 
                    // Wrapper function to remove a player from an Amt, with a null check.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // WARNING: Load size is inaccurate
  if ((player_data != (void *)0x0) && (*player_data != -1)) {
    handleRemovePlayerFromAmt(player_data);
  }
  return;
}



// Setting prototype: void kill_player_and_cleanup(uint32_t player_id, int cleanup_type)

void __cdecl gm_KillSpieler(uint32_t player_id,int cleanup_type)

{
  short *player_data;
  undefined4 uVar1;
  int *piVar2;
  int *spouse;
  int iVar3;
  short *psVar4;
  undefined4 *puVar5;
  undefined1 msg [512];
  
                    // 
                    // Kills a player and performs cleanup operations based on the cleanup type.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player to kill.
                    //   cleanup_type: The type of cleanup to perform (0 for simple kill, 1 for full
                    // cleanup).
                    // 
  iVar3 = player_id * 0x21c;
  uVar1 = (&DAT_100358a4)[player_id * 0x87];
  player_data = &DAT_100358a0 + player_id * 0x10e;
  if ((&DAT_100358a2)[iVar3] != '\x0f') {
    (&DAT_100358a8)[iVar3] = 0;
    *(undefined2 *)(&DAT_100358c8 + iVar3) = (undefined2)DAT_10035880;
    handleRemovePlayerFromAmtWrapper(player_data);
    (&DAT_100358a2)[iVar3] = 0xf;
  }
  handleFreeObjectList(&DAT_10035a18 + iVar3);
  if (cleanup_type == 0) {
    printf_wrapper(msg,s_gm_KillSpieler__Killing_Player_<_10031500,uVar1);
  }
  else {
    if (*player_data != -1) {
      DAT_10035434 = DAT_10035434 + -1;
    }
    spouse = &DAT_100358fc;
    do {
      iVar3 = 8;
      piVar2 = spouse;
      do {
        if (*piVar2 == (&DAT_100358a4)[player_id * 0x87]) {
          *piVar2 = -1;
        }
        piVar2 = piVar2 + 1;
        iVar3 = iVar3 + -1;
      } while (iVar3 != 0);
      spouse = spouse + 0x87;
    } while ((int)spouse < 0x1009acfc);
    psVar4 = player_data;
    for (iVar3 = 0x87; iVar3 != 0; iVar3 = iVar3 + -1) {
      psVar4[0] = 0;
      psVar4[1] = 0;
      psVar4 = psVar4 + 2;
    }
    *player_data = -1;
    (&DAT_100358a4)[player_id * 0x87] = 0xffffffff;
    puVar5 = &DAT_100358fc + player_id * 0x87;
    for (iVar3 = 8; iVar3 != 0; iVar3 = iVar3 + -1) {
      *puVar5 = 0xffffffff;
      puVar5 = puVar5 + 1;
    }
    if (cleanup_type == 1) {
      printf_wrapper(msg,s_gm_KillSpieler__Killing_Player_<_10031538,uVar1);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void kill_all_players(void)

void remove_all_players(void)

{
  int iVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  uint32_t player_id;
  undefined4 *puVar4;
  
                    // 
                    // Kills all players in the game and cleans up their data.
                    // 
  player_id = 0;
  do {
    gm_KillSpieler(player_id,2);
    player_id = player_id + 1;
  } while ((int)player_id < 0x300);
  puVar2 = (undefined4 *)&DAT_1009aca0;
  do {
    puVar3 = puVar2 + 0x2b;
    puVar4 = puVar2;
    for (iVar1 = 0x2b; iVar1 != 0; iVar1 = iVar1 + -1) {
      *puVar4 = 0;
      puVar4 = puVar4 + 1;
    }
    *(undefined2 *)puVar2 = 0xffff;
    puVar2 = puVar3;
  } while ((int)puVar3 < 0x1009b760);
  DAT_10035434 = 0;
  DAT_1003542c = 0;
  DAT_10035430 = 0;
  return;
}



// Setting prototype: int is_player_in_state(void *player_data)

int handleIsPlayerInState(void *player_data)

{
  uint32_t uVar1;
  
                    // 
                    // Checks if a player is in a specific state based on their class.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   0 if the player is in the state, 2 otherwise.
                    // 
  uVar1 = handleGetPlayerClass((uint32_t)player_data);
  if ((9 < (int)uVar1) && ((int)uVar1 < 0xf)) {
    return 0;
  }
  return 2;
}



// Setting prototype: int is_player_in_state_2(uint32_t state_id)

int handleIsPlayerInState2(uint32_t state_id)

{
                    // 
                    // Checks if a player is in a specific state based on the state ID.
                    // 
                    // Parameters:
                    //   state_id: The ID of the state to check.
                    // 
                    // Return values:
                    //   0 if the player is in the state, 2 otherwise.
                    // 
  switch(state_id) {
  case 1:
  case 2:
  case 3:
  case 4:
  case 7:
  case 8:
  case 9:
  case 10:
  case 0xb:
  case 0xc:
  case 0xf:
  case 0x10:
  case 0x11:
  case 0x12:
  case 0x13:
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x17:
  case 0x18:
    return 0;
  default:
    return 2;
  }
}



// Setting prototype: uint8_t get_player_attribute(uint32_t player_id, int attribute_type)

uint8_t handleGetPlayerAttribute(uint32_t player_id,int attribute_type)

{
  uint32_t uVar1;
  int iVar2;
  
                    // 
                    // Retrieves a specific attribute of a player.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player.
                    //   attribute_type: The type of attribute to retrieve.
                    // 
                    // Return values:
                    //   The value of the attribute.
                    // 
  uVar1 = handleGetPlayerClass((uint)(byte)(&DAT_10035a04)[player_id * 0x21c]);
  if (uVar1 == attribute_type) {
    return (&DAT_10035a04)[player_id * 0x21c];
  }
  iVar2 = gm_GetPlayerResidence(&DAT_100358a0 + player_id * 0x10e);
  if (iVar2 == 0) {
    return '\0';
  }
  return *(uint8_t *)(iVar2 + 0x74 + attribute_type);
}



// Setting prototype: uint32_t get_player_class(uint32_t player_type)

uint32_t handleGetPlayerClass(uint32_t player_type)

{
                    // 
                    // Retrieves the class of a player based on their type.
                    // 
                    // Parameters:
                    //   player_type: The type of the player.
                    // 
                    // Return values:
                    //   The class ID of the player.
                    // 
  switch(player_type) {
  default:
    return 0;
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    return 0xb;
  case 7:
  case 8:
  case 9:
  case 10:
  case 0xb:
  case 0xc:
    return 9;
  case 0xd:
  case 0xe:
  case 0xf:
  case 0x10:
  case 0x11:
  case 0x12:
    return 7;
  case 0x13:
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x17:
  case 0x18:
    return 6;
  case 0x19:
  case 0x1a:
  case 0x1b:
  case 0x1c:
  case 0x1d:
  case 0x1e:
    return 8;
  case 0x1f:
  case 0x20:
  case 0x21:
    return 0x10;
  case 0x22:
  case 0x23:
  case 0x24:
  case 0x25:
  case 0x26:
  case 0x27:
    return 5;
  case 0x28:
  case 0x29:
  case 0x2a:
  case 0x2b:
  case 0x2c:
  case 0x2d:
    return 0xc;
  case 0x2e:
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
    return 1;
  case 0x34:
  case 0x35:
  case 0x36:
  case 0x37:
  case 0x38:
  case 0x39:
    return 10;
  case 0x3a:
  case 0x3b:
  case 0x3c:
  case 0x3d:
  case 0x3e:
  case 0x3f:
    return 2;
  case 0x40:
  case 0x41:
  case 0x42:
  case 0x43:
  case 0x44:
  case 0x45:
    return 3;
  case 0x46:
  case 0x47:
  case 0x48:
  case 0x49:
  case 0x4a:
  case 0x4b:
    return 4;
  case 0x4c:
  case 0x4d:
  case 0x4e:
  case 0x4f:
  case 0x50:
  case 0x51:
    return 0xd;
  case 0x53:
  case 0x54:
  case 0x55:
  case 0x56:
  case 0x57:
  case 0x58:
    return 0xe;
  case 0x59:
  case 0x5a:
  case 0x5b:
  case 0x5c:
  case 0x5d:
  case 0x5e:
    return 0xf;
  }
}



// Setting prototype: int get_player_level(uint32_t player_type)

int handleGetPlayerLevel(uint32_t player_type)

{
  int iVar1;
  
                    // 
                    // Retrieves the level of a player based on their type.
                    // 
                    // Parameters:
                    //   player_type: The type of the player.
                    // 
                    // Return values:
                    //   The level of the player.
                    // 
  iVar1 = 0;
  if ((0 < (int)player_type) && ((int)player_type < 7)) {
    return 7 - player_type;
  }
  if ((6 < (int)player_type) && ((int)player_type < 0xd)) {
    return 0xd - player_type;
  }
  if ((0x21 < (int)player_type) && ((int)player_type < 0x28)) {
    return 0x28 - player_type;
  }
  if ((0x27 < (int)player_type) && ((int)player_type < 0x2e)) {
    return 0x2e - player_type;
  }
  if ((0x2d < (int)player_type) && ((int)player_type < 0x34)) {
    return 0x34 - player_type;
  }
  if ((0x39 < (int)player_type) && ((int)player_type < 0x40)) {
    return 0x40 - player_type;
  }
  if ((0x3f < (int)player_type) && ((int)player_type < 0x46)) {
    return 0x46 - player_type;
  }
  if ((0x45 < (int)player_type) && ((int)player_type < 0x4c)) {
    return 0x4c - player_type;
  }
  if ((0xc < (int)player_type) && ((int)player_type < 0x13)) {
    return 0x13 - player_type;
  }
  if ((0x33 < (int)player_type) && ((int)player_type < 0x3a)) {
    return 0x3a - player_type;
  }
  if ((0x18 < (int)player_type) && ((int)player_type < 0x1f)) {
    return 0x1f - player_type;
  }
  if ((0x12 < (int)player_type) && ((int)player_type < 0x19)) {
    return 0x19 - player_type;
  }
  if ((0x4b < (int)player_type) && ((int)player_type < 0x52)) {
    return 0x52 - player_type;
  }
  if ((0x58 < (int)player_type) && ((int)player_type < 0x5f)) {
    return 0x5f - player_type;
  }
  if ((0x52 < (int)player_type) && ((int)player_type < 0x59)) {
    iVar1 = 0x59 - player_type;
  }
  return iVar1;
}



// Setting prototype: uint8_t get_random_player_attribute(uint8_t base_value)

uint8_t handleGetRandomPlayerAttribute(uint8_t base_value)

{
  uint16_t max_value;
  int iVar1;
  
                    // 
                    // Generates a random player attribute based on a base value.
                    // 
                    // Parameters:
                    //   base_value: The base value for the attribute.
                    // 
                    // Return values:
                    //   A random attribute value.
                    // 
  if (base_value == '\0') {
    iVar1 = get_random_number(0x2a);
    return (char)iVar1 + '\x15';
  }
  max_value = 0xb;
  if ((float)base_value < 42.0) {
    max_value = 6;
  }
  iVar1 = get_random_number(max_value);
  return base_value + (char)iVar1;
}



// Setting prototype: void *get_player_by_id(uint32_t player_id)

undefined2 * handleGetPlayerById(int player_id)

{
  int *piVar1;
  int iVar2;
  
                    // 
                    // Retrieves a player's data by their ID.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player.
                    // 
                    // Return values:
                    //   A pointer to the player's data structure, or NULL if not found.
                    // 
  iVar2 = 0;
  piVar1 = &DAT_100358a4;
  while (((short)piVar1[-1] == -1 || (*piVar1 != player_id))) {
    piVar1 = piVar1 + 0x87;
    iVar2 = iVar2 + 1;
    if (0x1009aca3 < (int)piVar1) {
      return (undefined2 *)0x0;
    }
  }
  return &DAT_100358a0 + iVar2 * 0x10e;
}



// Setting prototype: void *get_player_residence(void *player_data)

undefined2 * gm_GetPlayerResidence(int player_data)

{
  char cVar1;
  uint uVar2;
  
                    // 
                    // Retrieves a player's residence data.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   A pointer to the residence data, or NULL if not found.
                    // 
  cVar1 = *(char *)(player_data + 2);
  if ((((cVar1 == '\x06') || (cVar1 == '\a')) || (cVar1 == '\x05')) &&
     (((*(ushort *)(player_data + 0x50) & 0x8000) != 0 &&
      (uVar2 = *(ushort *)(player_data + 0x50) & 0xf, uVar2 < 0x10)))) {
    return &DAT_1009aca0 + uVar2 * 0x56;
  }
  return (undefined2 *)0x0;
}



// Setting prototype: uint32_t player_management(uint32_t player_id_1, uint32_t player_id_2)

uint32_t gm_ChangePlayerIdentity(uint32_t player_id_1,uint32_t player_id_2)

{
  void *building_data;
  ushort uVar1;
  ushort uVar2;
  undefined4 uVar3;
  uint uVar4;
  uint uVar5;
  uint8_t uVar6;
  ushort *puVar7;
  uint32_t uVar8;
  undefined4 uVar9;
  ushort *puVar10;
  undefined3 extraout_var;
  int iVar11;
  uint32_t *puVar12;
  int iVar13;
  ushort *puVar14;
  undefined4 *puVar15;
  int iVar16;
  ushort *puVar17;
  undefined4 *puVar18;
  uint32_t *puVar19;
  int local_44c;
  ushort local_438;
  undefined1 local_436;
  undefined4 local_434;
  undefined1 local_42b;
  undefined1 local_2d4;
  undefined4 local_2c8;
  undefined4 local_21c;
  undefined4 local_218;
  ushort *local_a4;
  
                    // 
                    // Manages player data, including updating attributes, handling relationships
                    // (e.g., spouse, child),
                    // and performing cleanup operations.
                    // 
                    // Parameters:
                    //   player_id_1: The ID of the first player.
                    //   player_id_2: The ID of the second player.
                    // 
                    // Return values:
                    //   A status code indicating the result of the operation.
                    // 
  puVar7 = (ushort *)handleGetPlayerById(player_id_1);
  if (puVar7 == (ushort *)0x0) {
    return 0xffffffff;
  }
  iVar16 = 0;
  iVar13 = 0x100;
  do {
    building_data = (void *)(iVar16 + DAT_1014d8c0);
    if (((*(byte *)(iVar16 + DAT_1014d8c0) != 0) &&
        (uVar8 = handleGetBuildingType((uint)*(byte *)(iVar16 + DAT_1014d8c0)), uVar8 == 2)) &&
       (*(ushort *)((int)building_data + 0x27) == *puVar7)) {
      handleSetBuildingOwner(building_data,*DAT_1003546c,(uint)*DAT_1003546c);
    }
    iVar16 = iVar16 + 0xa9;
    iVar13 = iVar13 + -1;
  } while (iVar13 != 0);
  uVar1 = *puVar7;
  uVar9 = get_player_sibling(uVar1);
  puVar10 = (ushort *)handleGetPlayerById(player_id_2);
  if (puVar10 == (ushort *)0x0) {
    return 0xfffffffe;
  }
  uVar2 = *puVar10;
  if (puVar7[0x28] != puVar10[0x28]) {
    puVar10[0x28] = puVar7[0x28];
  }
  handleRemovePlayerFromAmt(puVar7);
  local_436 = (undefined1)puVar7[1];
  local_438 = *puVar7;
  puVar14 = puVar10;
  puVar17 = &local_438;
  for (iVar13 = 0x87; iVar13 != 0; iVar13 = iVar13 + -1) {
    *(undefined4 *)puVar17 = *(undefined4 *)puVar14;
    puVar14 = puVar14 + 2;
    puVar17 = puVar17 + 2;
  }
  local_434 = *(undefined4 *)(puVar7 + 2);
  local_42b = *(undefined1 *)((int)puVar7 + 0xd);
  local_2c8 = *(undefined4 *)(puVar7 + 0xb8);
  uVar8 = handleGetPlayerClass((uint)(byte)puVar10[0xb2]);
  if (uVar8 == 0) {
    local_2d4 = (char)puVar7[0xb2];
  }
  else {
    iVar13 = gm_GetPlayerResidence(puVar7);
    if (iVar13 != 0) {
      uVar6 = handleGetPlayerAttribute((uint)*puVar7,uVar8);
      if (CONCAT31(extraout_var,uVar6) != 0) {
        iVar16 = handleGetPlayerLevel((uint)(byte)puVar10[0xb2]);
        iVar11 = handleGetPlayerLevel(CONCAT31(extraout_var,uVar6));
        if (iVar11 < iVar16) {
          *(char *)(iVar13 + 0x74 + uVar8) = (char)puVar10[0xb2];
        }
        else {
          local_2d4 = (char)puVar7[0xb2];
        }
      }
    }
  }
  uVar3 = *(undefined4 *)(puVar10 + 2);
  uVar4 = (uint)uVar1;
  puVar15 = &local_21c;
  for (iVar13 = 0x87; iVar13 != 0; iVar13 = iVar13 + -1) {
    *puVar15 = *(undefined4 *)puVar7;
    puVar7 = puVar7 + 2;
    puVar15 = puVar15 + 1;
  }
  local_218 = uVar3;
  local_21c._0_3_ = CONCAT12(9,*puVar10);
  uVar5 = (uint)uVar2;
  iVar16 = uVar4 * 0x21c;
  puVar7 = &local_438;
  puVar15 = (undefined4 *)(&DAT_100358a0 + uVar4 * 0x10e);
  for (iVar13 = 0x87; iVar13 != 0; iVar13 = iVar13 + -1) {
    *puVar15 = *(undefined4 *)puVar7;
    puVar7 = puVar7 + 2;
    puVar15 = puVar15 + 1;
  }
  puVar15 = &local_21c;
  puVar18 = (undefined4 *)(&DAT_100358a0 + uVar5 * 0x10e);
  for (iVar13 = 0x87; iVar13 != 0; iVar13 = iVar13 + -1) {
    *puVar18 = *puVar15;
    puVar15 = puVar15 + 1;
    puVar18 = puVar18 + 1;
  }
  for (iVar13 = *(int *)(&DAT_10035a18 + iVar16); iVar13 != 0; iVar13 = *(int *)(iVar13 + 0x3f)) {
    *(undefined4 *)(iVar13 + 6) = (&DAT_100358a4)[uVar4 * 0x87];
  }
  for (iVar13 = *(int *)(&DAT_10035a18 + uVar5 * 0x21c); iVar13 != 0;
      iVar13 = *(int *)(iVar13 + 0x3f)) {
    *(undefined4 *)(iVar13 + 6) = (&DAT_100358a4)[uVar5 * 0x87];
  }
  puVar19 = &DAT_100358fc;
  local_44c = 0x300;
  do {
    iVar13 = 8;
    puVar12 = puVar19;
    do {
      if (*puVar12 == player_id_1) {
        *puVar12 = player_id_2;
      }
      else if (*puVar12 == player_id_2) {
        *puVar12 = player_id_1;
      }
      puVar12 = puVar12 + 1;
      iVar13 = iVar13 + -1;
    } while (iVar13 != 0);
    puVar19 = puVar19 + 0x87;
    local_44c = local_44c + -1;
    puVar7 = local_a4;
  } while (local_44c != 0);
  for (; puVar7 != (ushort *)0x0; puVar7 = *(ushort **)((int)puVar7 + 0x3f)) {
    uVar1 = *puVar7;
    if ((uVar1 != 0) && (*(char *)(DAT_101de450 + (uint)uVar1 * 0x41) == '\t')) {
      gm_AddObject(local_434,(uint)uVar1,*(undefined4 *)(puVar7 + 7));
    }
  }
  *(undefined4 *)(&DAT_10035a48 + iVar16) = uVar9;
  *(undefined4 *)(&DAT_10035a34 + iVar16) = 4;
  *(undefined4 *)(&DAT_10035a68 + iVar16) = 0;
  gm_KillSpieler(local_21c & 0xffff,0);
  return uVar4;
}



// Setting prototype: uint16_t alloc_player(uint32_t player_type, uint32_t father_id, uint32_t
// mother_id, void *player_data, void *building_data, uint8_t gender, uint32_t age, int init_type)

uint16_t gm_AllocPlayer(uint32_t player_type,uint32_t father_id,uint32_t mother_id,void *player_data
                       ,void *building_data,uint8_t gender,uint32_t age,int init_type)

{
  ushort *player_data_00;
  float fVar1;
  byte bVar2;
  ushort uVar3;
  undefined1 uVar4;
  uint8_t uVar5;
  short *psVar6;
  char *pcVar7;
  undefined4 *puVar8;
  uint uVar9;
  int32_t iVar10;
  ushort *puVar11;
  ushort *puVar12;
  byte *pbVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint32_t uVar17;
  int iVar18;
  uint uVar19;
  uint uVar20;
  char cVar21;
  int iVar22;
  int iVar23;
  float *pfVar24;
  char *pcVar25;
  undefined4 *puVar26;
  ushort *puVar27;
  float *pfVar28;
  float10 extraout_ST0;
  float10 extraout_ST0_00;
  float10 fVar29;
  float fVar30;
  float fVar31;
  undefined3 in_stack_00000019;
  int local_408;
  int local_404;
  CHAR local_400 [1024];
  
                    // 
                    // Allocates and initializes a new player.
                    // 
                    // Parameters:
                    //   player_type: The type of player to allocate.
                    //   father_id: The ID of the player's father.
                    //   mother_id: The ID of the player's mother.
                    //   player_data: Pointer to the player's data structure.
                    //   building_data: Pointer to the building data.
                    //   gender: The gender of the player.
                    //   age: The age of the player.
                    //   init_type: The initialization type.
                    // 
                    // Return values:
                    //   The ID of the allocated player, or 0xFFFF on failure.
                    // 
  iVar23 = 0;
  psVar6 = &DAT_100358a0;
  do {
    if (*psVar6 == -1) break;
    psVar6 = psVar6 + 0x10e;
    iVar23 = iVar23 + 1;
  } while ((int)psVar6 < 0x1009aca0);
  if (iVar23 == 0x300) {
    iVar23 = 0;
    pcVar7 = &DAT_100358a2;
    do {
      if (*pcVar7 == '\x0f') break;
      pcVar7 = pcVar7 + 0x21c;
      iVar23 = iVar23 + 1;
    } while ((int)pcVar7 < 0x1009aca2);
  }
  iVar22 = iVar23 * 0x21c;
  if ((&DAT_100358a2)[iVar22] == '\x0f') {
    DAT_10035434 = DAT_10035434 + -1;
  }
  if (iVar23 == 0x300) {
    pcVar7 = s_gm_AllocSpieler__array_overflow__10031604;
    iVar23 = 0x2614;
    goto LAB_100194db;
  }
  player_data_00 = &DAT_100358a0 + iVar23 * 0x10e;
  puVar11 = player_data_00;
  for (iVar18 = 0x87; iVar18 != 0; iVar18 = iVar18 + -1) {
    puVar11[0] = 0;
    puVar11[1] = 0;
    puVar11 = puVar11 + 2;
  }
  *player_data_00 = 0xffff;
  (&DAT_100358a4)[iVar23 * 0x87] = 0xffffffff;
  puVar8 = &DAT_100358fc + iVar23 * 0x87;
  for (iVar18 = 8; iVar18 != 0; iVar18 = iVar18 + -1) {
    *puVar8 = 0xffffffff;
    puVar8 = puVar8 + 1;
  }
  *player_data_00 = (ushort)iVar23;
  (&DAT_100358a2)[iVar22] = (char)player_type;
  (&DAT_10035a10)[iVar23 * 0x87] = 0;
  (&DAT_10035a0c)[iVar23 * 0x87] = 0;
  iVar18 = DAT_10030b6c;
  *(undefined4 *)(iVar22 + 0x10035a90) = 0;
  (&DAT_10035ab0)[iVar23 * 0x87] = 0xffffffff;
  *(undefined1 *)(iVar22 + 0x10035ab5) = 0;
  DAT_10035434 = DAT_10035434 + 1;
  *(undefined1 *)(iVar22 + 0x10035ab6) = 0;
  *(undefined1 *)(iVar22 + 0x10035ab7) = 0;
  *(undefined1 *)(iVar22 + 0x10035ab8) = 1;
  printf_wrapper(local_400,s______>SpID___i_playermode___i_100315e4,iVar18,player_type);
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x2637,local_400,8);
  (&DAT_100358a4)[iVar23 * 0x87] = DAT_10030b6c;
  DAT_10030b6c = DAT_10030b6c + 1;
  *(undefined4 *)(iVar22 + 0x10035a84) = 0x3f800000;
  (&DAT_10035a04)[iVar22] = gender;
  cVar21 = (&DAT_100358a2)[iVar22];
  (&DAT_100358a8)[iVar22] = 100;
  *(uint16_t *)(&DAT_100358aa + iVar22) = (uint16_t)player_data;
  *(undefined1 *)(iVar22 + 0x10035a06) = 0;
  (&DAT_10035a05)[iVar22] = (undefined1)age;
  *(undefined1 *)(iVar22 + 0x10035a94) = 0;
  *(undefined4 *)(&DAT_10035a30 + iVar22) = 4;
  *(undefined4 *)(&DAT_10035a34 + iVar22) = 0;
  *(undefined1 *)(iVar22 + 0x100358ad) = 1;
  *(undefined4 *)(iVar22 + 0x10035a2c) = 0xffffffff;
  *(undefined4 *)(&DAT_10035aac + iVar22) = 0xffffffff;
  if (((cVar21 == '\x03') || (cVar21 == '\x10')) || (cVar21 == '\x13')) {
    *(undefined4 *)(iVar22 + 0x10035a88) = 1;
    *(undefined1 *)(iVar22 + 0x100358ad) = 2;
  }
  if (cVar21 == '\x10') {
    puVar8 = (undefined4 *)alloc_alchemist();
    (&DAT_100358a2)[iVar22] = 3;
    if (puVar8 != (undefined4 *)0x0) {
      uVar9 = get_random_number(8);
      uVar9 = uVar9 & 0xffff;
      *(undefined4 *)(iVar22 + 0x10035a90) = *puVar8;
      (&DAT_10035a04)[iVar22] = *(undefined1 *)(puVar8 + 0x35);
      *(undefined1 *)(iVar22 + 0x100358a9) = *(undefined1 *)((int)puVar8 + 0xd5);
      uVar19 = 0xffffffff;
      (&DAT_100358ac)[iVar22] = *(undefined1 *)((int)puVar8 + 0xd6);
      pcVar7 = (char *)(puVar8 + 1);
      do {
        pcVar25 = pcVar7;
        if (uVar19 == 0) break;
        uVar19 = uVar19 - 1;
        pcVar25 = pcVar7 + 1;
        cVar21 = *pcVar7;
        pcVar7 = pcVar25;
      } while (cVar21 != '\0');
      uVar19 = ~uVar19;
      pcVar7 = pcVar25 + -uVar19;
      pcVar25 = &DAT_100358d0 + iVar22;
      for (uVar20 = uVar19 >> 2; uVar20 != 0; uVar20 = uVar20 - 1) {
        *(undefined4 *)pcVar25 = *(undefined4 *)pcVar7;
        pcVar7 = pcVar7 + 4;
        pcVar25 = pcVar25 + 4;
      }
      for (uVar19 = uVar19 & 3; uVar19 != 0; uVar19 = uVar19 - 1) {
        *pcVar25 = *pcVar7;
        pcVar7 = pcVar7 + 1;
        pcVar25 = pcVar25 + 1;
      }
      uVar19 = 0xffffffff;
      pcVar7 = (char *)(puVar8 + 5);
      do {
        pcVar25 = pcVar7;
        if (uVar19 == 0) break;
        uVar19 = uVar19 - 1;
        pcVar25 = pcVar7 + 1;
        cVar21 = *pcVar7;
        pcVar7 = pcVar25;
      } while (cVar21 != '\0');
      uVar19 = ~uVar19;
      pcVar7 = pcVar25 + -uVar19;
      pcVar25 = &DAT_100358e0 + iVar22;
      for (uVar20 = uVar19 >> 2; uVar20 != 0; uVar20 = uVar20 - 1) {
        *(undefined4 *)pcVar25 = *(undefined4 *)pcVar7;
        pcVar7 = pcVar7 + 4;
        pcVar25 = pcVar25 + 4;
      }
      for (uVar19 = uVar19 & 3; uVar19 != 0; uVar19 = uVar19 - 1) {
        *pcVar25 = *pcVar7;
        pcVar7 = pcVar7 + 1;
        pcVar25 = pcVar25 + 1;
      }
      uVar19 = 0xffffffff;
      pcVar7 = (char *)((int)puVar8 + 0xd7);
      do {
        pcVar25 = pcVar7;
        if (uVar19 == 0) break;
        uVar19 = uVar19 - 1;
        pcVar25 = pcVar7 + 1;
        cVar21 = *pcVar7;
        pcVar7 = pcVar25;
      } while (cVar21 != '\0');
      uVar19 = ~uVar19;
      pcVar7 = pcVar25 + -uVar19;
      pcVar25 = (char *)(iVar22 + 0x10035a94);
      for (uVar20 = uVar19 >> 2; uVar20 != 0; uVar20 = uVar20 - 1) {
        *(undefined4 *)pcVar25 = *(undefined4 *)pcVar7;
        pcVar7 = pcVar7 + 4;
        pcVar25 = pcVar25 + 4;
      }
      for (uVar19 = uVar19 & 3; uVar19 != 0; uVar19 = uVar19 - 1) {
        *pcVar25 = *pcVar7;
        pcVar7 = pcVar7 + 1;
        pcVar25 = pcVar25 + 1;
      }
      *(undefined4 *)(iVar22 + 0x10035920) = puVar8[9];
      *(undefined1 *)(iVar22 + 0x10035924) = *(undefined1 *)(puVar8 + 10);
      puVar8 = puVar8 + 0xb;
      puVar26 = (undefined4 *)(iVar22 + 0x10035928);
      for (iVar23 = 0x2a; iVar23 != 0; iVar23 = iVar23 + -1) {
        *puVar26 = *puVar8;
        puVar8 = puVar8 + 1;
        puVar26 = puVar26 + 1;
      }
      fVar30 = get_random_float();
      *(undefined4 *)(iVar22 + 0x100358bc) = 0x447a0000;
      *(short *)(&DAT_100358f0 + iVar22) = (short)DAT_1003542c;
      DAT_1003542c = DAT_1003542c + 1;
      *(float *)(iVar22 + 0x10035a70) = fVar30 * 0.5 + 0.25;
      fVar30 = get_random_float_in_range();
      *(undefined4 *)(&DAT_100358c0 + iVar22) = 0x41400000;
      *(float *)(iVar22 + 0x100358b4) = fVar30 * 7.0 + 30.0;
      iVar10 = __ftol();
      uVar19 = get_random_number((uint16_t)iVar10);
      *(undefined4 *)(iVar22 + 0x100358b8) = *(undefined4 *)(iVar22 + 0x100358bc);
      *(float *)(iVar22 + 0x100358b0) =
           (*(float *)(iVar22 + 0x100358bc) * 0.33 + (float)(uVar19 & 0xffff)) -
           *(float *)(iVar22 + 0x100358bc) * 0.1;
      if (uVar9 < 2) {
        *(undefined1 *)(iVar22 + 0x10035ab7) = 0x58;
      }
      else if (uVar9 < 4) {
        *(undefined1 *)(iVar22 + 0x10035ab7) = 0x5c;
      }
      uVar3 = *(ushort *)(&DAT_100358aa + iVar22);
      *(byte *)(iVar22 + 0x10035ab7) = ((5 < uVar9) - 1U & 0x86) + 0x3c;
      if (*(float *)(&DAT_100358c0 + iVar22) < (float)uVar3) {
        fVar30 = *(float *)(iVar22 + 0x100358b4);
        iVar23 = __ftol();
        fVar29 = extraout_ST0;
        if (0 < iVar23) {
          do {
            iVar23 = iVar23 + -1;
            fVar29 = (fVar29 - (float10)fVar30) + (float10)fVar30 / fVar29;
          } while (iVar23 != 0);
        }
        if (fVar29 <= (float10)1.0) {
          fVar29 = (float10)1.0;
        }
        *(float *)(iVar22 + 0x100358bc) = (float)fVar29;
        return *player_data_00;
      }
      goto LAB_100196aa;
    }
  }
  bVar2 = (&DAT_100358a2)[iVar22];
  if ((bVar2 == 0x15) || (bVar2 == 0x16)) {
    handlePlayerInit((uint)bVar2,father_id,(uint16_t)player_data,player_data_00);
LAB_100196aa:
    return *player_data_00;
  }
  if (building_data != (void *)0x0) {
                    // WARNING: Load size is inaccurate
    bVar2 = *(byte *)(DAT_100a8c30 + (uint)*building_data * 0x24d);
    if (bVar2 == 1) {
      (&DAT_10035a10)[iVar23 * 0x87] = building_data;
    }
    else if (((3 < bVar2) && (bVar2 < 0x17)) &&
            ((bVar2 != 10 && ((bVar2 != 0xf && (bVar2 != 0x11)))))) {
      (&DAT_10035a0c)[iVar23 * 0x87] = building_data;
    }
  }
  *(char *)(iVar22 + 0x100358ad) = (*(char *)(iVar22 + 0x10035a06) != '\0') + '\x01';
  if (((player_type != 6) && (player_type != 7)) && ((int)player_type < 10)) {
    iVar18 = get_random_number(8);
    *(char *)(iVar22 + 0x10035a50) = (char)iVar18;
  }
  if (init_type == 2) {
    init_type = get_random_number(2);
  }
  *(char *)(iVar22 + 0x100358a9) = (char)init_type;
  if (((int)player_type < 4) || (player_type == 0xb)) {
    if (age == 0) {
      if (_gender == (void *)0x0) goto LAB_10018d26;
      iVar18 = handleIsPlayerInState(_gender);
    }
    else {
      iVar18 = handleIsPlayerInState2(age);
    }
    if (iVar18 != 2) {
      *(char *)(iVar22 + 0x100358a9) = (char)iVar18;
    }
  }
LAB_10018d26:
  puVar11 = (ushort *)handleGetPlayerById(father_id);
  puVar12 = (ushort *)handleGetPlayerById(mother_id);
  if ((puVar11 == (ushort *)0x0) || (puVar12 == (ushort *)0x0)) {
    (&DAT_10035a04)[iVar22] = gender;
    *(undefined1 *)(iVar22 + 0x10035a06) = 0;
    (&DAT_10035a05)[iVar22] = (undefined1)age;
    uVar17 = handleGetPlayerClass((uint)gender);
    uVar9 = get_random_number(8);
    uVar9 = uVar9 & 0xffff;
    if ((&DAT_100358a2)[iVar22] == '\x03') {
      if ((uVar17 == 0xb) || (uVar17 == 0xc)) {
        if (2 < uVar9) {
          cVar21 = ((5 < uVar9) - 1U & 0x9a) - 0x3e;
          goto LAB_100192b3;
        }
        *(undefined1 *)(iVar22 + 0x10035ab7) = 0x58;
      }
      else if (uVar9 < 3) {
        *(undefined1 *)(iVar22 + 0x10035ab7) = 0x3c;
      }
      else {
        *(byte *)(iVar22 + 0x10035ab7) = ((5 < uVar9) - 1U & 4) + 0x58;
      }
    }
    else if ((uVar17 == 0xb) || (uVar17 == 0xc)) {
      *(byte *)(iVar22 + 0x10035ab7) = ((3 < uVar9) - 1U & 0xf8) + 0x56;
    }
    else if (uVar9 < 3) {
      *(undefined1 *)(iVar22 + 0x10035ab7) = 0x3e;
    }
    else {
      cVar21 = ((5 < uVar9) - 1U & 8) + 0x4e;
LAB_100192b3:
      *(char *)(iVar22 + 0x10035ab7) = cVar21;
    }
    iVar18 = 0xe;
    pfVar28 = (float *)(&DAT_10025818 + uVar17 * 0x70);
    pfVar24 = (float *)(iVar22 + 0x10035928);
    do {
      fVar30 = get_random_float();
      *pfVar24 = (pfVar28[1] - *pfVar28) * fVar30 + *pfVar28;
      uVar9 = get_random_number(10);
      pfVar28 = pfVar28 + 2;
      iVar18 = iVar18 + -1;
      pfVar24[2] = (float)(uVar9 & 0xffff) + 900.0;
      pfVar24[1] = *pfVar24 * 0.001;
      pfVar24 = pfVar24 + 3;
    } while (iVar18 != 0);
    fVar30 = get_random_float();
    iVar18 = 0;
    iVar14 = 0;
    fVar30 = (fVar30 + 2.0) * 8.0;
    *(float *)(iVar22 + 0x100359c4) = fVar30;
    *(float *)(iVar22 + 0x100359c8) = fVar30 * 0.001;
    do {
      uVar3 = *player_data_00;
      iVar15 = get_random_number(0x40);
      (&DAT_1014d8e0)[(uint)uVar3 + iVar14] = 0;
      (&DAT_100a9820)[(uint)uVar3 + iVar14] = (char)iVar15 + -0x20;
      iVar15 = (uint)*player_data_00 * 0x300 + iVar18;
      iVar16 = get_random_number(0x40);
      iVar14 = iVar14 + 0x300;
      iVar18 = iVar18 + 1;
      (&DAT_100a9820)[iVar15] = (char)iVar16 + -0x20;
      (&DAT_1014d8e0)[iVar15] = 0;
    } while (iVar14 < 0x90000);
    iVar18 = get_random_number(2);
    (&DAT_100358ac)[iVar22] = (char)iVar18;
    fVar30 = get_random_float();
    *(float *)(iVar22 + 0x10035a70) = fVar30 * 0.5 + 0.25;
    if ((age == 0) || (_gender != (void *)0x0)) {
      iVar18 = 0;
      do {
        uVar5 = handleGetRandomPlayerAttribute
                          ((&DAT_10030ba0)[(uint)(byte)(&DAT_10035a04)[iVar22] * 6 + iVar18]);
        *(uint8_t *)(iVar18 + 0x80 + (int)player_data_00) = uVar5;
        iVar18 = iVar18 + 1;
      } while (iVar18 < 5);
    }
    else {
      iVar18 = 0;
      do {
        uVar5 = handleGetRandomPlayerAttribute
                          ((&DAT_10030dda)[(uint)(byte)(&DAT_10035a05)[iVar22] * 6 + iVar18]);
        *(uint8_t *)(iVar18 + 0x80 + (int)player_data_00) = uVar5;
        iVar18 = iVar18 + 1;
      } while (iVar18 < 5);
    }
    if ((player_type != 6) && (player_type != 7)) {
      *(undefined *)(iVar22 + 0x100358ad) = (&DAT_10030ba5)[(uint)(byte)(&DAT_10035a04)[iVar22] * 6]
      ;
    }
    puVar8 = &DAT_100358fc + iVar23 * 0x87;
    for (iVar18 = 8; iVar18 != 0; iVar18 = iVar18 + -1) {
      *puVar8 = 0xffffffff;
      puVar8 = puVar8 + 1;
    }
    *(uint32_t *)(iVar22 + 0x10035904) = mother_id;
    *(undefined1 *)(iVar22 + 0x100358f8) = 1;
    if (puVar12 != (ushort *)0x0) {
      puVar11 = puVar12 + 0x34;
      *(char *)(iVar22 + 0x100358f8) = (char)puVar12[0x2c] + '\x01';
      iVar18 = 3;
      do {
        if (*(int *)puVar11 == -1) {
          *(undefined4 *)(puVar12 + iVar18 * 2 + 0x2e) = (&DAT_100358a4)[iVar23 * 0x87];
          break;
        }
        iVar18 = iVar18 + 1;
        puVar11 = puVar11 + 2;
      } while (iVar18 < 8);
    }
    if (((player_type == 6) || (player_type == 7)) || (player_type == 5)) {
      if (0xf < DAT_10035430) {
        pcVar7 = s_gm_AllocSpieler____gm_CurrentHum_100315ac;
        iVar23 = 0x27f0;
LAB_100194db:
        logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,iVar23,pcVar7,1);
        return 0xffff;
      }
      uVar3 = (ushort)DAT_10035430;
      DAT_10035430 = DAT_10035430 + 1;
      *(ushort *)(&DAT_100358f0 + iVar22) = uVar3 | 0x8000;
    }
    else if ((int)player_type < 10) {
      *(short *)(&DAT_100358f0 + iVar22) = (short)DAT_1003542c;
      DAT_1003542c = DAT_1003542c + 1;
    }
    else {
      *(undefined2 *)(&DAT_100358f0 + iVar22) = 0x7fff;
    }
    *(undefined4 *)(iVar22 + 0x100358bc) = 0x447a0000;
    fVar30 = get_random_float_in_range();
    *(undefined4 *)(&DAT_100358c0 + iVar22) = 0x41400000;
    *(float *)(iVar22 + 0x100358b4) = fVar30 * 7.0 + 30.0;
    iVar10 = __ftol();
    uVar9 = get_random_number((uint16_t)iVar10);
    *(undefined4 *)(iVar22 + 0x100358b8) = *(undefined4 *)(iVar22 + 0x100358bc);
    *(float *)(iVar22 + 0x100358b0) =
         (*(float *)(iVar22 + 0x100358bc) * 0.33 + (float)(uVar9 & 0xffff)) -
         *(float *)(iVar22 + 0x100358bc) * 0.1;
    get_random_number(0x10);
    goto LAB_10019572;
  }
  *(undefined1 *)(iVar22 + 0x100358ad) = 1;
  cVar21 = (char)puVar11[1];
  if (((cVar21 == '\x06') || (cVar21 == '\a')) || (cVar21 == '\x05')) {
    (&DAT_100358ac)[iVar22] = (char)puVar11[6];
    *(undefined4 *)(iVar22 + 0x10035a70) = *(undefined4 *)(puVar11 + 0xe8);
    uVar4 = *(undefined1 *)((int)puVar11 + 0x217);
LAB_10018e05:
    *(undefined1 *)(iVar22 + 0x10035ab7) = uVar4;
  }
  else {
    cVar21 = (char)puVar12[1];
    if (((cVar21 == '\x06') || (cVar21 == '\a')) || (cVar21 == '\x05')) {
      (&DAT_100358ac)[iVar22] = (char)puVar12[6];
      *(undefined4 *)(iVar22 + 0x10035a70) = *(undefined4 *)(puVar12 + 0xe8);
      uVar4 = *(undefined1 *)((int)puVar12 + 0x217);
      goto LAB_10018e05;
    }
    if (*(byte *)((int)puVar11 + 0xd) < *(byte *)((int)puVar12 + 0xd)) {
      (&DAT_100358ac)[iVar22] = (char)puVar12[6];
      *(undefined4 *)(iVar22 + 0x10035a70) = *(undefined4 *)(puVar12 + 0xe8);
      *(undefined1 *)(iVar22 + 0x10035ab7) = *(undefined1 *)((int)puVar12 + 0x217);
    }
    else {
      (&DAT_100358ac)[iVar22] = (char)puVar11[6];
      *(undefined4 *)(iVar22 + 0x10035a70) = *(undefined4 *)(puVar11 + 0xe8);
      *(undefined1 *)(iVar22 + 0x10035ab7) = *(undefined1 *)((int)puVar11 + 0x217);
    }
  }
  iVar18 = 0xe;
  pfVar24 = (float *)(iVar22 + 0x10035928);
  do {
    fVar30 = get_random_float();
    pfVar28 = (float *)(((int)puVar11 - (int)player_data_00) + (int)pfVar24);
    *pfVar24 = fVar30 * *pfVar28 +
               (1.0 - fVar30) * *(float *)((int)pfVar28 + ((int)puVar12 - (int)puVar11));
    uVar9 = get_random_number(10);
    iVar18 = iVar18 + -1;
    pfVar24[2] = (float)(uVar9 & 0xffff) + 900.0;
    pfVar24[1] = *pfVar24 * 0.001;
    pfVar24 = pfVar24 + 3;
  } while (iVar18 != 0);
  fVar30 = get_random_float();
  iVar18 = 1;
  fVar30 = (fVar30 + 2.0) * 8.0;
  local_408 = 0;
  local_404 = 0;
  pbVar13 = (byte *)((int)puVar12 + 0x81);
  *(float *)(iVar22 + 0x100359c4) = fVar30;
  *(float *)(iVar22 + 0x100359c8) = fVar30 * 0.001;
  do {
    if (*(byte *)((int)puVar11 + local_408 + 0x80) < pbVar13[(int)puVar11 - (int)puVar12]) {
      local_408 = iVar18;
    }
    if (*(byte *)((int)puVar12 + local_404 + 0x80) < *pbVar13) {
      local_404 = iVar18;
    }
    iVar18 = iVar18 + 1;
    pbVar13 = pbVar13 + 1;
  } while (iVar18 < 5);
  iVar18 = 0;
  do {
    get_random_float();
    iVar10 = __ftol();
    *(char *)(iVar18 + 0x80 + (int)player_data_00) = (char)iVar10;
    iVar18 = iVar18 + 1;
  } while (iVar18 < 5);
  (&DAT_10035900)[iVar23 * 0x87] = father_id;
  *(uint32_t *)(iVar22 + 0x10035904) = mother_id;
  *(undefined4 *)(&DAT_10035908 + iVar22) = 0xffffffff;
  iVar18 = 3;
  *(undefined4 *)(&DAT_1003590c + iVar22) = 0xffffffff;
  puVar27 = puVar11 + 0x34;
  *(undefined4 *)(iVar22 + 0x10035910) = 0xffffffff;
  *(undefined4 *)(iVar22 + 0x10035914) = 0xffffffff;
  *(undefined4 *)(iVar22 + 0x10035918) = 0xffffffff;
  do {
    if (*(int *)puVar27 == -1) {
      *(undefined4 *)(puVar11 + iVar18 * 2 + 0x2e) = (&DAT_100358a4)[iVar23 * 0x87];
      break;
    }
    iVar14 = handleGetPlayerById(*(int *)puVar27);
    if (*(char *)(iVar14 + 2) == '\x0f') {
      *(undefined4 *)(puVar11 + iVar18 * 2 + 0x2e) = (&DAT_100358a4)[iVar23 * 0x87];
      break;
    }
    iVar18 = iVar18 + 1;
    puVar27 = puVar27 + 2;
  } while (iVar18 < 8);
  iVar18 = 3;
  puVar27 = puVar12 + 0x34;
  do {
    if (*(int *)puVar27 == -1) {
      *(undefined4 *)(puVar12 + iVar18 * 2 + 0x2e) = (&DAT_100358a4)[iVar23 * 0x87];
      break;
    }
    iVar14 = handleGetPlayerById(*(int *)puVar27);
    if (*(char *)(iVar14 + 2) == '\x0f') {
      *(undefined4 *)(puVar12 + iVar18 * 2 + 0x2e) = (&DAT_100358a4)[iVar23 * 0x87];
      break;
    }
    iVar18 = iVar18 + 1;
    puVar27 = puVar27 + 2;
  } while (iVar18 < 8);
  *(undefined4 *)(iVar22 + 0x1003591c) = 0;
  cVar21 = (char)puVar12[1];
  if (((cVar21 == '\x06') || (cVar21 == '\a')) || (cVar21 == '\x05')) {
    *(ushort *)(&DAT_100358f0 + iVar22) = puVar12[0x28];
    *(char *)(iVar22 + 0x100358f8) = (char)puVar12[0x2c] + '\x01';
    *(undefined4 *)(&DAT_100358f4 + iVar22) = *(undefined4 *)(puVar12 + 0x2a);
  }
  else {
    *(ushort *)(&DAT_100358f0 + iVar22) = puVar11[0x28];
    *(char *)(iVar22 + 0x100358f8) = (char)puVar11[0x2c] + '\x01';
    *(undefined4 *)(&DAT_100358f4 + iVar22) = *(undefined4 *)(puVar11 + 0x2a);
  }
  *(undefined4 *)(iVar22 + 0x100358bc) = 0x447a0000;
  fVar31 = get_random_float_in_range();
  fVar30 = *(float *)(puVar12 + 10);
  fVar1 = *(float *)(puVar11 + 10);
  *(undefined4 *)(&DAT_100358c0 + iVar22) = 0x41400000;
  *(float *)(iVar22 + 0x100358b4) = (fVar30 + fVar1) * 0.2 + (fVar31 * 7.0 + 30.0) * 0.6;
  iVar10 = __ftol();
  uVar9 = get_random_number((uint16_t)iVar10);
  iVar18 = 0;
  *(undefined4 *)(iVar22 + 0x100358b8) = *(undefined4 *)(iVar22 + 0x100358bc);
  iVar14 = 0;
  *(float *)(iVar22 + 0x100358b0) =
       (*(float *)(iVar22 + 0x100358bc) * 0.33 + (float)(uVar9 & 0xffff)) -
       *(float *)(iVar22 + 0x100358bc) * 0.1;
  do {
    uVar3 = *player_data_00;
    iVar15 = get_random_number(0x40);
    (&DAT_1014d8e0)[(uint)uVar3 + iVar14] = 0;
    (&DAT_100a9820)[(uint)uVar3 + iVar14] = (char)iVar15 + -0x20;
    iVar15 = (uint)*player_data_00 * 0x300 + iVar18;
    iVar16 = get_random_number(0x40);
    iVar14 = iVar14 + 0x300;
    iVar18 = iVar18 + 1;
    (&DAT_100a9820)[iVar15] = (char)iVar16 + -0x20;
    (&DAT_1014d8e0)[iVar15] = 0;
  } while (iVar14 < 0x90000);
  iVar18 = get_random_number(0x20);
  (&DAT_100a9820)[(uint)*puVar11 + (uint)*player_data_00 * 0x300] = '\x7f' - (char)iVar18;
  iVar18 = get_random_number(0x20);
  (&DAT_100a9820)[(uint)*player_data_00 + (uint)*puVar11 * 0x300] = '\x7f' - (char)iVar18;
  iVar18 = get_random_number(0x20);
  (&DAT_100a9820)[(uint)*puVar12 + (uint)*player_data_00 * 0x300] = '\x7f' - (char)iVar18;
  iVar18 = get_random_number(0x20);
  (&DAT_100a9820)[(uint)*player_data_00 + (uint)*puVar12 * 0x300] = '\x7f' - (char)iVar18;
LAB_10019572:
  get_random_number(0x10);
  if (*(float *)(&DAT_100358c0 + iVar22) < (float)*(ushort *)(&DAT_100358aa + iVar22)) {
    fVar30 = *(float *)(iVar22 + 0x100358b4);
    iVar18 = __ftol();
    fVar29 = extraout_ST0_00;
    if (0 < iVar18) {
      do {
        iVar18 = iVar18 + -1;
        fVar29 = (fVar29 - (float10)fVar30) + (float10)fVar30 / fVar29;
      } while (iVar18 != 0);
    }
    if (fVar29 <= (float10)1.0) {
      fVar29 = (float10)1.0;
    }
    *(float *)(iVar22 + 0x100358bc) = (float)fVar29;
  }
  *(undefined4 *)(iVar22 + 0x10035a54) = 0;
  *(undefined4 *)(iVar22 + 0x10035a58) = 0;
  *(undefined4 *)(iVar22 + 0x10035a5c) = 0;
  *(undefined4 *)(iVar22 + 0x10035a60) = 0;
  player_AemterInit(player_data_00);
  cVar21 = (&DAT_100358a2)[iVar22];
  if (((cVar21 == '\x03') || (cVar21 == '\x04')) || ((cVar21 == '\x02' || (cVar21 == '\x13')))) {
    uVar9 = get_random_number(3);
    *(char *)((uVar9 & 0xffff) + 0x82 + (int)player_data_00) =
         *(char *)((uVar9 & 0xffff) + 0x82 + (int)player_data_00) + '*';
  }
  if (iVar23 == 0xffff) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x286c,s_gm_AllocSpieler__bug_10031594,1)
    ;
  }
  printf_wrapper(local_400,s______>PlayerID___i_PlayerName____10031570,DAT_10030b6c,
                 &DAT_100358d0 + iVar22);
  logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x2888,local_400,8);
  return (ushort)iVar23;
}



// Setting prototype: int get_building_item_count(uint32_t building_id, uint32_t item_id)

int get_building_item_count(uint32_t building_id,uint32_t item_id)

{
  short *psVar1;
  int iVar2;
  
                    // 
                    // Retrieves the count of a specific item within a building.
                    // 
                    // Parameters:
                    //   building_id: The ID of the building.
                    //   item_id: The ID of the item to count.
                    // 
                    // Return values:
                    //   The count of the item in the building.
                    // 
  iVar2 = 0;
  psVar1 = (short *)handleFindObjectInList(building_id,1,4,9);
  if (psVar1 != (short *)0x0) {
    do {
      if (*(short *)(&DAT_100a8c94 + (item_id & 0xff) * 0x2f4) == *psVar1) {
        iVar2 = iVar2 + *(int *)(psVar1 + 7);
      }
      psVar1 = (short *)handleGetNextObjectFromList();
    } while (psVar1 != (short *)0x0);
    return iVar2;
  }
  return 0;
}



// Setting prototype: float calculate_item_value(uint32_t item_id, uint32_t quantity)

float gm_CalculateItemValue(uint32_t item_id,uint32_t quantity)

{
  byte *pbVar1;
  ushort uVar2;
  int iVar3;
  int32_t iVar4;
  char *pcVar5;
  int iVar6;
  ushort *puVar7;
  float fVar8;
  
                    // 
                    // Calculates the value of an item based on its ID and quantity.
                    // 
                    // Parameters:
                    //   item_id: The ID of the item.
                    //   quantity: The quantity of the item.
                    // 
                    // Return values:
                    //   The calculated value of the item.
                    // 
  pcVar5 = (char *)(DAT_101de450 + item_id * 0x41);
  iVar6 = 0;
  if (*(int *)(pcVar5 + 0x38) == 0) {
    if ((&DAT_101dd8e0)[item_id] == 0) {
      fVar8 = 4.0;
    }
    else {
      fVar8 = 0.0;
      iVar3 = 0;
      do {
        pbVar1 = (byte *)(DAT_100a8c30 + (&DAT_101dd8e0)[item_id] * 0x24d + 0x233 + iVar3);
        iVar3 = iVar3 + 1;
        fVar8 = fVar8 + (float)*pbVar1 * 896.0 * 0.0013888889;
      } while (iVar3 < 2);
    }
    item_id = (uint32_t)
              (((float)*(uint *)(pcVar5 + 0x22) /
               (float)((uint)(*(ushort *)(pcVar5 + 0x36) == 0) + (uint)*(ushort *)(pcVar5 + 0x36)))
              * fVar8 * 0.5);
    if (*pcVar5 == '\x17') {
      return (float)item_id * 2.2;
    }
    puVar7 = (ushort *)(pcVar5 + 0x2e);
    do {
      uVar2 = *puVar7;
      if (uVar2 == 0) break;
      if (uVar2 != 0xffff) {
        fVar8 = gm_CalculateItemValue((uint)uVar2,quantity);
        item_id = (uint32_t)
                  ((fVar8 * (float)puVar7[-4]) / (float)*(ushort *)(pcVar5 + 0x36) + (float)item_id)
        ;
      }
      iVar6 = iVar6 + 1;
      puVar7 = puVar7 + 1;
    } while (iVar6 < 4);
    iVar4 = __ftol();
    *(int32_t *)(pcVar5 + 0x38) = iVar4;
    fVar8 = (float)(quantity & 0xff) * (float)item_id * 0.01 * 2.2;
  }
  else {
    fVar8 = (float)(*(int *)(pcVar5 + 0x38) << 5) * (float)(quantity & 0xff) * 0.01;
    if (pcVar5[0x21] == '\x03') {
      return fVar8 * 1.5;
    }
  }
  return fVar8;
}



// Setting prototype: void item_management(void *building_data)

void item_management(void *building_data)

{
  char cVar1;
  bool bVar2;
  uint uVar3;
  ushort *puVar4;
  undefined4 extraout_ECX;
  int iVar5;
  ushort *puVar6;
  ushort *puVar7;
  undefined8 uVar8;
  
                    // 
                    // Manages items within a building, including calculating their values.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // WARNING: Load size is inaccurate
  puVar6 = (ushort *)0x0;
  bVar2 = false;
  iVar5 = 0;
  puVar7 = (ushort *)(DAT_100a8c30 + (uint)*building_data * 0x24d + 0x25);
  do {
    if (puVar7[-1] == 0) break;
    uVar3 = puVar7[-1] & 0x7fff;
    if (bVar2) {
      if (puVar6 != (ushort *)0x0) {
        puVar4 = (ushort *)handleFindObjectInList(*(undefined4 *)(puVar6 + 10),1,0,uVar3);
        if (puVar4 != (ushort *)0x0) {
          gm_CalculateItemValue
                    ((uint)*puVar4,CONCAT31((int3)((uint)extraout_ECX >> 8),(char)puVar4[9]));
          __ftol();
        }
        if ((iVar5 < 0x3f) &&
           ((cVar1 = *(char *)(DAT_101de450 + (*puVar7 & 0x7fff) * 0x41), cVar1 == '\x02' ||
            (cVar1 == '\x06')))) {
          bVar2 = false;
        }
      }
    }
    else {
      cVar1 = *(char *)(DAT_101de450 + uVar3 * 0x41);
      if ((cVar1 == '\x02') || (cVar1 == '\x06')) {
        uVar8 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),1,0,uVar3);
        puVar6 = (ushort *)uVar8;
        if (puVar6 != (ushort *)0x0) {
          gm_CalculateItemValue
                    ((uint)*puVar6,CONCAT31((int3)((ulonglong)uVar8 >> 0x28),(char)puVar6[9]));
          __ftol();
          if (((iVar5 < 0x3f) &&
              (cVar1 = *(char *)(DAT_101de450 + (*puVar7 & 0x7fff) * 0x41), cVar1 != '\x02')) &&
             (cVar1 != '\x06')) {
            bVar2 = true;
          }
        }
      }
    }
    iVar5 = iVar5 + 1;
    puVar7 = puVar7 + 1;
  } while (iVar5 < 0x40);
  __ftol();
  return;
}



// Setting prototype: int get_building_object_count(void *building_data)

int get_building_object_count(void *building_data)

{
  int iVar1;
  int iVar2;
  
                    // 
                    // Retrieves the total count of objects within a building.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   The total count of objects.
                    // 
  iVar2 = 0;
  iVar1 = handleFindObjectInList
                    (*(undefined4 *)((int)building_data + 0x178),1,0,
                     *(undefined2 *)(&DAT_100a8c94 + (uint)DAT_10035439 * 0x2f4));
  while (iVar1 != 0) {
    iVar2 = iVar2 + *(int *)(iVar1 + 0xe);
    iVar1 = handleGetNextObjectFromList();
  }
  return iVar2;
}



// Setting prototype: uint32_t object_management_3(void *building_data)

uint32_t object_management_3(void *building_data)

{
  undefined4 uVar1;
  int iVar2;
  ushort *puVar3;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  uint32_t uVar4;
  
                    // 
                    // Manages objects within a building, specifically calculating item values.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   A calculated value related to the objects.
                    // 
  uVar4 = 0;
  iVar2 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x5d),2,6,0,0x2a);
  if (iVar2 != 0) {
    puVar3 = (ushort *)handleFindObjectInList(*(undefined4 *)(iVar2 + 0x14),1,5);
    uVar1 = extraout_ECX;
    while (puVar3 != (ushort *)0x0) {
      gm_CalculateItemValue((uint)*puVar3,CONCAT31((int3)((uint)uVar1 >> 8),(char)puVar3[9]));
      uVar4 = __ftol();
      puVar3 = (ushort *)handleGetNextObjectFromList();
      uVar1 = extraout_ECX_00;
    }
  }
  return uVar4;
}



// Setting prototype: void *get_player_spouse(void *player_data)

undefined2 * gm_GetPlayerSpouse(undefined2 *player_data)

{
  void *local_4;
  
                    // 
                    // Retrieves a player's spouse data.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   A pointer to the spouse's data, or NULL if no spouse is found.
                    // 
  gm_LoadGameData(&local_4,(void **)0x0,&player_data,*(uint32_t *)(player_data + 5));
  if (player_data == (undefined2 *)0x0) {
    if ((local_4 != (void *)0x0) && (*(ushort *)((int)local_4 + 0x27) != 0xffff)) {
      return &DAT_100358a0 + (uint)*(ushort *)((int)local_4 + 0x27) * 0x10e;
    }
    player_data = (undefined2 *)0x0;
  }
  return player_data;
}



// Setting prototype: uint16_t get_player_child(void *player_data)

uint16_t get_player_child(void *player_data)

{
  void *local_4;
  
                    // 
                    // Retrieves a player's child data.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   The ID of the child, or 0xFFFF if no child is found.
                    // 
  gm_LoadGameData(&local_4,(void **)0x0,&player_data,*(uint32_t *)((int)player_data + 10));
  if (player_data != (void *)0x0) {
                    // WARNING: Load size is inaccurate
    return *player_data;
  }
  if (local_4 != (void *)0x0) {
    return *(uint16_t *)((int)local_4 + 0x27);
  }
  return 0xffff;
}



// Setting prototype: void *get_player_parent(void *player_data)

int gm_GetPlayerParent(void *player_data)

{
  int iVar1;
  uint32_t id;
  void *local_8;
  void *local_4;
  
                    // 
                    // Retrieves a player's parent data.
                    // 
                    // Parameters:
                    //   player_data: Pointer to the player's data structure.
                    // 
                    // Return values:
                    //   A pointer to the parent's data, or NULL if no parent is found.
                    // 
  id = *(uint32_t *)((int)player_data + 6);
  while( true ) {
    if ((id == 0xffffffff) ||
       (iVar1 = gm_LoadGameData(&player_data,&local_4,&local_8,id), iVar1 == 0)) {
      return 0;
    }
    if (player_data != (void *)0x0) {
      return (int)player_data;
    }
    if (local_8 != (void *)0x0) break;
    if (local_4 != (void *)0x0) {
      id = *(uint32_t *)((int)local_4 + 6);
    }
    local_8 = (void *)0x0;
    player_data = (void *)0x0;
  }
  return 0;
}



// Setting prototype: void *get_player_sibling(uint16_t player_id)

int get_player_sibling(ushort player_id)

{
  int iVar1;
  void *building_data;
  void *pvVar2;
  uint32_t uVar3;
  uint uVar4;
  
                    // 
                    // Retrieves a player's sibling data.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player.
                    // 
                    // Return values:
                    //   A pointer to the sibling's data, or -1 if no sibling is found.
                    // 
  if (0x2ff < player_id) {
    return -1;
  }
  uVar4 = (uint)player_id;
  if ((&DAT_100358a0)[uVar4 * 0x10e] != -1) {
    iVar1 = get_building_object_count(&DAT_100358a0 + uVar4 * 0x10e);
    building_data = (void *)gm_FindObject(1,3,uVar4);
    while (building_data != (void *)0x0) {
      pvVar2 = building_data;
      item_management(building_data);
      uVar3 = object_management_3(building_data);
      iVar1 = (int)pvVar2 + uVar3 + iVar1;
      building_data = (void *)handleGetNextBuilding();
    }
    return iVar1;
  }
  return -1;
}



// Setting prototype: void *get_player_residence_2(uint32_t player_id)

undefined2 * get_player_residence_2(int player_id)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  
                    // 
                    // Retrieves a player's residence data by player ID.
                    // 
                    // Parameters:
                    //   player_id: The ID of the player.
                    // 
                    // Return values:
                    //   A pointer to the residence data, or NULL if not found.
                    // 
  if (player_id == 0) {
    return (undefined2 *)0x0;
  }
  iVar3 = 0;
  pcVar2 = &DAT_100358a2;
  while (((pcVar2[0x162] == '\0' || (*(int *)(pcVar2 + 0x16a) != player_id)) ||
         ((cVar1 = *pcVar2, cVar1 != '\x06' &&
          (((cVar1 != '\a' && (cVar1 != '\x01')) && (cVar1 != '\x02'))))))) {
    pcVar2 = pcVar2 + 0x21c;
    iVar3 = iVar3 + 1;
    if (0x1009aca1 < (int)pcVar2) {
      return (undefined2 *)0x0;
    }
  }
  return &DAT_100358a0 + iVar3 * 0x10e;
}



// Setting prototype: int get_building_item_count_2(void *item_data, void *object_data)

int gm_GetBuildingItemCount(void *item_data,void *object_data)

{
  short sVar1;
  
                    // 
                    // Retrieves the item count of a building, with special handling for certain
                    // item types.
                    // 
                    // Parameters:
                    //   item_data: Pointer to the item's data structure.
                    //   object_data: Pointer to the object's data structure.
                    // 
                    // Return values:
                    //   The item count.
                    // 
                    // WARNING: Load size is inaccurate
  sVar1 = *item_data;
  if ((((sVar1 != 0x2a) && (sVar1 != 0x116)) && (sVar1 != 0x1db)) && (sVar1 != 0x1dc)) {
    return *(int *)((int)object_data + 0xe);
  }
  return *(int *)((int)object_data + 0xe) + -1;
}



// Setting prototype: int get_building_inventory_size(void *building_data)

int get_building_inventory_size(void *building_data)

{
  int iVar1;
  
                    // 
                    // Retrieves the inventory size of a building based on its type.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    // 
                    // Return values:
                    //   The inventory size in bytes.
                    // 
                    // WARNING: Load size is inaccurate
  iVar1 = *(int *)((int)building_data + 0xe);
  if (*building_data == 0x1dd) {
    return (iVar1 + 2) * 5;
  }
  if (iVar1 == 3) {
    return 0x50;
  }
  return iVar1 * 0x14;
}



// Setting prototype: int is_building_inventory_full(void *building_data, uint32_t item_id, int
// quantity)

int gm_IsBuildingInventoryFull(void *building_data,uint32_t item_id,int quantity)

{
  char cVar1;
  byte *pbVar2;
  uint32_t uVar3;
  int iVar4;
  void *pvVar5;
  int iVar6;
  ushort *puVar7;
  int iVar8;
  char *pcVar9;
  bool bVar10;
  uint32_t uVar11;
  
                    // 
                    // Checks if a building's inventory is full for a given item and quantity.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   item_id: The ID of the item to check.
                    //   quantity: The quantity of the item.
                    // 
                    // Return values:
                    //   The remaining space if not full, or 0 if full.
                    // 
  pbVar2 = (byte *)gm_GetPlayerParent(building_data);
  if (pbVar2 == (byte *)0x0) {
    logMessage(s_D__Develop_DieGildeAddOn_game_sp_10031004,0x31de,&DAT_10031628,1);
    return 0;
  }
  uVar3 = handleGetBuildingType((uint)*pbVar2);
  pvVar5 = building_data;
  uVar11 = item_id;
  iVar4 = get_building_inventory_size(building_data);
  pvVar5 = (void *)handleFindObjectInList
                             (*(undefined4 *)((int)building_data + 0x14),1,0,item_id,pvVar5,uVar11);
  if (pvVar5 == (void *)0x0) {
    pcVar9 = (char *)(DAT_101de450 + item_id * 0x41);
    if (uVar3 != 2) {
      cVar1 = *pcVar9;
      if ((cVar1 == '\x17') || (cVar1 == '%')) {
        bVar10 = true;
      }
      else {
        bVar10 = false;
      }
    }
    else {
      bVar10 = *pcVar9 == '\x17';
    }
                    // WARNING: Load size is inaccurate
    if (*building_data == 0x2a) {
      iVar6 = 0;
      puVar7 = (ushort *)handleFindObjectInList(*(undefined4 *)((int)building_data + 0x14),1,5);
      while (puVar7 != (ushort *)0x0) {
        pcVar9 = (char *)(DAT_101de450 + (uint)*puVar7 * 0x41);
        if (uVar3 != 2) {
          cVar1 = *pcVar9;
          if (bVar10) {
            if ((cVar1 == '\x17') || (cVar1 == '%')) goto LAB_10019e56;
          }
          else if ((cVar1 != '\x17') && (cVar1 != '%')) goto LAB_10019e56;
        }
        else {
          cVar1 = *pcVar9;
          if (bVar10) {
            if (cVar1 == '\x17') {
LAB_10019e56:
              iVar6 = iVar6 + 1;
            }
          }
          else if (cVar1 != '\x17') goto LAB_10019e56;
        }
        puVar7 = (ushort *)handleGetNextObjectFromList();
      }
      if (bVar10) {
        if ((int)(uint)*(byte *)((int)building_data + 0x1c) <= iVar6) {
          return 0;
        }
      }
      else if ((int)(uint)*(byte *)((int)building_data + 0x1d) <= iVar6) {
        return 0;
      }
    }
    else {
      iVar6 = 0;
      iVar8 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x14),1,5);
      while (iVar8 != 0) {
        iVar6 = iVar6 + 1;
        iVar8 = handleGetNextObjectFromList();
      }
      if ((int)(uint)*(byte *)((int)building_data + 0x1c) <= iVar6) {
        return 0;
      }
    }
    if (iVar4 < quantity) {
      quantity = iVar4;
    }
  }
  else {
    iVar6 = gm_GetBuildingItemCount(building_data,pvVar5);
    if (iVar4 - iVar6 <= quantity) {
      return iVar4 - iVar6;
    }
  }
  return quantity;
}



// Setting prototype: uint32_t add_item_to_building_inventory(void *building_data, uint32_t item_id,
// uint32_t quantity)

uint32_t add_item_to_building_inventory(void *building_data,uint32_t item_id,uint32_t quantity)

{
  byte bVar1;
  bool bVar2;
  uint uVar3;
  int iVar4;
  ushort *puVar5;
  undefined4 *puVar6;
  uint32_t uVar7;
  undefined4 local_20;
  uint local_1c [7];
  
                    // 
                    // Adds an item to a building's inventory.
                    // 
                    // Parameters:
                    //   building_data: Pointer to the building's data structure.
                    //   item_id: The ID of the item to add.
                    //   quantity: The quantity of the item to add.
                    // 
                    // Return values:
                    //   The remaining quantity that could not be added, or 0 if all added
                    // successfully.
                    // 
  uVar7 = 0;
  bVar2 = false;
  local_20 = 8;
  local_1c[0] = 0xc;
  bVar1 = *(byte *)(DAT_101de450 + item_id * 0x41);
  local_1c[1] = 0x12;
  local_1c[2] = 0x19;
  local_1c[3] = 0x22;
  local_1c[4] = 0x20;
  local_1c[5] = 0x27;
  local_1c[6] = 0;
  if (bVar1 == 9) {
    return quantity;
  }
  uVar3 = 8;
  puVar6 = &local_20;
  do {
    if (uVar3 == bVar1) {
      bVar2 = true;
      break;
    }
    uVar3 = puVar6[1];
    puVar6 = puVar6 + 1;
  } while (uVar3 != 0);
  if ((((*(char *)((int)building_data + 2) == '\x06') || (*(char *)((int)building_data + 2) == '\a')
       ) && (iVar4 = get_alchemist_by_id(item_id), iVar4 != 0)) ||
     (((item_id == 0x179 || (item_id == 0x17a)) || (!bVar2)))) {
    return 0;
  }
  iVar4 = handleFindObjectInList(*(undefined4 *)((int)building_data + 0x178),1,0,item_id);
  if (iVar4 == 0) {
    iVar4 = 0;
    puVar5 = (ushort *)handleFindObjectInList(*(undefined4 *)((int)building_data + 0x178),1,5);
    if (puVar5 != (ushort *)0x0) {
      do {
        if (*(char *)(DAT_101de450 + (uint)*puVar5 * 0x41) != '\t') {
          iVar4 = iVar4 + 1;
        }
        puVar5 = (ushort *)handleGetNextObjectFromList();
      } while (puVar5 != (ushort *)0x0);
      if (5 < iVar4) goto LAB_1001a03f;
    }
    uVar7 = 3;
    if (3 < (int)quantity) goto LAB_1001a03f;
  }
  else {
    get_alchemist_by_id(item_id);
    if (3 < (int)(*(int *)(iVar4 + 0xe) + quantity)) {
      uVar3 = 3 - *(int *)(iVar4 + 0xe);
      return ((int)uVar3 < 0) - 1 & uVar3;
    }
  }
  uVar7 = quantity;
LAB_1001a03f:
  return ((int)uVar7 < 0) - 1 & uVar7;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void building_management_4(void)

void building_management_4(void)

{
  int iVar1;
  
                    // 
                    // Manages buildings, specifically updating the state of objects within them.
                    // 
  iVar1 = gm_FindObject(1,0,0x1e);
  while (iVar1 != 0) {
    iVar1 = handleFindObjectInList(*(undefined4 *)(iVar1 + 0x5d),1,0,0xff);
    if (iVar1 != 0) {
      iVar1 = handleFindObjectInList(*(undefined4 *)(iVar1 + 0x14),1,5);
      while (iVar1 != 0) {
        if (*(int *)(iVar1 + 0xe) != 2) {
          *(undefined4 *)(iVar1 + 0xe) = 2;
        }
        iVar1 = handleGetNextObjectFromList();
      }
    }
    iVar1 = handleGetNextBuilding();
  }
  return;
}



// Setting prototype: int get_random_number(uint16_t max_value)

int get_random_number(uint16_t max_value)

{
  int iVar1;
  
                    // 
                    // Generates a random integer between 0 (inclusive) and max_value (exclusive).
                    // 
                    // Parameters:
                    //   max_value: The upper bound for the random number (exclusive).
                    // 
                    // Return values:
                    //   A random integer.
                    // 
  if (max_value != 0) {
    iVar1 = _rand();
    return iVar1 % (int)(uint)max_value;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: float get_random_float(void)

float get_random_float(void)

{
  int iVar1;
  
                    // 
                    // Generates a random floating-point number between 0.0 (inclusive) and 1.0
                    // (exclusive).
                    // 
                    // Return values:
                    //   A random floating-point number.
                    // 
  iVar1 = _rand();
  return (float)iVar1 * 3.051851e-05;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: float get_random_float_in_range(void)

float get_random_float_in_range(void)

{
  float fVar1;
  
                    // 
                    // Generates a random floating-point number within a specific range.
                    // 
                    // Return values:
                    //   A random floating-point number within the defined range.
                    // 
  fVar1 = get_random_float();
  fVar1 = (fVar1 + fVar1) - 1.0;
  if (fVar1 < 0.0) {
    return fVar1 * -1.0 * fVar1;
  }
  return fVar1 * 1.0 * fVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void init_random(void)

void init_random(void)

{
  DWORD seed;
  
                    // 
                    // Initializes the random number generator using the current time as a seed.
                    // 
  seed = timeGetTime();
  seed_random_2(seed);
  return;
}



// Setting prototype: void seed_random(uint32_t seed)

void seed_random(uint32_t seed)

{
                    // 
                    // Seeds the random number generator.
                    // 
                    // Parameters:
                    //   seed: The seed value.
                    // 
  seed_random_2(seed);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int closesocket(int socket)

int closesocket(int socket)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a160. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Closes an existing socket.
                    // 
                    // Parameters:
                    //   socket: The socket descriptor to close.
                    // 
                    // Return values:
                    //   0 if successful, or SOCKET_ERROR on error.
                    // 
  iVar1 = closesocket(socket);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int sendto(int socket, void *buf, int len, int flags, void *to, int tolen)

int sendto(int socket,void *buf,int len,int flags,void *to,int tolen)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a166. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Sends data to a specific destination using a socket.
                    // 
                    // Parameters:
                    //   socket: The socket descriptor.
                    //   buf: A pointer to the buffer containing the data to send.
                    //   len: The length of the data in the buffer.
                    //   flags: Specifies the way in which the call is made.
                    //   to: A pointer to a sockaddr structure containing the address of the target
                    // socket.
                    //   tolen: The size of the sockaddr structure.
                    // 
                    // Return values:
                    //   The number of bytes sent, or SOCKET_ERROR on error.
                    // 
  iVar1 = sendto(socket,buf,len,flags,to,tolen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int bind(int socket, void *addr, int addrlen)

int bind(int socket,void *addr,int addrlen)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a16c. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Associates a local address with a socket.
                    // 
                    // Parameters:
                    //   socket: The socket descriptor.
                    //   addr: A pointer to a sockaddr structure containing the local address to
                    // bind.
                    //   addrlen: The size of the sockaddr structure.
                    // 
                    // Return values:
                    //   0 if successful, or SOCKET_ERROR on error.
                    // 
  iVar1 = bind(socket,addr,addrlen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: uint16_t htons(uint16_t hostshort)

uint16_t htons(uint16_t hostshort)

{
  uint16_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a172. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Converts a u_short from host byte order to TCP/IP network byte order
                    // (big-endian).
                    // 
                    // Parameters:
                    //   hostshort: The 16-bit number in host byte order.
                    // 
                    // Return values:
                    //   The 16-bit number in network byte order.
                    // 
  uVar1 = htons(hostshort);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: uint32_t htonl(uint32_t hostlong)

uint32_t htonl(uint32_t hostlong)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a178. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Converts a u_long from host byte order to TCP/IP network byte order
                    // (big-endian).
                    // 
                    // Parameters:
                    //   hostlong: The 32-bit number in host byte order.
                    // 
                    // Return values:
                    //   The 32-bit number in network byte order.
                    // 
  uVar1 = htonl(hostlong);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int setsockopt(int socket, int level, int optname, void *optval, int optlen)

int setsockopt(int socket,int level,int optname,void *optval,int optlen)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a17e. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Sets a socket option.
                    // 
                    // Parameters:
                    //   socket: The socket descriptor.
                    //   level: The level at which the option is defined (e.g., SOL_SOCKET).
                    //   optname: The socket option for which the value is to be set.
                    //   optval: A pointer to the buffer in which the value for the requested option
                    // is supplied.
                    //   optlen: The size of the optval buffer.
                    // 
                    // Return values:
                    //   0 if successful, or SOCKET_ERROR on error.
                    // 
  iVar1 = setsockopt(socket,level,optname,optval,optlen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int socket(int af, int type, int protocol)

int socket(int af,int type,int protocol)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x1001a184. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 
                    // Creates a socket.
                    // 
                    // Parameters:
                    //   af: The address family (e.g., AF_INET).
                    //   type: The type of socket (e.g., SOCK_STREAM, SOCK_DGRAM).
                    //   protocol: The protocol to be used (e.g., IPPROTO_TCP, IPPROTO_UDP).
                    // 
                    // Return values:
                    //   A socket descriptor if successful, or INVALID_SOCKET on error.
                    // 
  iVar1 = socket(af,type,protocol);
  return iVar1;
}



// Setting prototype: int fclose_wrapper(void *file_handle)

int __cdecl fclose_wrapper(void *file_handle)

{
  int result;
  
                    // 
                    // Wrapper function for fclose, handling stream locking.
                    // 
                    // Parameters:
                    //   file_handle: The file handle to close.
                    // 
                    // Return values:
                    //   0 if successful, or EOF on error.
                    // 
  result = -1;
  if ((*(byte *)((int)file_handle + 0xc) & 0x40) == 0) {
    lock_stream(file_handle);
    result = __fclose_lk((FILE *)file_handle);
    unlock_stream(file_handle);
  }
  else {
    *(undefined4 *)((int)file_handle + 0xc) = 0;
  }
  return result;
}



// Setting prototype: int __fclose_lk(FILE *file_ptr)

int __fclose_lk(FILE *file_ptr)

{
  int iVar1;
  int iVar2;
  
                    // 
                    // Closes a file, flushes its buffer, frees the buffer, and closes the file
                    // handle.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the FILE structure.
                    // 
                    // Return values:
                    //   0 if successful, or EOF on error.
                    // 
  iVar2 = -1;
  if ((file_ptr->_flag & 0x83) != 0) {
    iVar2 = file_flush_2(file_ptr);
    __freebuf(file_ptr);
    iVar1 = close_file_handle(file_ptr->_file);
    if (iVar1 < 0) {
      iVar2 = -1;
    }
    else if (file_ptr->_tmpfname != (char *)0x0) {
      free_memory(file_ptr->_tmpfname);
      file_ptr->_tmpfname = (char *)0x0;
    }
  }
  file_ptr->_flag = 0;
  return iVar2;
}



// Setting prototype: int write_string_to_file(char *str_to_write, FILE *file_ptr)

int __cdecl write_string_to_file(char *str_to_write,FILE *file_ptr)

{
  size_t len;
  uint32_t status;
  uint32_t uVar1;
  
                    // 
                    // Writes a string to a file.
                    // 
                    // Parameters:
                    //   str_to_write: The string to write.
                    //   file_ptr: Pointer to the FILE structure.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  len = _strlen(str_to_write);
  lock_stream(file_ptr);
  status = file_io(file_ptr);
  uVar1 = file_write_2(str_to_write,1,len,file_ptr);
  file_io_2(status,file_ptr);
  unlock_stream(file_ptr);
  return (uVar1 == len) - 1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int open_file(const char *filename, const char *mode, FILE **file_ptr)

undefined4 open_file(undefined4 filename,undefined4 mode,undefined4 file_ptr)

{
  FILE *file_handle;
  undefined4 uVar1;
  
                    // 
                    // Opens a file with the specified filename and mode.
                    // 
                    // Parameters:
                    //   filename: The name of the file to open.
                    //   mode: The file access mode (e.g., "r", "w", "a").
                    //   file_ptr: Pointer to a FILE pointer that will receive the opened file
                    // handle.
                    // 
                    // Return values:
                    //   0 if successful, or a non-zero value on error.
                    // 
  file_handle = acquire_stream_slot();
  if (file_handle == (FILE *)0x0) {
    return 0;
  }
  uVar1 = printf_internal(filename,mode,file_ptr,file_handle);
  unlock_stream(file_handle);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void open_file_wrapper(const char *filename, const char *mode)

void open_file_wrapper(undefined4 filename,undefined4 mode)

{
                    // 
                    // Wrapper function for open_file, with a fixed third parameter.
                    // 
                    // Parameters:
                    //   filename: The name of the file to open.
                    //   mode: The file access mode (e.g., "r", "w", "a").
                    // 
  open_file(filename,mode,0x40);
  return;
}



// Setting prototype: int printf_wrapper(char *buffer, const char *format, ...)

int __cdecl printf_wrapper(undefined1 *buffer,char *format,...)

{
  int result;
  undefined1 *buffer_ptr;
  int remaining;
  undefined1 *local_1c;
  undefined4 flags;
  
                    // 
                    // Wrapper function for printf, writing formatted output to a buffer.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the output buffer.
                    //   format: The format string.
                    //   ...: Variable arguments for formatting.
                    // 
                    // Return values:
                    //   The number of characters written, or a negative value on error.
                    // 
  local_1c = buffer;
  buffer_ptr = buffer;
  flags = 0x42;
  remaining = 0x7fffffff;
  result = printf_internal_4(&buffer_ptr,format,&stack0x0000000c);
  remaining = remaining + -1;
  if (remaining < 0) {
    printf_internal_3(0,&buffer_ptr);
  }
  else {
    *buffer_ptr = 0;
  }
  return result;
}



// Setting prototype: int get_file_size_wrapper(void *file_handle)

int __cdecl get_file_size_wrapper(void *file_handle)

{
  int size;
  
                    // 
                    // Wrapper function for get_file_size, handling stream locking.
                    // 
                    // Parameters:
                    //   file_handle: The file handle.
                    // 
                    // Return values:
                    //   The size of the file in bytes.
                    // 
  lock_stream(file_handle);
  size = get_file_size(file_handle);
  unlock_stream(file_handle);
  return size;
}



// Setting prototype: int get_file_size(void *file_handle)

int __cdecl get_file_size(void *file_handle)

{
  uint file_descriptor;
  uint uVar1;
  byte bVar2;
  undefined4 *puVar3;
  char *pcVar4;
  uint32_t uVar5;
  char *pcVar6;
  void *pvVar7;
  char *pcVar8;
  int iVar9;
  int local_c;
  uint32_t local_8;
  
                    // 
                    // Retrieves the size of a file.
                    // 
                    // Parameters:
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   The size of the file in bytes, or -1 on error.
                    // 
  pvVar7 = file_handle;
  file_descriptor = *(uint *)((int)file_handle + 0x10);
  if (*(int *)((int)file_handle + 4) < 0) {
    *(undefined4 *)((int)file_handle + 4) = 0;
  }
  local_8 = file_io_5(file_descriptor,0,1);
  if ((int)local_8 < 0) {
LAB_1001a39b:
    local_c = -1;
  }
  else {
    uVar1 = *(uint *)((int)file_handle + 0xc);
    if ((uVar1 & 0x108) == 0) {
      return local_8 - *(int *)((int)file_handle + 4);
    }
                    // WARNING: Load size is inaccurate
    pcVar4 = *file_handle;
    pcVar6 = *(char **)((int)file_handle + 8);
    local_c = (int)pcVar4 - (int)pcVar6;
    if ((uVar1 & 3) == 0) {
      if ((uVar1 & 0x80) == 0) {
        puVar3 = (undefined4 *)get_last_error();
        *puVar3 = 0x16;
        goto LAB_1001a39b;
      }
    }
    else {
      pcVar8 = pcVar6;
      if ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 +
                    (file_descriptor & 0x1f) * 0x24) & 0x80) != 0) {
        for (; pcVar8 < pcVar4; pcVar8 = pcVar8 + 1) {
          if (*pcVar8 == '\n') {
            local_c = local_c + 1;
          }
        }
      }
    }
    if (local_8 != 0) {
      if ((*(byte *)((int)file_handle + 0xc) & 1) != 0) {
        if (*(int *)((int)file_handle + 4) == 0) {
          local_c = 0;
        }
        else {
          pcVar4 = pcVar4 + (*(int *)((int)file_handle + 4) - (int)pcVar6);
          iVar9 = (file_descriptor & 0x1f) * 0x24;
          if ((*(byte *)(iVar9 + 4 + (&DAT_11766460)[(int)file_descriptor >> 5]) & 0x80) != 0) {
            uVar5 = file_io_5(file_descriptor,0,2);
            if (uVar5 == local_8) {
              pcVar6 = *(char **)((int)file_handle + 8);
              pcVar8 = pcVar4 + (int)pcVar6;
              file_handle = pcVar4;
              for (; pcVar6 < pcVar8; pcVar6 = pcVar6 + 1) {
                if (*pcVar6 == '\n') {
                  file_handle = (void *)((int)file_handle + 1);
                }
              }
              bVar2 = *(byte *)((int)pvVar7 + 0xd) & 0x20;
            }
            else {
              file_io_5(file_descriptor,local_8,0);
              pvVar7 = (void *)0x200;
              if ((((char *)0x200 < pcVar4) || ((*(uint *)((int)file_handle + 0xc) & 8) == 0)) ||
                 ((*(uint *)((int)file_handle + 0xc) & 0x400) != 0)) {
                pvVar7 = *(void **)((int)file_handle + 0x18);
              }
              bVar2 = *(byte *)(iVar9 + 4 + (&DAT_11766460)[(int)file_descriptor >> 5]) & 4;
              file_handle = pvVar7;
            }
            pcVar4 = (char *)file_handle;
            if (bVar2 != 0) {
              pcVar4 = (char *)((int)file_handle + 1);
            }
          }
          file_handle = pcVar4;
          local_8 = local_8 - (int)file_handle;
        }
      }
      local_c = local_c + local_8;
    }
  }
  return local_c;
}



// Setting prototype: int file_seek(void *file_handle, int offset, int origin)

int __cdecl file_seek(void *file_handle,int offset,int origin)

{
  int iVar1;
  
                    // 
                    // Sets the file position indicator for the stream pointed to by file_handle.
                    // 
                    // Parameters:
                    //   file_handle: The file handle.
                    //   offset: The offset from the origin.
                    //   origin: The starting position for the offset (e.g., SEEK_SET, SEEK_CUR,
                    // SEEK_END).
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  lock_stream(file_handle);
  iVar1 = file_seek_2(file_handle,offset,origin);
  unlock_stream(file_handle);
  return iVar1;
}



// Setting prototype: int file_seek_2(void *file_handle, int offset, int origin)

int __cdecl file_seek_2(void *file_handle,int offset,int origin)

{
  uint uVar1;
  int iVar2;
  uint32_t uVar3;
  undefined4 *puVar4;
  
                    // 
                    // Sets the file position indicator for the stream pointed to by file_handle.
                    // 
                    // Parameters:
                    //   file_handle: The file handle.
                    //   offset: The offset from the origin.
                    //   origin: The starting position for the offset (e.g., SEEK_SET, SEEK_CUR,
                    // SEEK_END).
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  if (((*(uint *)((int)file_handle + 0xc) & 0x83) == 0) ||
     (((origin != 0 && (origin != 1)) && (origin != 2)))) {
    puVar4 = (undefined4 *)get_last_error();
    *puVar4 = 0x16;
    iVar2 = -1;
  }
  else {
    *(uint *)((int)file_handle + 0xc) = *(uint *)((int)file_handle + 0xc) & 0xffffffef;
    if (origin == 1) {
      iVar2 = get_file_size(file_handle);
      offset = offset + iVar2;
      origin = 0;
    }
    file_flush_2(file_handle);
    uVar1 = *(uint *)((int)file_handle + 0xc);
    if ((uVar1 & 0x80) == 0) {
      if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
        *(undefined4 *)((int)file_handle + 0x18) = 0x200;
      }
    }
    else {
      *(uint *)((int)file_handle + 0xc) = uVar1 & 0xfffffffc;
    }
    uVar3 = file_io_5(*(uint32_t *)((int)file_handle + 0x10),offset,origin);
    iVar2 = (uVar3 != 0xffffffff) - 1;
  }
  return iVar2;
}



// Setting prototype: uint32_t get_current_time(void *time_ptr)

uint32_t __cdecl get_current_time(void *time_ptr)

{
  int iVar1;
  uint32_t uVar2;
  
                    // 
                    // Retrieves the current time and formats it.
                    // 
                    // Parameters:
                    //   time_ptr: Pointer to a structure to store the time information.
                    // 
                    // Return values:
                    //   The formatted time string, or 0 on error.
                    // 
  iVar1 = time_to_tm(time_ptr);
  if (iVar1 != 0) {
    uVar2 = format_datetime(iVar1);
    return uVar2;
  }
  return 0;
}



// Setting prototype: char *strrchr(char *str, int character)

char * __cdecl _strrchr(char *str,int character)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  
                    // 
                    // Finds the last occurrence of a character in a string.
                    // 
                    // Parameters:
                    //   str: The string to search.
                    //   character: The character to search for.
                    // 
                    // Return values:
                    //   A pointer to the last occurrence of the character in the string, or NULL if
                    // not found.
                    // 
  iVar2 = -1;
  do {
    pcVar4 = str;
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    pcVar4 = str + 1;
    cVar1 = *str;
    str = pcVar4;
  } while (cVar1 != '\0');
  iVar2 = -(iVar2 + 1);
  pcVar4 = pcVar4 + -1;
  do {
    pcVar3 = pcVar4;
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    pcVar3 = pcVar4 + -1;
    cVar1 = *pcVar4;
    pcVar4 = pcVar3;
  } while ((char)character != cVar1);
  pcVar3 = pcVar3 + 1;
  if (*pcVar3 != (char)character) {
    pcVar3 = (char *)0x0;
  }
  return pcVar3;
}



// Setting prototype: void get_local_time(uint32_t *time_ptr)

void __cdecl get_local_time(uint32_t *time_ptr)

{
  DWORD DVar1;
  uint32_t uVar2;
  _TIME_ZONE_INFORMATION local_d0;
  _SYSTEMTIME local_24;
  _SYSTEMTIME local_14;
  
                    // 
                    // Retrieves the current local time and converts it to a time_t equivalent.
                    // 
                    // Parameters:
                    //   time_ptr: Pointer to a buffer to store the time_t value.
                    // 
  GetLocalTime(&local_14);
  GetSystemTime(&local_24);
  if (local_24.wMinute == DAT_100354a8._2_2_) {
    if (local_24.wHour == (WORD)DAT_100354a8) {
      if (local_24.wDay == DAT_100354a4._2_2_) {
        if (local_24.wMonth == DAT_100354a0._2_2_) {
          if (local_24.wYear == (WORD)DAT_100354a0) goto LAB_1001a611;
        }
      }
    }
  }
  DVar1 = GetTimeZoneInformation(&local_d0);
  if (DVar1 == 0xffffffff) {
    DAT_10035498 = -1;
  }
  else if (((DVar1 == 2) && (local_d0.DaylightDate.wMonth != 0)) && (local_d0.DaylightBias != 0)) {
    DAT_10035498 = 1;
  }
  else {
    DAT_10035498 = 0;
  }
  DAT_100354a0._0_2_ = local_24.wYear;
  DAT_100354a0._2_2_ = local_24.wMonth;
  DAT_100354a4._0_2_ = local_24.wDayOfWeek;
  DAT_100354a4._2_2_ = local_24.wDay;
  DAT_100354a8._0_2_ = local_24.wHour;
  DAT_100354a8._2_2_ = local_24.wMinute;
  DAT_100354ac._0_2_ = local_24.wSecond;
  DAT_100354ac._2_2_ = local_24.wMilliseconds;
LAB_1001a611:
  uVar2 = tm_to_time((uint)local_14.wYear,(uint)local_14.wMonth,(uint)local_14.wDay,
                     (uint)local_14.wHour,(uint)local_14.wMinute,(uint)local_14.wSecond,DAT_10035498
                    );
  if (time_ptr != (uint32_t *)0x0) {
    *time_ptr = uVar2;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void exit_program(void)

void exit_program(void)

{
                    // 
                    // Exits the program, performing necessary cleanup and shutdown operations.
                    // 
  if (PTR_crt_startup_100317d8 != (undefined *)0x0) {
    (*(code *)PTR_crt_startup_100317d8)();
  }
  exit_program_7((void **)&DAT_10027008,(void **)&DAT_10027014);
  exit_program_7((void **)&DAT_10027000,(void **)&DAT_10027004);
  return;
}



// Setting prototype: void exit_program_2(uint32_t exit_code)

void __cdecl exit_program_2(uint32_t exit_code)

{
                    // 
                    // Exits the program with a specified exit code.
                    // 
                    // Parameters:
                    //   exit_code: The exit code to use.
                    // 
  exit_program_4(exit_code,0,0);
  return;
}



// Setting prototype: void __exit(int exit_code)

void __cdecl __exit(int exit_code)

{
                    // 
                    // Exits the program with a specified exit code.
                    // 
                    // Parameters:
                    //   exit_code: The exit code to use.
                    // 
  exit_program_4(exit_code,1,0);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void exit_program_3(void)

void exit_program_3(void)

{
                    // 
                    // Exits the program with a default exit code and specific flags.
                    // 
  exit_program_4(0,0,1);
  return;
}



// Setting prototype: void exit_program_4(uint32_t exit_code, int quick_exit, int quiet_mode)

void __cdecl exit_program_4(uint32_t exit_code,int quick_exit,int quiet_mode)

{
  HANDLE hProcess;
  undefined4 *puVar1;
  uint32_t uExitCode;
  
                    // 
                    // Exits the program with a specified exit code and options for quick or quiet
                    // exit.
                    // 
                    // Parameters:
                    //   exit_code: The exit code to use.
                    //   quick_exit: If non-zero, performs a quick exit without calling atexit
                    // functions.
                    //   quiet_mode: If non-zero, suppresses certain exit messages.
                    // 
  exit_program_5();
  if (DAT_100354f0 == 1) {
    uExitCode = exit_code;
    hProcess = GetCurrentProcess();
    TerminateProcess(hProcess,uExitCode);
  }
  g_remainingExitRefs = 1;
  DAT_100354e8 = (undefined1)quiet_mode;
  if (quick_exit == 0) {
    if ((DAT_11767598 != (undefined4 *)0x0) &&
       (puVar1 = (undefined4 *)(DAT_11767594 - 4), DAT_11767598 <= puVar1)) {
      do {
        if ((code *)*puVar1 != (code *)0x0) {
          (*(code *)*puVar1)();
        }
        puVar1 = puVar1 + -1;
      } while (DAT_11767598 <= puVar1);
    }
    exit_program_7((void **)&DAT_10027018,(void **)&DAT_10027020);
  }
  exit_program_7((void **)&DAT_10027024,(void **)&DAT_10027028);
  if (quiet_mode == 0) {
    DAT_100354f0 = 1;
                    // WARNING: Subroutine does not return
    ExitProcess(exit_code);
  }
  exit_program_6();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void exit_program_5(void)

void exit_program_5(void)

{
                    // 
                    // Performs initial steps for program exit, including resource locking.
                    // 
  lock_resource(0xd);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void exit_program_6(void)

void exit_program_6(void)

{
                    // 
                    // Performs final steps for program exit, including resource unlocking.
                    // 
  unlock_resource(0xd);
  return;
}



// Setting prototype: void exit_program_7(void **start_ptr, void **end_ptr)

void __cdecl exit_program_7(void **start_ptr,void **end_ptr)

{
  for (; start_ptr < end_ptr; start_ptr = start_ptr + 1) {
    if ((code *)*start_ptr != (code *)0x0) {
      (*(code *)*start_ptr)();
    }
  }
  return;
}



// Setting prototype: void get_error_code(uint32_t input_error_code)

void __cdecl get_error_code(uint32_t input_error_code)

{
  uint32_t *puVar1;
  undefined4 *puVar2;
  int iVar3;
  
                    // 
                    // Retrieves a mapped error code based on the input error code.
                    // 
                    // Parameters:
                    //   input_error_code: The input error code.
                    // 
  puVar1 = (uint32_t *)get_last_error_2();
  iVar3 = 0;
  *puVar1 = input_error_code;
  puVar1 = &DAT_10031660;
  do {
    if (input_error_code == *puVar1) {
      puVar2 = (undefined4 *)get_last_error();
      *puVar2 = (&DAT_10031664)[iVar3 * 2];
      return;
    }
    puVar1 = puVar1 + 2;
    iVar3 = iVar3 + 1;
  } while ((int)puVar1 < 0x100317c8);
  if ((0x12 < input_error_code) && (input_error_code < 0x25)) {
    puVar2 = (undefined4 *)get_last_error();
    *puVar2 = 0xd;
    return;
  }
  if ((0xbb < input_error_code) && (input_error_code < 0xcb)) {
    puVar2 = (undefined4 *)get_last_error();
    *puVar2 = 8;
    return;
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 0x16;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int get_last_error(void)

int get_last_error(void)

{
  int iVar1;
  
                    // 
                    // Retrieves the last error code from thread-local storage.
                    // 
                    // Return values:
                    //   The last error code.
                    // 
  iVar1 = get_tls_block();
  return iVar1 + 8;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int get_last_error_2(void)

int get_last_error_2(void)

{
  int iVar1;
  
                    // 
                    // Retrieves the last error code from thread-local storage.
                    // 
                    // Return values:
                    //   The last error code.
                    // 
  iVar1 = get_tls_block();
  return iVar1 + 0xc;
}



// Setting prototype: void *_malloc(size_t size)

void * __cdecl _malloc(size_t size)

{
  void *pvVar1;
  
                    // 
                    // Allocates a block of memory.
                    // 
                    // Parameters:
                    //   size: The number of bytes to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL if allocation fails.
                    // 
  pvVar1 = __nh_malloc(size,DAT_1003559c);
  return pvVar1;
}



// Setting prototype: void *__nh_malloc(size_t size, int nh_flag)

void * __cdecl __nh_malloc(size_t size,int nh_flag)

{
  void *in_EAX;
  
                    // 
                    // Allocates a block of memory, with optional new handler invocation.
                    // 
                    // Parameters:
                    //   size: The number of bytes to allocate.
                    //   nh_flag: If non-zero, the new handler is called on allocation failure.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL if allocation fails.
                    // 
  if (size < 0xffffffe1) {
    do {
      malloc_internal(size);
      if (in_EAX != (void *)0x0) {
        return in_EAX;
      }
      if (nh_flag == 0) {
        return (void *)0x0;
      }
      in_EAX = (void *)new_handler(size);
    } while (in_EAX != (void *)0x0);
  }
  return (void *)0x0;
}



// Setting prototype: void *malloc_internal(uint32_t num_bytes)

void __cdecl malloc_internal(uint num_bytes)

{
  int iVar1;
  uint dwBytes;
  void *local_14;
  undefined1 *puStack_10;
  undefined *puStack_c;
  undefined4 local_8;
  
                    // 
                    // Internal memory allocation function.
                    // 
                    // Parameters:
                    //   num_bytes: The number of bytes to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL if allocation fails.
                    // 
  local_8 = 0xffffffff;
  puStack_c = &DAT_10025fc0;
  puStack_10 = &LAB_1001e7dc;
  local_14 = ExceptionList;
  if (DAT_11766450 == 3) {
    ExceptionList = &local_14;
    if (num_bytes <= DAT_11766448) {
      ExceptionList = &local_14;
      lock_resource(9);
      local_8 = 0;
      iVar1 = heap_management_9(num_bytes);
      local_8 = 0xffffffff;
      malloc_internal_2();
      if (iVar1 != 0) {
        ExceptionList = local_14;
        return;
      }
    }
  }
  else {
    ExceptionList = &local_14;
    if (DAT_11766450 == 2) {
      if (num_bytes == 0) {
        dwBytes = 0x10;
      }
      else {
        dwBytes = num_bytes + 0xf & 0xfffffff0;
      }
      ExceptionList = &local_14;
      if (dwBytes <= DAT_10033b9c) {
        ExceptionList = &local_14;
        lock_resource(9);
        local_8 = 1;
        iVar1 = heap_management_18(dwBytes >> 4);
        local_8 = 0xffffffff;
        malloc_internal_3();
        if (iVar1 != 0) {
          ExceptionList = local_14;
          return;
        }
      }
      goto LAB_1001a914;
    }
  }
  if (num_bytes == 0) {
    num_bytes = 1;
  }
  dwBytes = num_bytes + 0xf & 0xfffffff0;
LAB_1001a914:
  HeapAlloc(DAT_1176644c,0,dwBytes);
  ExceptionList = local_14;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void malloc_internal_2(void)

void malloc_internal_2(void)

{
                    // 
                    // Internal function for memory allocation, likely unlocks a resource.
                    // 
  unlock_resource(9);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void malloc_internal_3(void)

void malloc_internal_3(void)

{
                    // 
                    // Internal function for memory allocation, likely unlocks a resource.
                    // 
  unlock_resource(9);
  return;
}



// Setting prototype: uint32_t file_write(void *buffer, uint32_t element_size, uint32_t
// element_count, void *file_handle)

uint32_t __cdecl
file_write(void *buffer,uint32_t element_size,uint32_t element_count,void *file_handle)

{
  uint32_t uVar1;
  
                    // 
                    // Writes data to a file, handling stream locking.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the buffer containing the data to write.
                    //   element_size: The size of each element to write.
                    //   element_count: The number of elements to write.
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   The number of elements written.
                    // 
  lock_stream(file_handle);
  uVar1 = file_write_2(buffer,element_size,element_count,file_handle);
  unlock_stream(file_handle);
  return uVar1;
}



// Setting prototype: uint32_t file_write_2(void *buffer, uint32_t element_size, uint32_t
// element_count, void *file_handle)

uint32_t __cdecl
file_write_2(void *buffer,uint32_t element_size,uint32_t element_count,void *file_handle)

{
  void *file_ptr;
  int iVar1;
  void *pvVar2;
  uint32_t uVar3;
  uint uVar4;
  void *pvVar5;
  void *pvVar6;
  void *pvVar7;
  
                    // 
                    // Writes data to a file.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the buffer containing the data to write.
                    //   element_size: The size of each element to write.
                    //   element_count: The number of elements to write.
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   The number of elements written.
                    // 
  file_ptr = file_handle;
  pvVar6 = (void *)(element_size * element_count);
  if (pvVar6 == (void *)0x0) {
    element_count = 0;
  }
  else {
    pvVar5 = pvVar6;
    if ((*(ushort *)((int)file_handle + 0xc) & 0x10c) == 0) {
      file_handle = (void *)0x1000;
    }
    else {
      file_handle = *(void **)((int)file_handle + 0x18);
    }
    do {
      uVar4 = *(uint *)((int)file_ptr + 0xc) & 0x108;
      if ((uVar4 == 0) || (pvVar7 = *(void **)((int)file_ptr + 4), pvVar7 == (void *)0x0)) {
        if (file_handle <= pvVar5) {
          if ((uVar4 != 0) && (iVar1 = file_flush_2(file_ptr), iVar1 != 0)) {
LAB_1001aa61:
            return (uint)((int)pvVar6 - (int)pvVar5) / element_size;
          }
          pvVar7 = pvVar5;
          if (file_handle != (void *)0x0) {
            pvVar7 = (void *)((int)pvVar5 - (uint)pvVar5 % (uint)file_handle);
          }
          pvVar2 = (void *)file_write_11(*(uint32_t *)((int)file_ptr + 0x10),buffer,(uint32_t)pvVar7
                                        );
          if ((pvVar2 == (void *)0xffffffff) ||
             (pvVar5 = (void *)((int)pvVar5 - (int)pvVar2), pvVar2 < pvVar7)) {
            *(uint *)((int)file_ptr + 0xc) = *(uint *)((int)file_ptr + 0xc) | 0x20;
            goto LAB_1001aa61;
          }
          goto LAB_1001aa18;
        }
                    // WARNING: Load size is inaccurate
        uVar3 = printf_internal_3((int)*buffer,file_ptr);
        if (uVar3 == 0xffffffff) goto LAB_1001aa61;
        buffer = (void *)((int)buffer + 1);
        file_handle = *(void **)((int)file_ptr + 0x18);
        pvVar5 = (void *)((int)pvVar5 - 1);
        if ((int)file_handle < 1) {
          file_handle = (void *)0x1;
        }
      }
      else {
        pvVar2 = pvVar5;
        if (pvVar7 <= pvVar5) {
          pvVar2 = pvVar7;
        }
                    // WARNING: Load size is inaccurate
        memcpy_internal_6(*file_ptr,buffer,pvVar2);
        *(int *)((int)file_ptr + 4) = *(int *)((int)file_ptr + 4) - (int)pvVar2;
                    // WARNING: Load size is inaccurate
        *(int *)file_ptr = *file_ptr + (int)pvVar2;
        pvVar5 = (void *)((int)pvVar5 - (int)pvVar2);
LAB_1001aa18:
        buffer = (void *)((int)buffer + (int)pvVar2);
      }
    } while (pvVar5 != (void *)0x0);
  }
  return element_count;
}



// Setting prototype: uint32_t file_read_3(void *buffer, uint32_t element_size, uint32_t
// element_count, void *file_handle)

uint32_t __cdecl
file_read_3(void *buffer,uint32_t element_size,uint32_t element_count,void *file_handle)

{
  uint32_t uVar1;
  
                    // 
                    // Reads data from a file, handling stream locking.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the destination buffer.
                    //   element_size: The size of each element to read.
                    //   element_count: The number of elements to read.
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   The number of elements read.
                    // 
  lock_stream(file_handle);
  uVar1 = file_read_4(buffer,element_size,element_count,file_handle);
  unlock_stream(file_handle);
  return uVar1;
}



// Setting prototype: uint32_t file_read_4(void *buffer, uint32_t element_size, uint32_t
// element_count, void *file_handle)

uint32_t __cdecl
file_read_4(void *buffer,uint32_t element_size,uint32_t element_count,void *file_handle)

{
  void *file_ptr;
  void *pvVar1;
  uint32_t uVar2;
  undefined1 *puVar3;
  void *pvVar4;
  void *pvVar5;
  
                    // 
                    // Reads data from a file.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the destination buffer.
                    //   element_size: The size of each element to read.
                    //   element_count: The number of elements to read.
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   The number of elements read.
                    // 
  file_ptr = file_handle;
  pvVar4 = (void *)(element_size * element_count);
  if (pvVar4 == (void *)0x0) {
    element_count = 0;
  }
  else {
    puVar3 = (undefined1 *)buffer;
    buffer = pvVar4;
    if ((*(ushort *)((int)file_handle + 0xc) & 0x10c) == 0) {
      file_handle = (void *)0x1000;
    }
    else {
      file_handle = *(void **)((int)file_handle + 0x18);
    }
    do {
      if (((*(ushort *)((int)file_ptr + 0xc) & 0x10c) == 0) ||
         (pvVar1 = *(void **)((int)file_ptr + 4), pvVar1 == (void *)0x0)) {
        if (buffer < file_handle) {
          uVar2 = file_io_15(file_ptr);
          if (uVar2 == 0xffffffff) goto LAB_1001ab75;
          *puVar3 = (char)uVar2;
          file_handle = *(void **)((int)file_ptr + 0x18);
          puVar3 = puVar3 + 1;
          buffer = (void *)((int)buffer + -1);
        }
        else {
          pvVar1 = buffer;
          if (file_handle != (void *)0x0) {
            pvVar1 = (void *)((int)buffer - (uint)buffer % (uint)file_handle);
          }
          uVar2 = file_io_16(*(uint32_t *)((int)file_ptr + 0x10),puVar3,(uint32_t)pvVar1);
          if (uVar2 == 0) {
            *(uint *)((int)file_ptr + 0xc) = *(uint *)((int)file_ptr + 0xc) | 0x10;
LAB_1001ab75:
            return (uint)((int)pvVar4 - (int)buffer) / element_size;
          }
          if (uVar2 == 0xffffffff) {
            *(uint *)((int)file_ptr + 0xc) = *(uint *)((int)file_ptr + 0xc) | 0x20;
            goto LAB_1001ab75;
          }
          buffer = (void *)((int)buffer - uVar2);
          puVar3 = puVar3 + uVar2;
        }
      }
      else {
        pvVar5 = buffer;
        if (pvVar1 <= buffer) {
          pvVar5 = pvVar1;
        }
                    // WARNING: Load size is inaccurate
        memcpy_internal_6(puVar3,*file_ptr,pvVar5);
        buffer = (void *)((int)buffer - (int)pvVar5);
        *(int *)((int)file_ptr + 4) = *(int *)((int)file_ptr + 4) - (int)pvVar5;
                    // WARNING: Load size is inaccurate
        *(int *)file_ptr = *file_ptr + (int)pvVar5;
        puVar3 = puVar3 + (int)pvVar5;
      }
    } while (buffer != (void *)0x0);
  }
  return element_count;
}



// Setting prototype: void free_memory(void *ptr)

void __cdecl free_memory(void *ptr)

{
  void *pvVar1;
  void *local_2c;
  void *local_28;
  uint32_t local_24;
  void *local_20;
  void *local_14;
  undefined1 *puStack_10;
  undefined *puStack_c;
  undefined4 local_8;
  
                    // 
                    // Frees a block of memory.
                    // 
                    // Parameters:
                    //   ptr: A pointer to the memory block to free.
                    // 
  local_8 = 0xffffffff;
  puStack_c = &DAT_10025fd8;
  puStack_10 = &LAB_1001e7dc;
  local_14 = ExceptionList;
  if (ptr == (void *)0x0) {
    return;
  }
  if (DAT_11766450 == 3) {
    ExceptionList = &local_14;
    lock_resource(9);
    local_8 = 0;
    local_20 = (void *)heap_management_3((uint32_t)ptr);
    if (local_20 != (void *)0x0) {
      heap_management_4(local_20,ptr);
    }
    local_8 = 0xffffffff;
    memory_management();
    pvVar1 = local_20;
  }
  else {
    ExceptionList = &local_14;
    if (DAT_11766450 != 2) goto LAB_1001ac4d;
    ExceptionList = &local_14;
    lock_resource(9);
    local_8 = 1;
    local_28 = (void *)heap_management_16(ptr,&local_2c,&local_24);
    if (local_28 != (void *)0x0) {
      heap_management_17(local_2c,local_24,local_28);
    }
    local_8 = 0xffffffff;
    memory_management_2();
    pvVar1 = local_28;
  }
  if (pvVar1 != (void *)0x0) {
    ExceptionList = local_14;
    return;
  }
LAB_1001ac4d:
  HeapFree(DAT_1176644c,0,ptr);
  ExceptionList = local_14;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void memory_management(void)

void memory_management(void)

{
                    // 
                    // Manages memory, likely by unlocking a resource.
                    // 
  unlock_resource(9);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void memory_management_2(void)

void memory_management_2(void)

{
                    // 
                    // Manages memory, likely by unlocking a resource.
                    // 
  unlock_resource(9);
  return;
}



// WARNING: Unable to track spacebase fully for stack
// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void memory_management_3(void)

void memory_management_3(void)

{
  uint in_EAX;
  undefined1 *puVar1;
  undefined4 unaff_retaddr;
  
                    // 
                    // Manages memory, possibly related to stack unwinding or exception handling.
                    // 
  puVar1 = &stack0x00000004;
  if (0xfff < in_EAX) {
    do {
      puVar1 = puVar1 + -0x1000;
      in_EAX = in_EAX - 0x1000;
    } while (0xfff < in_EAX);
  }
  *(undefined4 *)(puVar1 + (-4 - in_EAX)) = unaff_retaddr;
  return;
}



// Setting prototype: int file_flush(void *file_handle)

int __cdecl file_flush(void *file_handle)

{
  int iVar1;
  uint32_t uVar2;
  
                    // 
                    // Flushes the buffer of a file to disk.
                    // 
                    // Parameters:
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  iVar1 = file_flush_2(file_handle);
  if (iVar1 != 0) {
    return -1;
  }
  if ((*(byte *)((int)file_handle + 0xd) & 0x40) != 0) {
    uVar2 = file_io_22(*(uint32_t *)((int)file_handle + 0x10));
    return -(uint)(uVar2 != 0);
  }
  return 0;
}



// Setting prototype: int file_flush_2(void *file_handle)

int file_flush_2(void *file_handle)

{
  uint32_t uVar1;
  int iVar2;
  uint32_t count;
  
                    // 
                    // Flushes the buffer of a file to disk.
                    // 
                    // Parameters:
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  iVar2 = 0;
  if ((((byte)*(uint *)((int)file_handle + 0xc) & 3) == 2) &&
     ((*(uint *)((int)file_handle + 0xc) & 0x108) != 0)) {
                    // WARNING: Load size is inaccurate
    count = *file_handle - (int)*(void **)((int)file_handle + 8);
    if (0 < (int)count) {
      uVar1 = file_write_11(*(uint32_t *)((int)file_handle + 0x10),*(void **)((int)file_handle + 8),
                            count);
      if (uVar1 == count) {
        if ((*(uint *)((int)file_handle + 0xc) & 0x80) != 0) {
          *(uint *)((int)file_handle + 0xc) = *(uint *)((int)file_handle + 0xc) & 0xfffffffd;
        }
      }
      else {
        *(uint *)((int)file_handle + 0xc) = *(uint *)((int)file_handle + 0xc) | 0x20;
        iVar2 = -1;
      }
    }
  }
  *(undefined4 *)((int)file_handle + 4) = 0;
  *(undefined4 *)file_handle = *(undefined4 *)((int)file_handle + 8);
  return iVar2;
}



// Setting prototype: int file_management(int operation_type)

int file_management(int operation_type)

{
  void *pvVar1;
  int iVar2;
  int iVar3;
  int stream_id;
  int iVar4;
  
                    // 
                    // Manages file operations, such as flushing buffers for all open files.
                    // 
                    // Parameters:
                    //   operation_type: The type of operation to perform (e.g., 0 for flush, 1 for
                    // close).
                    // 
                    // Return values:
                    //   The number of successful operations, or -1 on error.
                    // 
  iVar3 = 0;
  iVar4 = 0;
  lock_resource(2);
  stream_id = 0;
  if (0 < g_max_streams) {
    do {
      pvVar1 = *(void **)(g_stream_table + stream_id * 4);
      if ((pvVar1 != (void *)0x0) && ((*(byte *)((int)pvVar1 + 0xc) & 0x83) != 0)) {
        lock_stream_2(stream_id,pvVar1);
        pvVar1 = *(void **)(g_stream_table + stream_id * 4);
        if ((*(uint *)((int)pvVar1 + 0xc) & 0x83) != 0) {
          if (operation_type == 1) {
            iVar2 = file_flush(pvVar1);
            if (iVar2 != -1) {
              iVar3 = iVar3 + 1;
            }
          }
          else if ((operation_type == 0) && ((*(uint *)((int)pvVar1 + 0xc) & 2) != 0)) {
            iVar2 = file_flush(pvVar1);
            if (iVar2 == -1) {
              iVar4 = -1;
            }
          }
        }
        unlock_stream_2(stream_id,*(void **)(g_stream_table + stream_id * 4));
      }
      stream_id = stream_id + 1;
    } while (stream_id < g_max_streams);
  }
  unlock_resource(2);
  if (operation_type != 1) {
    iVar3 = iVar4;
  }
  return iVar3;
}



// Setting prototype: uint32_t file_putc(uint32_t character, void *file_handle)

uint32_t file_putc(uint32_t character,void *file_handle)

{
  int *piVar1;
  uint32_t uVar2;
  
                    // 
                    // Writes a character to a file.
                    // 
                    // Parameters:
                    //   character: The character to write.
                    //   file_handle: Pointer to the file structure.
                    // 
                    // Return values:
                    //   The character written, or EOF on error.
                    // 
  lock_stream(file_handle);
  piVar1 = (int *)((int)file_handle + 4);
  *piVar1 = *piVar1 + -1;
  if (*piVar1 < 0) {
    uVar2 = printf_internal_3(character,file_handle);
  }
  else {
                    // WARNING: Load size is inaccurate
    uVar2 = character & 0xff;
    **file_handle = (undefined1)character;
                    // WARNING: Load size is inaccurate
    *(int *)file_handle = *file_handle + 1;
  }
  unlock_stream(file_handle);
  return uVar2;
}



// Setting prototype: char *strncpy(char *destination, const char *source, size_t count)

char * __cdecl _strncpy(char *destination,char *source,size_t count)

{
  uint uVar1;
  uint uVar2;
  char cVar3;
  uint uVar4;
  uint *puVar5;
  
                    // 
                    // Copies a specified number of characters from a source string to a destination
                    // string.
                    // 
                    // Parameters:
                    //   destination: Pointer to the destination buffer.
                    //   source: Pointer to the source string.
                    //   count: The maximum number of characters to copy.
                    // 
                    // Return values:
                    //   A pointer to the destination string.
                    // 
  if (count == 0) {
    return destination;
  }
  puVar5 = (uint *)destination;
  if (((uint)source & 3) != 0) {
    while( true ) {
      uVar4 = *(uint *)source;
      source = (char *)((int)source + 1);
      *(char *)puVar5 = (char)uVar4;
      puVar5 = (uint *)((int)puVar5 + 1);
      count = count - 1;
      if (count == 0) {
        return destination;
      }
      if ((char)uVar4 == '\0') break;
      if (((uint)source & 3) == 0) {
        uVar4 = count >> 2;
        goto joined_r0x1001ae5e;
      }
    }
    do {
      if (((uint)puVar5 & 3) == 0) {
        uVar4 = count >> 2;
        cVar3 = '\0';
        if (uVar4 == 0) goto LAB_1001ae9b;
        goto LAB_1001af09;
      }
      *(char *)puVar5 = '\0';
      puVar5 = (uint *)((int)puVar5 + 1);
      count = count - 1;
    } while (count != 0);
    return destination;
  }
  uVar4 = count >> 2;
  if (uVar4 != 0) {
    do {
      uVar1 = *(uint *)source;
      uVar2 = *(uint *)source;
      source = (char *)((int)source + 4);
      if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {
        if ((char)uVar2 == '\0') {
          *puVar5 = 0;
joined_r0x1001af05:
          while( true ) {
            uVar4 = uVar4 - 1;
            puVar5 = puVar5 + 1;
            if (uVar4 == 0) break;
LAB_1001af09:
            *puVar5 = 0;
          }
          cVar3 = '\0';
          count = count & 3;
          if (count != 0) goto LAB_1001ae9b;
          return destination;
        }
        if ((char)(uVar2 >> 8) == '\0') {
          *puVar5 = uVar2 & 0xff;
          goto joined_r0x1001af05;
        }
        if ((uVar2 & 0xff0000) == 0) {
          *puVar5 = uVar2 & 0xffff;
          goto joined_r0x1001af05;
        }
        if ((uVar2 & 0xff000000) == 0) {
          *puVar5 = uVar2;
          goto joined_r0x1001af05;
        }
      }
      *puVar5 = uVar2;
      puVar5 = puVar5 + 1;
      uVar4 = uVar4 - 1;
joined_r0x1001ae5e:
    } while (uVar4 != 0);
    count = count & 3;
    if (count == 0) {
      return destination;
    }
  }
  do {
    cVar3 = (char)*(uint *)source;
    source = (char *)((int)source + 1);
    *(char *)puVar5 = cVar3;
    puVar5 = (uint *)((int)puVar5 + 1);
    if (cVar3 == '\0') {
      while (count = count - 1, count != 0) {
LAB_1001ae9b:
        *(char *)puVar5 = cVar3;
        puVar5 = (uint *)((int)puVar5 + 1);
      }
      return destination;
    }
    count = count - 1;
  } while (count != 0);
  return destination;
}



// Setting prototype: char *strchr(char *str, int character)

char * __cdecl _strchr(char *str,int character)

{
  uint uVar1;
  char cVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  
                    // 
                    // Finds the first occurrence of a character in a string.
                    // 
                    // Parameters:
                    //   str: The string to search.
                    //   character: The character to search for.
                    // 
                    // Return values:
                    //   A pointer to the first occurrence of the character in the string, or NULL
                    // if not found.
                    // 
  uVar1 = (uint)str & 3;
  while (uVar1 != 0) {
    if ((char)*(uint *)str == (char)character) {
      return (char *)(uint *)str;
    }
    if ((char)*(uint *)str == '\0') {
      return (char *)0x0;
    }
    uVar1 = (uint)((int)str + 1) & 3;
    str = (char *)((int)str + 1);
  }
  while( true ) {
    while( true ) {
      uVar1 = *(uint *)str;
      uVar4 = uVar1 ^ CONCAT22(CONCAT11((char)character,(char)character),
                               CONCAT11((char)character,(char)character));
      uVar3 = uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff;
      puVar5 = (uint *)((int)str + 4);
      if (((uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff) & 0x81010100) != 0) break;
      str = (char *)puVar5;
      if ((uVar3 & 0x81010100) != 0) {
        if ((uVar3 & 0x1010100) != 0) {
          return (char *)0x0;
        }
        if ((uVar1 + 0x7efefeff & 0x80000000) == 0) {
          return (char *)0x0;
        }
      }
    }
    uVar1 = *(uint *)str;
    if ((char)uVar1 == (char)character) {
      return (char *)(uint *)str;
    }
    if ((char)uVar1 == '\0') {
      return (char *)0x0;
    }
    cVar2 = (char)(uVar1 >> 8);
    if (cVar2 == (char)character) {
      return (char *)((int)str + 1);
    }
    if (cVar2 == '\0') break;
    cVar2 = (char)(uVar1 >> 0x10);
    if (cVar2 == (char)character) {
      return (char *)((int)str + 2);
    }
    if (cVar2 == '\0') {
      return (char *)0x0;
    }
    cVar2 = (char)(uVar1 >> 0x18);
    if (cVar2 == (char)character) {
      return (char *)((int)str + 3);
    }
    str = (char *)puVar5;
    if (cVar2 == '\0') {
      return (char *)0x0;
    }
  }
  return (char *)0x0;
}



// Setting prototype: char *strstr(char *str, const char *substring)

char * __cdecl _strstr(char *str,char *substring)

{
  char *pcVar1;
  char *pcVar2;
  char cVar3;
  uint uVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;
  char *pcVar8;
  uint *puVar9;
  char *pcVar10;
  
                    // 
                    // Finds the first occurrence of a substring within a string.
                    // 
                    // Parameters:
                    //   str: The string to search.
                    //   substring: The substring to search for.
                    // 
                    // Return values:
                    //   A pointer to the first occurrence of the substring in the string, or NULL
                    // if not found.
                    // 
  cVar3 = *substring;
  if (cVar3 == '\0') {
    return str;
  }
  if (substring[1] == '\0') {
    uVar4 = (uint)str & 3;
    while (uVar4 != 0) {
      if ((char)*(uint *)str == cVar3) {
        return (char *)(uint *)str;
      }
      if ((char)*(uint *)str == '\0') {
        return (char *)0x0;
      }
      uVar4 = (uint)((int)str + 1) & 3;
      str = (char *)((int)str + 1);
    }
    while( true ) {
      while( true ) {
        uVar4 = *(uint *)str;
        uVar7 = uVar4 ^ CONCAT22(CONCAT11(cVar3,cVar3),CONCAT11(cVar3,cVar3));
        uVar6 = uVar4 ^ 0xffffffff ^ uVar4 + 0x7efefeff;
        puVar9 = (uint *)((int)str + 4);
        if (((uVar7 ^ 0xffffffff ^ uVar7 + 0x7efefeff) & 0x81010100) != 0) break;
        str = (char *)puVar9;
        if ((uVar6 & 0x81010100) != 0) {
          if ((uVar6 & 0x1010100) != 0) {
            return (char *)0x0;
          }
          if ((uVar4 + 0x7efefeff & 0x80000000) == 0) {
            return (char *)0x0;
          }
        }
      }
      uVar4 = *(uint *)str;
      if ((char)uVar4 == cVar3) {
        return (char *)(uint *)str;
      }
      if ((char)uVar4 == '\0') {
        return (char *)0x0;
      }
      cVar5 = (char)(uVar4 >> 8);
      if (cVar5 == cVar3) {
        return (char *)((int)str + 1);
      }
      if (cVar5 == '\0') break;
      cVar5 = (char)(uVar4 >> 0x10);
      if (cVar5 == cVar3) {
        return (char *)((int)str + 2);
      }
      if (cVar5 == '\0') {
        return (char *)0x0;
      }
      cVar5 = (char)(uVar4 >> 0x18);
      if (cVar5 == cVar3) {
        return (char *)((int)str + 3);
      }
      str = (char *)puVar9;
      if (cVar5 == '\0') {
        return (char *)0x0;
      }
    }
    return (char *)0x0;
  }
  do {
    cVar5 = *str;
    do {
      while (str = str + 1, cVar5 != cVar3) {
        if (cVar5 == '\0') {
          return (char *)0x0;
        }
        cVar5 = *str;
      }
      cVar5 = *str;
      pcVar10 = str + 1;
      pcVar8 = substring;
    } while (cVar5 != substring[1]);
    do {
      if (pcVar8[2] == '\0') {
LAB_1001b063:
        return str + -1;
      }
      if (*pcVar10 != pcVar8[2]) break;
      pcVar1 = pcVar8 + 3;
      if (*pcVar1 == '\0') goto LAB_1001b063;
      pcVar2 = pcVar10 + 1;
      pcVar8 = pcVar8 + 2;
      pcVar10 = pcVar10 + 2;
    } while (*pcVar1 == *pcVar2);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_startup(void)

void crt_startup(void)

{
  undefined4 in_EAX;
  
                    // 
                    // Performs C runtime startup initialization.
                    // 
  crt_startup_2();
  crt_startup_12();
  _DAT_100354f8 = in_EAX;
  crt_startup_10();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_startup_2(void)

void crt_startup_2(void)

{
                    // 
                    // Performs C runtime startup initialization, setting up floating-point and
                    // string conversion functions.
                    // 
  PTR___fptrap_10033bb4 = &LAB_1001f265;
  PTR___fptrap_10033bb0 = __cfltcvt;
  PTR___fptrap_10033bb8 = __fassign;
  PTR___fptrap_10033bbc = str_to_float;
  PTR___fptrap_10033bc0 = &LAB_1001f2b3;
  PTR___fptrap_10033bc4 = __cfltcvt;
  return;
}



// Setting prototype: int char_to_upper(int character)

int char_to_upper(int character)

{
  bool bVar1;
  
                    // 
                    // Converts a character to its uppercase equivalent.
                    // 
                    // Parameters:
                    //   character: The character to convert.
                    // 
                    // Return values:
                    //   The uppercase equivalent of the character.
                    // 
  if (DAT_100355bc == 0) {
    if ((0x60 < character) && (character < 0x7b)) {
      return character + -0x20;
    }
  }
  else {
    InterlockedIncrement((LONG *)&DAT_1176642c);
    bVar1 = DAT_11766428 != 0;
    if (bVar1) {
      InterlockedDecrement((LONG *)&DAT_1176642c);
      lock_resource(0x13);
    }
    character = char_to_upper_2(character);
    if (bVar1) {
      unlock_resource(0x13);
    }
    else {
      InterlockedDecrement((LONG *)&DAT_1176642c);
    }
  }
  return character;
}



// Setting prototype: uint32_t char_to_upper_2(uint32_t character)

uint32_t char_to_upper_2(uint32_t character)

{
  uint uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  int iVar4;
  void *in_ECX;
  uint32_t unaff_EBX;
  undefined4 uVar5;
  void *local_8;
  
                    // 
                    // Converts a character to its uppercase equivalent, handling locale-specific
                    // conversions.
                    // 
                    // Parameters:
                    //   character: The character to convert.
                    // 
                    // Return values:
                    //   The uppercase equivalent of the character.
                    // 
  uVar2 = character;
  if (DAT_100355bc == 0) {
    if ((0x60 < (int)character) && ((int)character < 0x7b)) {
      uVar2 = character - 0x20;
    }
  }
  else {
    local_8 = in_ECX;
    if ((int)character < 0x100) {
      if (DAT_10033ee0 < 2) {
        uVar3 = (byte)PTR_DAT_10033cd4[character * 2] & 2;
      }
      else {
        uVar3 = get_char_property(in_ECX,character,2,unaff_EBX);
      }
      if (uVar3 == 0) {
        return uVar2;
      }
    }
    if ((PTR_DAT_10033cd4[((int)uVar2 >> 8 & 0xffU) * 2 + 1] & 0x80) == 0) {
      character = CONCAT31((int3)(character >> 8),(char)uVar2) & 0xffff00ff;
      uVar5 = 1;
    }
    else {
      uVar1 = character >> 0x10;
      character._0_2_ = CONCAT11((char)uVar2,(char)(uVar2 >> 8));
      character = CONCAT22((short)uVar1,(undefined2)character) & 0xff00ffff;
      uVar5 = 2;
    }
    iVar4 = string_map(DAT_100355bc,0x200,&character,uVar5,&local_8,3,0,1);
    if (iVar4 != 0) {
      if (iVar4 == 1) {
        uVar2 = (uint)local_8 & 0xff;
      }
      else {
        uVar2 = (uint)local_8 & 0xffff;
      }
    }
  }
  return uVar2;
}



// Setting prototype: void *memcpy_internal(void *destination, const void *source, size_t count)

undefined4 * memcpy_internal(undefined4 *destination,undefined4 *source,uint count)

{
  uint uVar1;
  undefined4 *puVar2;
  
                    // 
                    // Copies a specified number of bytes from a source memory area to a destination
                    // memory area.
                    // 
                    // Parameters:
                    //   destination: Pointer to the destination memory area.
                    //   source: Pointer to the source memory area.
                    //   count: The number of bytes to copy.
                    // 
                    // Return values:
                    //   A pointer to the destination memory area.
                    // 
  if ((source < destination) && (destination < (undefined4 *)(count + (int)source))) {
    source = (undefined4 *)((count - 4) + (int)source);
    puVar2 = (undefined4 *)((count - 4) + (int)destination);
    if (((uint)puVar2 & 3) == 0) {
      uVar1 = count >> 2;
      count = count & 3;
      if (7 < uVar1) {
        for (; uVar1 != 0; uVar1 = uVar1 - 1) {
          *puVar2 = *source;
          source = source + -1;
          puVar2 = puVar2 + -1;
        }
        switch(count) {
        case 0:
          return destination;
        case 2:
          goto switchD_1001b3b7_caseD_2;
        case 3:
          goto switchD_1001b3b7_caseD_3;
        }
        goto switchD_1001b3b7_caseD_1;
      }
    }
    else {
      switch(count) {
      case 0:
        goto switchD_1001b3b7_caseD_0;
      case 1:
        goto switchD_1001b3b7_caseD_1;
      case 2:
        goto switchD_1001b3b7_caseD_2;
      case 3:
        goto switchD_1001b3b7_caseD_3;
      default:
        uVar1 = count - ((uint)puVar2 & 3);
        switch((uint)puVar2 & 3) {
        case 1:
          count = uVar1 & 3;
          *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
          source = (undefined4 *)((int)source + -1);
          uVar1 = uVar1 >> 2;
          puVar2 = (undefined4 *)((int)puVar2 - 1);
          if (7 < uVar1) {
            for (; uVar1 != 0; uVar1 = uVar1 - 1) {
              *puVar2 = *source;
              source = source + -1;
              puVar2 = puVar2 + -1;
            }
            switch(count) {
            case 0:
              return destination;
            case 2:
              goto switchD_1001b3b7_caseD_2;
            case 3:
              goto switchD_1001b3b7_caseD_3;
            }
            goto switchD_1001b3b7_caseD_1;
          }
          break;
        case 2:
          count = uVar1 & 3;
          *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
          uVar1 = uVar1 >> 2;
          *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
          source = (undefined4 *)((int)source + -2);
          puVar2 = (undefined4 *)((int)puVar2 - 2);
          if (7 < uVar1) {
            for (; uVar1 != 0; uVar1 = uVar1 - 1) {
              *puVar2 = *source;
              source = source + -1;
              puVar2 = puVar2 + -1;
            }
            switch(count) {
            case 0:
              return destination;
            case 2:
              goto switchD_1001b3b7_caseD_2;
            case 3:
              goto switchD_1001b3b7_caseD_3;
            }
            goto switchD_1001b3b7_caseD_1;
          }
          break;
        case 3:
          count = uVar1 & 3;
          *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
          *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
          uVar1 = uVar1 >> 2;
          *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
          source = (undefined4 *)((int)source + -3);
          puVar2 = (undefined4 *)((int)puVar2 - 3);
          if (7 < uVar1) {
            for (; uVar1 != 0; uVar1 = uVar1 - 1) {
              *puVar2 = *source;
              source = source + -1;
              puVar2 = puVar2 + -1;
            }
            switch(count) {
            case 0:
              return destination;
            case 2:
              goto switchD_1001b3b7_caseD_2;
            case 3:
              goto switchD_1001b3b7_caseD_3;
            }
            goto switchD_1001b3b7_caseD_1;
          }
        }
      }
    }
    switch(uVar1) {
    case 7:
      puVar2[7 - uVar1] = source[7 - uVar1];
    case 6:
      puVar2[6 - uVar1] = source[6 - uVar1];
    case 5:
      puVar2[5 - uVar1] = source[5 - uVar1];
    case 4:
      puVar2[4 - uVar1] = source[4 - uVar1];
    case 3:
      puVar2[3 - uVar1] = source[3 - uVar1];
    case 2:
      puVar2[2 - uVar1] = source[2 - uVar1];
    case 1:
      puVar2[1 - uVar1] = source[1 - uVar1];
      source = source + -uVar1;
      puVar2 = puVar2 + -uVar1;
    }
    switch(count) {
    case 1:
switchD_1001b3b7_caseD_1:
      *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
      return destination;
    case 2:
switchD_1001b3b7_caseD_2:
      *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
      *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
      return destination;
    case 3:
switchD_1001b3b7_caseD_3:
      *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
      *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
      *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
      return destination;
    }
switchD_1001b3b7_caseD_0:
    return destination;
  }
  puVar2 = destination;
  if (((uint)destination & 3) == 0) {
    uVar1 = count >> 2;
    count = count & 3;
    if (7 < uVar1) {
      for (; uVar1 != 0; uVar1 = uVar1 - 1) {
        *puVar2 = *source;
        source = source + 1;
        puVar2 = puVar2 + 1;
      }
      switch(count) {
      case 0:
        return destination;
      case 2:
        goto switchD_1001b235_caseD_2;
      case 3:
        goto switchD_1001b235_caseD_3;
      }
      goto switchD_1001b235_caseD_1;
    }
  }
  else {
    switch(count) {
    case 0:
      goto switchD_1001b235_caseD_0;
    case 1:
      goto switchD_1001b235_caseD_1;
    case 2:
      goto switchD_1001b235_caseD_2;
    case 3:
      goto switchD_1001b235_caseD_3;
    default:
      uVar1 = (count - 4) + ((uint)destination & 3);
      switch((uint)destination & 3) {
      case 1:
        count = uVar1 & 3;
        *(undefined1 *)destination = *(undefined1 *)source;
        *(undefined1 *)((int)destination + 1) = *(undefined1 *)((int)source + 1);
        uVar1 = uVar1 >> 2;
        *(undefined1 *)((int)destination + 2) = *(undefined1 *)((int)source + 2);
        source = (undefined4 *)((int)source + 3);
        puVar2 = (undefined4 *)((int)destination + 3);
        if (7 < uVar1) {
          for (; uVar1 != 0; uVar1 = uVar1 - 1) {
            *puVar2 = *source;
            source = source + 1;
            puVar2 = puVar2 + 1;
          }
          switch(count) {
          case 0:
            return destination;
          case 2:
            goto switchD_1001b235_caseD_2;
          case 3:
            goto switchD_1001b235_caseD_3;
          }
          goto switchD_1001b235_caseD_1;
        }
        break;
      case 2:
        count = uVar1 & 3;
        *(undefined1 *)destination = *(undefined1 *)source;
        uVar1 = uVar1 >> 2;
        *(undefined1 *)((int)destination + 1) = *(undefined1 *)((int)source + 1);
        source = (undefined4 *)((int)source + 2);
        puVar2 = (undefined4 *)((int)destination + 2);
        if (7 < uVar1) {
          for (; uVar1 != 0; uVar1 = uVar1 - 1) {
            *puVar2 = *source;
            source = source + 1;
            puVar2 = puVar2 + 1;
          }
          switch(count) {
          case 0:
            return destination;
          case 2:
            goto switchD_1001b235_caseD_2;
          case 3:
            goto switchD_1001b235_caseD_3;
          }
          goto switchD_1001b235_caseD_1;
        }
        break;
      case 3:
        count = uVar1 & 3;
        *(undefined1 *)destination = *(undefined1 *)source;
        source = (undefined4 *)((int)source + 1);
        uVar1 = uVar1 >> 2;
        puVar2 = (undefined4 *)((int)destination + 1);
        if (7 < uVar1) {
          for (; uVar1 != 0; uVar1 = uVar1 - 1) {
            *puVar2 = *source;
            source = source + 1;
            puVar2 = puVar2 + 1;
          }
          switch(count) {
          case 0:
            return destination;
          case 2:
            goto switchD_1001b235_caseD_2;
          case 3:
            goto switchD_1001b235_caseD_3;
          }
          goto switchD_1001b235_caseD_1;
        }
      }
    }
  }
  switch(uVar1) {
  case 7:
    puVar2[uVar1 - 7] = source[uVar1 - 7];
  case 6:
    puVar2[uVar1 - 6] = source[uVar1 - 6];
  case 5:
    puVar2[uVar1 - 5] = source[uVar1 - 5];
  case 4:
    puVar2[uVar1 - 4] = source[uVar1 - 4];
  case 3:
    puVar2[uVar1 - 3] = source[uVar1 - 3];
  case 2:
    puVar2[uVar1 - 2] = source[uVar1 - 2];
  case 1:
    puVar2[uVar1 - 1] = source[uVar1 - 1];
    source = source + uVar1;
    puVar2 = puVar2 + uVar1;
  }
  switch(count) {
  case 1:
switchD_1001b235_caseD_1:
    *(undefined1 *)puVar2 = *(undefined1 *)source;
    return destination;
  case 2:
switchD_1001b235_caseD_2:
    *(undefined1 *)puVar2 = *(undefined1 *)source;
    *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
    return destination;
  case 3:
switchD_1001b235_caseD_3:
    *(undefined1 *)puVar2 = *(undefined1 *)source;
    *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
    *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
    return destination;
  }
switchD_1001b235_caseD_0:
  return destination;
}



// Setting prototype: void seed_random_2(uint32_t seed)

void seed_random_2(uint32_t seed)

{
  int iVar1;
  
                    // 
                    // Seeds the random number generator using thread-local storage.
                    // 
                    // Parameters:
                    //   seed: The seed value.
                    // 
  iVar1 = get_tls_block();
  *(uint32_t *)(iVar1 + 0x14) = seed;
  return;
}



// Setting prototype: int _rand(void)

int __cdecl _rand(void)

{
  int iVar1;
  uint uVar2;
  
                    // 
                    // Generates a pseudo-random integer.
                    // 
                    // Return values:
                    //   A pseudo-random integer.
                    // 
  iVar1 = get_tls_block();
  uVar2 = *(int *)(iVar1 + 0x14) * 0x343fd + 0x269ec3;
  *(uint *)(iVar1 + 0x14) = uVar2;
  return uVar2 >> 0x10 & 0x7fff;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int32_t __ftol(void)

int32_t __ftol(void)

{
  float10 in_ST0;
  undefined4 local_10;
  
                    // 
                    // Converts a floating-point value to a long integer by truncation.
                    // 
                    // Return values:
                    //   The truncated long integer value.
                    // 
  local_10 = (int32_t)(longlong)ROUND(in_ST0);
  return local_10;
}



// Setting prototype: int crt_startup_3(const char *format_string)

int crt_startup_3(char *format_string)

{
  uint32_t status;
  int iVar1;
  
                    // 
                    // Performs C runtime startup initialization, likely related to formatted
                    // output.
                    // 
                    // Parameters:
                    //   format_string: The format string for output.
                    // 
                    // Return values:
                    //   The number of characters written, or a negative value on error.
                    // 
  lock_stream_2(1,&DAT_10031818);
  status = file_io(&DAT_10031818);
  iVar1 = printf_internal_4(&DAT_10031818,format_string,&stack0x00000008);
  file_io_2(status,&DAT_10031818);
  unlock_stream_2(1,&DAT_10031818);
  return iVar1;
}



// Setting prototype: void *realloc_internal(void *old_ptr, uint32_t new_size)

byte * realloc_internal(byte *old_ptr,uint new_size)

{
  int iVar1;
  uint uVar2;
  byte *pbVar3;
  void *local_3c;
  uint local_38;
  byte *local_34;
  void *local_30;
  void *local_2c;
  byte *local_28;
  uint local_24;
  void *local_14;
  undefined1 *puStack_10;
  undefined *puStack_c;
  undefined4 local_8;
  
                    // 
                    // Reallocates a block of memory to a new size.
                    // 
                    // Parameters:
                    //   old_ptr: Pointer to the old memory block.
                    //   new_size: The new size for the memory block.
                    // 
                    // Return values:
                    //   A pointer to the reallocated memory block, or NULL if reallocation fails.
                    // 
  local_8 = 0xffffffff;
  puStack_c = &DAT_10025ff0;
  puStack_10 = &LAB_1001e7dc;
  local_14 = ExceptionList;
  pbVar3 = (byte *)0x0;
  if (old_ptr == (byte *)0x0) {
    ExceptionList = &local_14;
    pbVar3 = (byte *)_malloc(new_size);
  }
  else {
    if (new_size == 0) {
      ExceptionList = &local_14;
      free_memory(old_ptr);
    }
    else {
      ExceptionList = &local_14;
      if (DAT_11766450 == 3) {
        do {
          local_28 = (byte *)0x0;
          if (new_size < 0xffffffe1) {
            lock_resource(9);
            local_8 = 0;
            local_2c = (void *)heap_management_3((uint32_t)old_ptr);
            if (local_2c != (void *)0x0) {
              if (new_size <= DAT_11766448) {
                iVar1 = heap_management_12(local_2c,old_ptr,new_size);
                if (iVar1 == 0) {
                  local_28 = (byte *)heap_management_9(new_size);
                  if (local_28 != (byte *)0x0) {
                    local_24 = *(int *)(old_ptr + -4) - 1;
                    uVar2 = local_24;
                    if (new_size <= local_24) {
                      uVar2 = new_size;
                    }
                    memcpy_internal_6(local_28,old_ptr,uVar2);
                    local_2c = (void *)heap_management_3((uint32_t)old_ptr);
                    heap_management_4(local_2c,old_ptr);
                  }
                }
                else {
                  local_28 = old_ptr;
                }
              }
              if (local_28 == (byte *)0x0) {
                if (new_size == 0) {
                  new_size = 1;
                }
                new_size = new_size + 0xf & 0xfffffff0;
                local_28 = (byte *)HeapAlloc(DAT_1176644c,0,new_size);
                if (local_28 != (byte *)0x0) {
                  local_24 = *(int *)(old_ptr + -4) - 1;
                  uVar2 = local_24;
                  if (new_size <= local_24) {
                    uVar2 = new_size;
                  }
                  memcpy_internal_6(local_28,old_ptr,uVar2);
                  heap_management_4(local_2c,old_ptr);
                }
              }
            }
            local_8 = 0xffffffff;
            memory_management_7();
            if (local_2c == (void *)0x0) {
              if (new_size == 0) {
                new_size = 1;
              }
              new_size = new_size + 0xf & 0xfffffff0;
              local_28 = (byte *)HeapReAlloc(DAT_1176644c,0,old_ptr,new_size);
            }
          }
          if (local_28 != (byte *)0x0) {
            ExceptionList = local_14;
            return local_28;
          }
          if (DAT_1003559c == (byte *)0x0) {
            ExceptionList = local_14;
            return (byte *)0x0;
          }
          iVar1 = new_handler(new_size);
        } while (iVar1 != 0);
      }
      else {
        ExceptionList = &local_14;
        if (DAT_11766450 == 2) {
          ExceptionList = &local_14;
          if (new_size < 0xffffffe1) {
            if (new_size == 0) {
              new_size = 0x10;
              ExceptionList = &local_14;
            }
            else {
              new_size = new_size + 0xf & 0xfffffff0;
              ExceptionList = &local_14;
            }
          }
          do {
            local_28 = pbVar3;
            if (new_size < 0xffffffe1) {
              lock_resource(9);
              local_8 = 1;
              pbVar3 = (byte *)heap_management_16(old_ptr,&local_3c,(uint32_t *)&local_30);
              local_34 = pbVar3;
              if (pbVar3 == (byte *)0x0) {
                local_28 = (byte *)HeapReAlloc(DAT_1176644c,0,old_ptr,new_size);
              }
              else {
                if (new_size < DAT_10033b9c) {
                  iVar1 = heap_management_20(local_3c,local_30,pbVar3,new_size >> 4);
                  if (iVar1 == 0) {
                    local_28 = (byte *)heap_management_18(new_size >> 4);
                    if (local_28 != (byte *)0x0) {
                      local_38 = (uint)*pbVar3 << 4;
                      uVar2 = local_38;
                      if (new_size <= local_38) {
                        uVar2 = new_size;
                      }
                      memcpy_internal_6(local_28,old_ptr,uVar2);
                      heap_management_17(local_3c,(uint32_t)local_30,pbVar3);
                    }
                  }
                  else {
                    local_28 = old_ptr;
                  }
                }
                if ((local_28 == (byte *)0x0) &&
                   (local_28 = (byte *)HeapAlloc(DAT_1176644c,0,new_size), local_28 != (byte *)0x0))
                {
                  local_38 = (uint)*pbVar3 << 4;
                  uVar2 = local_38;
                  if (new_size <= local_38) {
                    uVar2 = new_size;
                  }
                  memcpy_internal_6(local_28,old_ptr,uVar2);
                  heap_management_17(local_3c,(uint32_t)local_30,pbVar3);
                }
              }
              local_8 = 0xffffffff;
              memory_management_8();
            }
            if (local_28 != pbVar3) {
              ExceptionList = local_14;
              return local_28;
            }
            if (DAT_1003559c == pbVar3) {
              ExceptionList = local_14;
              return local_28;
            }
            iVar1 = new_handler(new_size);
          } while (iVar1 != 0);
        }
        else {
          do {
            pbVar3 = (byte *)0x0;
            if (new_size < 0xffffffe1) {
              if (new_size == 0) {
                new_size = 1;
              }
              new_size = new_size + 0xf & 0xfffffff0;
              pbVar3 = (byte *)HeapReAlloc(DAT_1176644c,0,old_ptr,new_size);
            }
            if (pbVar3 != (byte *)0x0) {
              ExceptionList = local_14;
              return pbVar3;
            }
            if (DAT_1003559c == (byte *)0x0) {
              ExceptionList = local_14;
              return (byte *)0x0;
            }
            iVar1 = new_handler(new_size);
          } while (iVar1 != 0);
        }
      }
    }
    pbVar3 = (byte *)0x0;
  }
  ExceptionList = local_14;
  return pbVar3;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void memory_management_7(void)

void memory_management_7(void)

{
                    // 
                    // Manages memory, likely by unlocking a resource.
                    // 
  unlock_resource(9);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void memory_management_8(void)

void memory_management_8(void)

{
                    // 
                    // Manages memory, likely by unlocking a resource.
                    // 
  unlock_resource(9);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: BOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)

BOOL DllMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpvReserved)

{
  int init_result;
  BOOL dllmain_result;
  
                    // 
                    // DllMain entry point for the DLL.
                    // This function handles DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH, and
                    // DLL_THREAD_DETACH notifications.
                    // 
                    // Parameters:
                    //   hinstDLL: A handle to the DLL module.
                    //   fdwReason: The reason code that indicates why the DLL entry-point function
                    // is being called.
                    // 
                    // Return values:
                    //   TRUE if initialization is successful, or FALSE on failure.
                    // 
  if (fdwReason == 1) {
                    // g_windowsVersionRaw format: 0xMMmmbbbb
    g_windowsVersionRaw = GetVersion();
    init_result = heap_init(1);
    if (init_result != 0) {
      _g_winVerMajor = g_windowsVersionRaw >> 8 & 0xff;
      _g_winVerMinor = g_windowsVersionRaw & 0xff;
                    // now contains build number
      g_windowsVersionRaw = g_windowsVersionRaw >> 0x10;
      _g_winVerCombined = _g_winVerMinor * 0x100 + _g_winVerMajor;
      init_result = tls_init();
      if (init_result != 0) {
        g_commandLine = GetCommandLineA();
        g_envStrings = get_environment_strings();
        crt_init_file_descriptors();
        env_var_management_2();
        env_var_management();
        exit_program();
        g_dllAttachCount = g_dllAttachCount + 1;
        goto return_true_success;
      }
      heap_deinit();
    }
fail_dll_process_attach:
    dllmain_result = 0;
  }
  else {
    if (fdwReason == 0) {
      if (g_dllAttachCount < 1) goto fail_dll_process_attach;
      g_dllAttachCount = g_dllAttachCount + -1;
      if (g_remainingExitRefs == 0) {
        exit_program_3();
      }
      crt_shutdown();
      tls_deinit();
      heap_deinit();
    }
    else if (fdwReason == 3) {
      free_tls_block((void *)0x0);
    }
return_true_success:
    dllmain_result = 1;
  }
  return dllmain_result;
}



// Setting prototype: BOOL entry(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)

BOOL entry(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpvReserved)

{
  int iVar1;
  DWORD res;
  BOOL result;
  DWORD reason;
  
                    // 
                    // Entry point for the DLL.
                    // This function dispatches calls to DllMain based on the reason for the call.
                    // 
                    // Parameters:
                    //   hinstDLL: A handle to the DLL module.
                    //   fdwReason: The reason code that indicates why the DLL entry-point function
                    // is being called.
                    //   lpvReserved: Reserved.
                    // 
                    // Return values:
                    //   TRUE if initialization is successful, or FALSE on failure.
                    // 
  reason = fdwReason;
  iVar1 = g_dllAttachCount;
  if (fdwReason != 0) {
    if ((fdwReason != 1) && (fdwReason != 2)) goto entry_dispatch_continue;
    if ((g_pfnTlsCallback != (code *)0x0) &&
       (iVar1 = (*g_pfnTlsCallback)(hinstDLL,fdwReason,lpvReserved), iVar1 == 0)) {
      return 0;
    }
    iVar1 = DllMain(hinstDLL,fdwReason,lpvReserved);
  }
  if (iVar1 == 0) {
    return 0;
  }
entry_dispatch_continue:
  res = DllMain_Internal();
  if (fdwReason == 1) {
    if (res != 0) {
      return res;
    }
    DllMain(hinstDLL,0,lpvReserved);
  }
  if ((fdwReason != 0) && (fdwReason != 3)) {
    return res;
  }
  result = DllMain(hinstDLL,fdwReason,lpvReserved);
  fdwReason = res;
  if (result == 0) {
    fdwReason = 0;
  }
  if (fdwReason != 0) {
    if (g_pfnTlsCallback != (code *)0x0) {
      result = (*g_pfnTlsCallback)(hinstDLL,reason,lpvReserved);
      return result;
    }
    return fdwReason;
  }
  return 0;
}



// Setting prototype: void __amsg_exit(int exit_code)

void __cdecl __amsg_exit(int exit_code)

{
                    // 
                    // Handles program exit due to an error, performing cleanup and terminating the
                    // process.
                    // 
                    // Parameters:
                    //   exit_code: The exit code to use.
                    // 
  if ((DAT_10035508 == 1) || ((DAT_10035508 == 0 && (DAT_1003550c == 1)))) {
    exit_program_44();
  }
  exit_program_45(exit_code);
  (*(code *)PTR___exit_100317f0)(0xff);
  return;
}



// Setting prototype: void lock_stream(void *stream_ptr)

void lock_stream(void *stream_ptr)

{
                    // 
                    // Locks a stream for exclusive access.
                    // 
                    // Parameters:
                    //   stream_ptr: Pointer to the stream to lock.
                    // 
  if (((void *)0x100317f7 < stream_ptr) && (stream_ptr < (void *)0x10031a59)) {
    lock_resource(((int)stream_ptr + -0x100317f8 >> 5) + 0x1c);
    return;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((int)stream_ptr + 0x20));
  return;
}



// Setting prototype: void lock_stream_2(int stream_id, void *stream_ptr)

void lock_stream_2(int stream_id,void *stream_ptr)

{
                    // 
                    // Locks a stream for exclusive access, using either a resource ID or a critical
                    // section.
                    // 
                    // Parameters:
                    //   stream_id: The ID of the stream.
                    //   stream_ptr: Pointer to the stream to lock.
                    // 
  if (stream_id < 0x14) {
    lock_resource(stream_id + 0x1c);
    return;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((int)stream_ptr + 0x20));
  return;
}



// Setting prototype: void unlock_stream(void *stream_ptr)

void unlock_stream(void *stream_ptr)

{
                    // 
                    // Unlocks a stream, releasing exclusive access.
                    // 
                    // Parameters:
                    //   stream_ptr: Pointer to the stream to unlock.
                    // 
  if (((void *)0x100317f7 < stream_ptr) && (stream_ptr < (void *)0x10031a59)) {
    unlock_resource(((int)stream_ptr + -0x100317f8 >> 5) + 0x1c);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((int)stream_ptr + 0x20));
  return;
}



// Setting prototype: void unlock_stream_2(int stream_id, void *stream_ptr)

void unlock_stream_2(int stream_id,void *stream_ptr)

{
                    // 
                    // Unlocks a stream, releasing exclusive access, using either a resource ID or a
                    // critical section.
                    // 
                    // Parameters:
                    //   stream_id: The ID of the stream.
                    //   stream_ptr: Pointer to the stream to unlock.
                    // 
  if (stream_id < 0x14) {
    unlock_resource(stream_id + 0x1c);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((int)stream_ptr + 0x20));
  return;
}



// Setting prototype: int close_file_handle(uint32_t file_descriptor)

int close_file_handle(uint32_t file_descriptor)

{
  int iVar1;
  undefined4 *puVar2;
  
                    // 
                    // Closes a file handle.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor to close.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  if ((file_descriptor < DAT_11766560) &&
     ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + (file_descriptor & 0x1f) * 0x24) &
      1) != 0)) {
    file_management_13(file_descriptor);
    iVar1 = close_file_handle_2(file_descriptor);
    file_management_14(file_descriptor);
    return iVar1;
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 9;
  puVar2 = (undefined4 *)get_last_error_2();
  *puVar2 = 0;
  return -1;
}



// Setting prototype: int close_file_handle_2(uint32_t file_descriptor)

int close_file_handle_2(uint32_t file_descriptor)

{
  int iVar1;
  int iVar2;
  HANDLE hObject;
  BOOL BVar3;
  DWORD input_error_code;
  
                    // 
                    // Closes a file handle and performs associated cleanup.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor to close.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  iVar1 = file_management_12(file_descriptor);
  if (iVar1 != -1) {
    if ((file_descriptor == 1) || (file_descriptor == 2)) {
      iVar1 = file_management_12(2);
      iVar2 = file_management_12(1);
      if (iVar2 == iVar1) goto LAB_1001bcaf;
    }
    hObject = (HANDLE)file_management_12(file_descriptor);
    BVar3 = CloseHandle(hObject);
    if (BVar3 == 0) {
      input_error_code = GetLastError();
      goto LAB_1001bcb1;
    }
  }
LAB_1001bcaf:
  input_error_code = 0;
LAB_1001bcb1:
  file_management_11(file_descriptor);
  *(undefined1 *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + (file_descriptor & 0x1f) * 0x24)
       = 0;
  if (input_error_code == 0) {
    iVar1 = 0;
  }
  else {
    get_error_code(input_error_code);
    iVar1 = -1;
  }
  return iVar1;
}



// Setting prototype: void __freebuf(FILE *file_ptr)

void __cdecl __freebuf(FILE *file_ptr)

{
                    // 
                    // Frees the buffer associated with a FILE structure.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the FILE structure.
                    // 
  if (((file_ptr->_flag & 0x83U) != 0) && ((file_ptr->_flag & 8U) != 0)) {
    free_memory(file_ptr->_base);
    *(ushort *)&file_ptr->_flag = (ushort)file_ptr->_flag & 0xfbf7;
    file_ptr->_ptr = (char *)0x0;
    file_ptr->_base = (char *)0x0;
    file_ptr->_cnt = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: uint32_t file_io(void *file_ptr)

uint32_t file_io(void *file_ptr)

{
  undefined4 uVar1;
  int iVar2;
  void *pvVar3;
  
                    // 
                    // Handles file I/O operations, including buffer management and stream flags.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the FILE structure.
                    // 
                    // Return values:
                    //   A status code indicating success or failure.
                    // 
  iVar2 = file_management_15(*(undefined4 *)((int)file_ptr + 0x10));
  if (iVar2 == 0) {
    return 0;
  }
  if ((undefined *)file_ptr == &DAT_10031818) {
    iVar2 = 0;
  }
  else {
    if ((undefined *)file_ptr != &DAT_10031838) {
      return 0;
    }
    iVar2 = 1;
  }
  _DAT_10035510 = _DAT_10035510 + 1;
  if ((*(ushort *)((int)file_ptr + 0xc) & 0x10c) != 0) {
    return 0;
  }
  if ((&DAT_10035514)[iVar2] == 0) {
    pvVar3 = _malloc(0x1000);
    (&DAT_10035514)[iVar2] = pvVar3;
    if (pvVar3 == (void *)0x0) {
      *(int *)((int)file_ptr + 8) = (int)file_ptr + 0x14;
      *(int *)file_ptr = (int)file_ptr + 0x14;
      *(undefined4 *)((int)file_ptr + 0x18) = 2;
      *(undefined4 *)((int)file_ptr + 4) = 2;
      goto LAB_1001bd8b;
    }
  }
  uVar1 = (&DAT_10035514)[iVar2];
  *(undefined4 *)((int)file_ptr + 0x18) = 0x1000;
  *(undefined4 *)((int)file_ptr + 8) = uVar1;
  *(undefined4 *)file_ptr = uVar1;
  *(undefined4 *)((int)file_ptr + 4) = 0x1000;
LAB_1001bd8b:
  *(ushort *)((int)file_ptr + 0xc) = *(ushort *)((int)file_ptr + 0xc) | 0x1102;
  return 1;
}



// Setting prototype: void file_io_2(int status, void *file_ptr)

void file_io_2(int status,void *file_ptr)

{
                    // 
                    // Handles file I/O operations, specifically flushing and resetting the file
                    // buffer based on status.
                    // 
                    // Parameters:
                    //   status: The status of the previous file operation.
                    //   file_ptr: Pointer to the FILE structure.
                    // 
  if ((status != 0) && ((*(byte *)((int)file_ptr + 0xd) & 0x10) != 0)) {
    file_flush_2(file_ptr);
    *(byte *)((int)file_ptr + 0xd) = *(byte *)((int)file_ptr + 0xd) & 0xee;
    *(undefined4 *)((int)file_ptr + 0x18) = 0;
    *(undefined4 *)file_ptr = 0;
    *(undefined4 *)((int)file_ptr + 8) = 0;
  }
  return;
}



// Setting prototype: size_t strlen(const char *str)

size_t __cdecl _strlen(char *str)

{
  uint uVar1;
  uint *puVar2;
  uint *puVar3;
  
                    // 
                    // Calculates the length of a null-terminated string.
                    // 
                    // Parameters:
                    //   str: The string whose length is to be calculated.
                    // 
                    // Return values:
                    //   The length of the string.
                    // 
  uVar1 = (uint)str & 3;
  puVar2 = (uint *)str;
  while (uVar1 != 0) {
    uVar1 = *puVar2;
    puVar2 = (uint *)((int)puVar2 + 1);
    if ((char)uVar1 == '\0') goto LAB_1001be23;
    uVar1 = (uint)puVar2 & 3;
  }
  do {
    do {
      puVar3 = puVar2;
      puVar2 = puVar3 + 1;
    } while (((*puVar3 ^ 0xffffffff ^ *puVar3 + 0x7efefeff) & 0x81010100) == 0);
    uVar1 = *puVar3;
    if ((char)uVar1 == '\0') {
      return (int)puVar3 - (int)str;
    }
    if ((char)(uVar1 >> 8) == '\0') {
      return (size_t)((int)puVar3 + (1 - (int)str));
    }
    if ((uVar1 & 0xff0000) == 0) {
      return (size_t)((int)puVar3 + (2 - (int)str));
    }
  } while ((uVar1 & 0xff000000) != 0);
LAB_1001be23:
  return (size_t)((int)puVar2 + (-1 - (int)str));
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Setting prototype: void *printf_internal(uint32_t file_descriptor, char *mode_string, void
// *file_handle_ptr, void *file_struct_ptr)

undefined4 *
printf_internal(undefined4 file_descriptor,char *mode_string,undefined4 file_handle_ptr,
               undefined4 *file_struct_ptr)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  
                    // 
                    // Internal printf implementation for file operations.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   mode_string: The mode string (e.g., "r", "w", "a").
                    //   file_handle_ptr: Pointer to the file handle.
                    //   file_struct_ptr: Pointer to the FILE structure.
                    // 
                    // Return values:
                    //   A pointer to the FILE structure if successful, or NULL on error.
                    // 
  bVar4 = false;
  bVar3 = false;
  cVar1 = *mode_string;
  if (cVar1 == 'a') {
    uVar6 = 0x109;
  }
  else {
    if (cVar1 == 'r') {
      uVar6 = 0;
      uVar7 = DAT_10035598 | 1;
      goto LAB_1001be8c;
    }
    if (cVar1 != 'w') {
      return (undefined4 *)0x0;
    }
    uVar6 = 0x301;
  }
  uVar7 = DAT_10035598 | 2;
LAB_1001be8c:
  bVar2 = true;
LAB_1001be8f:
  cVar1 = mode_string[1];
  mode_string = mode_string + 1;
  if ((cVar1 == '\0') || (!bVar2)) {
    iVar5 = file_management_16(file_descriptor,uVar6,file_handle_ptr,0x1a4);
    if (iVar5 < 0) {
      return (undefined4 *)0x0;
    }
    _DAT_10035510 = _DAT_10035510 + 1;
    file_struct_ptr[3] = uVar7;
    file_struct_ptr[1] = 0;
    *file_struct_ptr = 0;
    file_struct_ptr[2] = 0;
    file_struct_ptr[7] = 0;
    file_struct_ptr[4] = iVar5;
    return file_struct_ptr;
  }
  if (cVar1 < 'U') {
    if (cVar1 == 'T') {
      if ((uVar6 & 0x1000) == 0) {
        uVar6 = uVar6 | 0x1000;
        goto LAB_1001be8f;
      }
    }
    else if (cVar1 == '+') {
      if ((uVar6 & 2) == 0) {
        uVar6 = uVar6 & 0xfffffffe | 2;
        uVar7 = uVar7 & 0xfffffffc | 0x80;
        goto LAB_1001be8f;
      }
    }
    else if (cVar1 == 'D') {
      if ((uVar6 & 0x40) == 0) {
        uVar6 = uVar6 | 0x40;
        goto LAB_1001be8f;
      }
    }
    else if (cVar1 == 'R') {
      if (!bVar3) {
        bVar3 = true;
        uVar6 = uVar6 | 0x10;
        goto LAB_1001be8f;
      }
    }
    else if ((cVar1 == 'S') && (!bVar3)) {
      bVar3 = true;
      uVar6 = uVar6 | 0x20;
      goto LAB_1001be8f;
    }
  }
  else {
    if (cVar1 == 'b') {
      if ((uVar6 & 0xc000) != 0) goto LAB_1001bf6f;
      uVar6 = uVar6 | 0x8000;
      goto LAB_1001be8f;
    }
    if (cVar1 == 'c') {
      if (!bVar4) {
        bVar4 = true;
        uVar7 = uVar7 | 0x4000;
        goto LAB_1001be8f;
      }
    }
    else {
      if (cVar1 != 'n') {
        if ((cVar1 != 't') || ((uVar6 & 0xc000) != 0)) goto LAB_1001bf6f;
        uVar6 = uVar6 | 0x4000;
        goto LAB_1001be8f;
      }
      if (!bVar4) {
        bVar4 = true;
        uVar7 = uVar7 & 0xffffbfff;
        goto LAB_1001be8f;
      }
    }
  }
LAB_1001bf6f:
  bVar2 = false;
  goto LAB_1001be8f;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: FILE *acquire_stream_slot(void)

FILE * acquire_stream_slot(void)

{
  void *stream;
  int stream_index;
  FILE *new_stream;
  
                    // Internal stream allocator for custom FILE-like structures.
                    // 
                    // Returns:
                    // A pointer to a free or newly initialized FILE-like stream, or NULL on
                    // failure.
  new_stream = (FILE *)0x0;
  lock_resource(2);
  stream_index = 0;
  if (0 < g_max_streams) {
    do {
      stream = *(void **)(g_stream_table + stream_index * 4);
      if (stream == (void *)0x0) {
        stream_index = stream_index * 4;
        stream = _malloc(0x38);
        *(void **)(stream_index + g_stream_table) = stream;
        if (*(int *)(stream_index + g_stream_table) != 0) {
          InitializeCriticalSection
                    ((LPCRITICAL_SECTION)(*(int *)(stream_index + g_stream_table) + 0x20));
          EnterCriticalSection((LPCRITICAL_SECTION)(*(int *)(stream_index + g_stream_table) + 0x20))
          ;
          new_stream = *(FILE **)(stream_index + g_stream_table);
initialize_stream_fields:
          if (new_stream != (FILE *)0x0) {
            new_stream->_file = -1;
            new_stream->_cnt = 0;
            new_stream->_flag = 0;
            new_stream->_base = (char *)0x0;
            new_stream->_ptr = (char *)0x0;
            new_stream->_tmpfname = (char *)0x0;
          }
        }
        break;
      }
      if ((*(byte *)((int)stream + 0xc) & 0x83) == 0) {
        lock_stream_2(stream_index,stream);
        stream = *(void **)(g_stream_table + stream_index * 4);
        if ((*(byte *)((int)stream + 0xc) & 0x83) == 0) {
          new_stream = *(FILE **)(g_stream_table + stream_index * 4);
          goto initialize_stream_fields;
        }
        unlock_stream_2(stream_index,stream);
      }
      stream_index = stream_index + 1;
    } while (stream_index < g_max_streams);
  }
  unlock_resource(2);
  return new_stream;
}



// Setting prototype: uint32_t printf_internal_3(uint32_t character, void *file_ptr)

uint32_t printf_internal_3(uint32_t character,void *file_ptr)

{
  uint uVar1;
  uint file_descriptor;
  void *buffer;
  void *pvVar2;
  int iVar3;
  undefined *puVar4;
  void *count;
  
                    // 
                    // Internal printf implementation, likely for writing a single character to a
                    // file.
                    // 
                    // Parameters:
                    //   character: The character to write.
                    //   file_ptr: Pointer to the FILE structure.
                    // 
                    // Return values:
                    //   The character written, or EOF on error.
                    // 
  pvVar2 = file_ptr;
  uVar1 = *(uint *)((int)file_ptr + 0xc);
  file_descriptor = *(uint *)((int)file_ptr + 0x10);
  if (((uVar1 & 0x82) == 0) || ((uVar1 & 0x40) != 0)) {
LAB_1001c18f:
    *(uint *)((int)file_ptr + 0xc) = uVar1 | 0x20;
  }
  else {
    if ((uVar1 & 1) != 0) {
      *(undefined4 *)((int)file_ptr + 4) = 0;
      if ((uVar1 & 0x10) == 0) goto LAB_1001c18f;
      *(undefined4 *)file_ptr = *(undefined4 *)((int)file_ptr + 8);
      *(uint *)((int)file_ptr + 0xc) = uVar1 & 0xfffffffe;
    }
    uVar1 = *(uint *)((int)file_ptr + 0xc);
    *(undefined4 *)((int)file_ptr + 4) = 0;
    file_ptr = (void *)0x0;
    *(uint *)((int)pvVar2 + 0xc) = uVar1 & 0xffffffef | 2;
    if (((uVar1 & 0x10c) == 0) &&
       ((((undefined *)pvVar2 != &DAT_10031818 && ((undefined *)pvVar2 != &DAT_10031838)) ||
        (iVar3 = file_management_15(file_descriptor), iVar3 == 0)))) {
      file_io_31(pvVar2);
    }
    if ((*(ushort *)((int)pvVar2 + 0xc) & 0x108) == 0) {
      count = (void *)0x1;
      file_ptr = (void *)file_write_11(file_descriptor,&character,1);
    }
    else {
      buffer = *(void **)((int)pvVar2 + 8);
                    // WARNING: Load size is inaccurate
      count = (void *)(*pvVar2 - (int)buffer);
      *(int *)pvVar2 = (int)buffer + 1;
      *(int *)((int)pvVar2 + 4) = *(int *)((int)pvVar2 + 0x18) + -1;
      if ((int)count < 1) {
        if (file_descriptor == 0xffffffff) {
          puVar4 = &DAT_10031a88;
        }
        else {
          puVar4 = (undefined *)
                   ((&DAT_11766460)[(int)file_descriptor >> 5] + (file_descriptor & 0x1f) * 0x24);
        }
        if ((puVar4[4] & 0x20) != 0) {
          file_io_5(file_descriptor,0,2);
        }
      }
      else {
        file_ptr = (void *)file_write_11(file_descriptor,buffer,(uint32_t)count);
      }
      **(undefined1 **)((int)pvVar2 + 8) = (undefined1)character;
    }
    if (file_ptr == count) {
      return character & 0xff;
    }
    *(uint *)((int)pvVar2 + 0xc) = *(uint *)((int)pvVar2 + 0xc) | 0x20;
  }
  return 0xffffffff;
}



// Setting prototype: int printf_internal_4(void *file_ptr, char *format_string, void *arg_list)

int printf_internal_4(void *file_ptr,char *format_string,void *arg_list)

{
  uint uVar1;
  short *psVar2;
  short *psVar3;
  int *piVar4;
  int length;
  byte bVar5;
  uint32_t uVar6;
  int iVar7;
  undefined1 *puVar8;
  ulonglong uVar9;
  longlong lVar10;
  undefined1 local_24c [511];
  undefined1 local_4d;
  undefined4 local_4c;
  undefined4 local_48;
  int local_44;
  int local_40;
  char local_3c [4];
  undefined4 local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  uint32_t local_24;
  int local_20;
  char local_1a;
  char local_19;
  int local_18;
  uint32_t local_14;
  undefined1 *local_10;
  short *local_c;
  uint local_8;
  
                    // 
                    // Internal printf implementation for formatted output.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the FILE structure.
                    //   format_string: The format string.
                    //   arg_list: Pointer to the argument list.
                    // 
                    // Return values:
                    //   The number of characters written, or a negative value on error.
                    // 
  local_34 = 0;
  bVar5 = *format_string;
  format_string = format_string + 1;
  local_10 = (undefined1 *)0x0;
  local_18 = 0;
  do {
    if ((bVar5 == 0) || (local_18 < 0)) {
      return local_18;
    }
    if (((char)bVar5 < ' ') || ('x' < (char)bVar5)) {
      uVar1 = 0;
    }
    else {
      uVar1 = (byte)(&DAT_10025fe8)[(char)bVar5] & 0xf;
    }
    local_34 = (int)(char)(&DAT_10026008)[uVar1 * 8 + local_34] >> 4;
    switch(local_34) {
    case 0:
switchD_1001c209_caseD_0:
      local_28 = 0;
      if ((PTR_DAT_10033cd4[(uint)bVar5 * 2 + 1] & 0x80) != 0) {
        printf_internal_5((int)(char)bVar5,file_ptr,&local_18);
        bVar5 = *format_string;
        format_string = (char *)((byte *)format_string + 1);
      }
      printf_internal_5((int)(char)bVar5,file_ptr,&local_18);
      break;
    case 1:
      local_14 = 0xffffffff;
      local_38 = 0;
      local_2c = 0;
      local_24 = 0;
      local_20 = 0;
      local_8 = 0;
      local_28 = 0;
      break;
    case 2:
      if (bVar5 == 0x20) {
        local_8 = local_8 | 2;
      }
      else if (bVar5 == 0x23) {
        local_8 = local_8 | 0x80;
      }
      else if (bVar5 == 0x2b) {
        local_8 = local_8 | 1;
      }
      else if (bVar5 == 0x2d) {
        local_8 = local_8 | 4;
      }
      else if (bVar5 == 0x30) {
        local_8 = local_8 | 8;
      }
      break;
    case 3:
      if (bVar5 == 0x2a) {
        local_24 = printf_internal_15(&arg_list);
        if ((int)local_24 < 0) {
          local_8 = local_8 | 4;
          local_24 = -local_24;
        }
      }
      else {
        local_24 = (char)bVar5 + -0x30 + local_24 * 10;
      }
      break;
    case 4:
      local_14 = 0;
      break;
    case 5:
      if (bVar5 == 0x2a) {
        local_14 = printf_internal_15(&arg_list);
        if ((int)local_14 < 0) {
          local_14 = 0xffffffff;
        }
      }
      else {
        local_14 = (char)bVar5 + -0x30 + local_14 * 10;
      }
      break;
    case 6:
      if (bVar5 == 0x49) {
        if ((*format_string != 0x36) || (((byte *)format_string)[1] != 0x34)) {
          local_34 = 0;
          goto switchD_1001c209_caseD_0;
        }
        format_string = (char *)((byte *)format_string + 2);
        local_8 = local_8 | 0x8000;
      }
      else if (bVar5 == 0x68) {
        local_8 = local_8 | 0x20;
      }
      else if (bVar5 == 0x6c) {
        local_8 = local_8 | 0x10;
      }
      else if (bVar5 == 0x77) {
        local_8 = local_8 | 0x800;
      }
      break;
    case 7:
      psVar3 = local_c;
      if ((char)bVar5 < 'h') {
        if ((char)bVar5 < 'e') {
          if ((char)bVar5 < 'Y') {
            if (bVar5 == 0x58) {
LAB_1001c61a:
              local_30 = 7;
LAB_1001c621:
              local_10 = (undefined1 *)0x10;
              if ((local_8 & 0x80) != 0) {
                local_1a = '0';
                local_19 = (char)local_30 + 'Q';
                local_20 = 2;
              }
              goto LAB_1001c68b;
            }
            if (bVar5 != 0x43) {
              if ((bVar5 != 0x45) && (bVar5 != 0x47)) {
                if (bVar5 == 0x53) {
                  if ((local_8 & 0x830) == 0) {
                    local_8 = local_8 | 0x800;
                  }
                  goto LAB_1001c3c8;
                }
                goto LAB_1001c7a5;
              }
              local_38 = 1;
              bVar5 = bVar5 + 0x20;
              goto LAB_1001c429;
            }
            if ((local_8 & 0x830) == 0) {
              local_8 = local_8 | 0x800;
            }
LAB_1001c456:
            if ((local_8 & 0x810) == 0) {
              uVar6 = printf_internal_15(&arg_list);
              local_24c[0] = (char)uVar6;
              local_10 = (undefined1 *)0x1;
            }
            else {
              uVar6 = printf_internal_17(&arg_list);
              local_10 = (undefined1 *)char_to_upper_15(local_24c,uVar6);
              if ((int)local_10 < 0) {
                local_2c = 1;
              }
            }
            psVar3 = (short *)local_24c;
          }
          else if (bVar5 == 0x5a) {
            psVar2 = (short *)printf_internal_15(&arg_list);
            if ((psVar2 == (short *)0x0) ||
               (psVar3 = *(short **)(psVar2 + 2), psVar3 == (short *)0x0)) {
              local_c = (short *)PTR_s__null__10031a80;
              psVar3 = (short *)PTR_s__null__10031a80;
              goto LAB_1001c59b;
            }
            if ((local_8 & 0x800) == 0) {
              local_28 = 0;
              local_10 = (undefined1 *)(int)*psVar2;
            }
            else {
              local_28 = 1;
              local_10 = (undefined1 *)((uint)(int)*psVar2 >> 1);
            }
          }
          else {
            if (bVar5 == 99) goto LAB_1001c456;
            if (bVar5 == 100) goto LAB_1001c680;
          }
        }
        else {
LAB_1001c429:
          local_8 = local_8 | 0x40;
          psVar3 = (short *)local_24c;
          if ((int)local_14 < 0) {
            local_14 = 6;
          }
          else if ((local_14 == 0) && (bVar5 == 0x67)) {
            local_14 = 1;
          }
                    // WARNING: Load size is inaccurate
          local_4c = *arg_list;
          local_48 = *(undefined4 *)((int)arg_list + 4);
          arg_list = (undefined4 *)((int)arg_list + 8);
          local_c = psVar3;
          (*(code *)PTR___fptrap_10033bb0)(&local_4c,local_24c,(int)(char)bVar5,local_14,local_38);
          uVar1 = local_8 & 0x80;
          if ((uVar1 != 0) && (local_14 == 0)) {
            (*(code *)PTR___fptrap_10033bbc)(local_24c);
          }
          if ((bVar5 == 0x67) && (uVar1 == 0)) {
            (*(code *)PTR___fptrap_10033bb4)(local_24c);
          }
          if (local_24c[0] == '-') {
            local_8 = local_8 | 0x100;
            psVar3 = (short *)(local_24c + 1);
            local_c = psVar3;
          }
LAB_1001c59b:
          local_10 = (undefined1 *)_strlen((char *)psVar3);
          psVar3 = local_c;
        }
      }
      else {
        if (bVar5 == 0x69) {
LAB_1001c680:
          local_8 = local_8 | 0x40;
        }
        else {
          if (bVar5 == 0x6e) {
            piVar4 = (int *)printf_internal_15(&arg_list);
            if ((local_8 & 0x20) == 0) {
              *piVar4 = local_18;
            }
            else {
              *(undefined2 *)piVar4 = (undefined2)local_18;
            }
            local_2c = 1;
            break;
          }
          if (bVar5 == 0x6f) {
            local_10 = (undefined1 *)0x8;
            if ((local_8 & 0x80) != 0) {
              local_8 = local_8 | 0x200;
            }
            goto LAB_1001c68b;
          }
          if (bVar5 == 0x70) {
            local_14 = 8;
            goto LAB_1001c61a;
          }
          if (bVar5 == 0x73) {
LAB_1001c3c8:
            uVar6 = local_14;
            if (local_14 == 0xffffffff) {
              uVar6 = 0x7fffffff;
            }
            psVar2 = (short *)printf_internal_15(&arg_list);
            if ((local_8 & 0x810) == 0) {
              psVar3 = psVar2;
              if (psVar2 == (short *)0x0) {
                psVar2 = (short *)PTR_s__null__10031a80;
                psVar3 = (short *)PTR_s__null__10031a80;
              }
              for (; (uVar6 != 0 && ((char)*psVar2 != '\0')); psVar2 = (short *)((int)psVar2 + 1)) {
                uVar6 = uVar6 - 1;
              }
              local_10 = (undefined1 *)((int)psVar2 - (int)psVar3);
            }
            else {
              if (psVar2 == (short *)0x0) {
                psVar2 = (short *)PTR_DAT_10031a84;
              }
              local_28 = 1;
              for (psVar3 = psVar2; (uVar6 != 0 && (*psVar3 != 0)); psVar3 = psVar3 + 1) {
                uVar6 = uVar6 - 1;
              }
              local_10 = (undefined1 *)((int)psVar3 - (int)psVar2 >> 1);
              psVar3 = psVar2;
            }
            goto LAB_1001c7a5;
          }
          if (bVar5 != 0x75) {
            if (bVar5 != 0x78) goto LAB_1001c7a5;
            local_30 = 0x27;
            goto LAB_1001c621;
          }
        }
        local_10 = (undefined1 *)0xa;
LAB_1001c68b:
        if ((local_8 & 0x8000) == 0) {
          if ((local_8 & 0x20) == 0) {
            if ((local_8 & 0x40) == 0) {
              uVar6 = printf_internal_15(&arg_list);
              uVar9 = (ulonglong)uVar6;
              goto LAB_1001c6de;
            }
            uVar1 = printf_internal_15(&arg_list);
          }
          else if ((local_8 & 0x40) == 0) {
            uVar6 = printf_internal_15(&arg_list);
            uVar1 = uVar6 & 0xffff;
          }
          else {
            uVar6 = printf_internal_15(&arg_list);
            uVar1 = (uint)(short)uVar6;
          }
          uVar9 = (ulonglong)(int)uVar1;
        }
        else {
          uVar9 = printf_internal_16(&arg_list);
        }
LAB_1001c6de:
        iVar7 = (int)(uVar9 >> 0x20);
        if ((((local_8 & 0x40) != 0) && (iVar7 == 0 || (longlong)uVar9 < 0)) &&
           ((longlong)uVar9 < 0)) {
          local_8 = local_8 | 0x100;
          uVar9 = CONCAT44(-(iVar7 + (uint)((int)uVar9 != 0)),-(int)uVar9);
        }
        iVar7 = (int)(uVar9 >> 0x20);
        if ((local_8 & 0x8000) == 0) {
          iVar7 = 0;
        }
        lVar10 = CONCAT44(iVar7,(int)uVar9);
        if ((int)local_14 < 0) {
          local_14 = 1;
        }
        else {
          local_8 = local_8 & 0xfffffff7;
        }
        if ((int)uVar9 == 0 && iVar7 == 0) {
          local_20 = 0;
        }
        local_c = (short *)&local_4d;
        while ((uVar6 = local_14 - 1, 0 < (int)local_14 || (lVar10 != 0))) {
          local_40 = (int)local_10 >> 0x1f;
          local_44 = (int)local_10;
          local_14 = uVar6;
          iVar7 = __aullrem(lVar10,local_10,local_40);
          iVar7 = iVar7 + 0x30;
          lVar10 = __aulldiv(lVar10,local_44,local_40);
          if (0x39 < iVar7) {
            iVar7 = iVar7 + local_30;
          }
          psVar3 = (short *)((int)local_c + -1);
          *(char *)local_c = (char)iVar7;
          local_c = psVar3;
        }
        iVar7 = -(int)local_c;
        local_10 = &local_4d + iVar7;
        psVar3 = (short *)((int)local_c + 1);
        local_14 = uVar6;
        if (((local_8 & 0x200) != 0) &&
           ((*(char *)psVar3 != '0' || (local_10 == (undefined1 *)0x0)))) {
          *(char *)local_c = '0';
          local_10 = (undefined1 *)((int)&local_4c + iVar7);
          psVar3 = local_c;
        }
      }
LAB_1001c7a5:
      local_c = psVar3;
      uVar1 = local_8;
      if (local_2c == 0) {
        if ((local_8 & 0x40) != 0) {
          if ((local_8 & 0x100) == 0) {
            if ((local_8 & 1) == 0) {
              if ((local_8 & 2) == 0) goto LAB_1001c7dd;
              local_1a = ' ';
            }
            else {
              local_1a = '+';
            }
          }
          else {
            local_1a = '-';
          }
          local_20 = 1;
        }
LAB_1001c7dd:
        iVar7 = (local_24 - local_20) - (int)local_10;
        if ((local_8 & 0xc) == 0) {
          printf_internal_6(0x20,iVar7,file_ptr,&local_18);
        }
        printf_internal_7(&local_1a,local_20,file_ptr,&local_18);
        if (((uVar1 & 8) != 0) && ((uVar1 & 4) == 0)) {
          printf_internal_6(0x30,iVar7,file_ptr,&local_18);
        }
        if ((local_28 == 0) || (puVar8 = local_10, psVar3 = local_c, (int)local_10 < 1)) {
          printf_internal_7((char *)local_c,(int)local_10,file_ptr,&local_18);
        }
        else {
          do {
            puVar8 = puVar8 + -1;
            length = char_to_upper_15(local_3c,*psVar3);
            if (length < 1) break;
            printf_internal_7(local_3c,length,file_ptr,&local_18);
            psVar3 = psVar3 + 1;
          } while (puVar8 != (undefined1 *)0x0);
        }
        if ((local_8 & 4) != 0) {
          printf_internal_6(0x20,iVar7,file_ptr,&local_18);
        }
      }
    }
    bVar5 = *format_string;
    format_string = format_string + 1;
  } while( true );
}



// Setting prototype: void printf_internal_5(uint32_t character, void *file_ptr, int *chars_written)

void printf_internal_5(uint32_t character,void *file_ptr,int *chars_written)

{
  int *piVar1;
  uint uVar2;
  
                    // 
                    // Internal printf implementation, likely for writing a single character to a
                    // file and updating the count of characters written.
                    // 
                    // Parameters:
                    //   character: The character to write.
                    //   file_ptr: Pointer to the FILE structure.
                    //   chars_written: Pointer to an integer tracking the number of characters
                    // written.
                    // 
  piVar1 = (int *)((int)file_ptr + 4);
  *piVar1 = *piVar1 + -1;
  if (*piVar1 < 0) {
    uVar2 = printf_internal_3(character,file_ptr);
  }
  else {
                    // WARNING: Load size is inaccurate
    **file_ptr = (undefined1)character;
                    // WARNING: Load size is inaccurate
    *(int *)file_ptr = *file_ptr + 1;
    uVar2 = character & 0xff;
  }
  if (uVar2 == 0xffffffff) {
    *chars_written = -1;
    return;
  }
  *chars_written = *chars_written + 1;
  return;
}



// Setting prototype: void printf_internal_6(uint32_t character, int count, void *file_ptr, int
// *chars_written)

void printf_internal_6(uint32_t character,int count,void *file_ptr,int *chars_written)

{
  if (0 < count) {
    do {
      count = count + -1;
      printf_internal_5(character,file_ptr,chars_written);
      if (*chars_written == -1) {
        return;
      }
    } while (0 < count);
  }
  return;
}



// Setting prototype: void printf_internal_7(char *string, int length, void *file_ptr, int
// *chars_written)

void printf_internal_7(char *string,int length,void *file_ptr,int *chars_written)

{
  char cVar1;
  
  if (0 < length) {
    do {
      length = length + -1;
      cVar1 = *string;
      string = string + 1;
      printf_internal_5((int)cVar1,file_ptr,chars_written);
      if (*chars_written == -1) {
        return;
      }
    } while (0 < length);
  }
  return;
}



// Setting prototype: uint32_t printf_internal_15(void *arg_list)

uint32_t printf_internal_15(void *arg_list)

{
                    // 
                    // Internal printf implementation, likely for retrieving an integer argument
                    // from the argument list.
                    // 
                    // Parameters:
                    //   arg_list: Pointer to the argument list.
                    // 
                    // Return values:
                    //   The integer argument.
                    // 
                    // WARNING: Load size is inaccurate
  *(int *)arg_list = *arg_list + 4;
                    // WARNING: Load size is inaccurate
  return *(uint32_t *)(*arg_list + -4);
}



// Setting prototype: uint64_t printf_internal_16(void *arg_list)

uint64_t printf_internal_16(void *arg_list)

{
                    // 
                    // Internal printf implementation, likely for retrieving a 64-bit integer
                    // argument from the argument list.
                    // 
                    // Parameters:
                    //   arg_list: Pointer to the argument list.
                    // 
                    // Return values:
                    //   The 64-bit integer argument.
                    // 
                    // WARNING: Load size is inaccurate
  *(int *)arg_list = *arg_list + 8;
                    // WARNING: Load size is inaccurate
  return *(uint64_t *)(*arg_list + -8);
}



// Setting prototype: uint32_t printf_internal_17(void *arg_list)

uint32_t printf_internal_17(void *arg_list)

{
                    // 
                    // Internal printf implementation, likely for retrieving a 32-bit argument from
                    // the argument list.
                    // 
                    // Parameters:
                    //   arg_list: Pointer to the argument list.
                    // 
                    // Return values:
                    //   The 32-bit argument.
                    // 
                    // WARNING: Load size is inaccurate
  *(int *)arg_list = *arg_list + 4;
                    // WARNING: Load size is inaccurate
  return CONCAT22((short)((uint)*arg_list >> 0x10),*(undefined2 *)(*arg_list + -4));
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_init_file_descriptors(void)

void crt_init_file_descriptors(void)

{
  undefined4 *puVar1;
  undefined4 *current_file_descriptor;
  DWORD DVar2;
  HANDLE std_handle;
  UINT *pUVar3;
  int iVar4;
  uint uVar5;
  UINT UVar6;
  UINT UVar7;
  _STARTUPINFOA startup_info;
  byte *startup_info_handles;
  undefined4 *file_descriptor_table;
  
                    // Initializes the C runtime's file descriptors. This function allocates memory
                    // for the file descriptor table, initializes it, and then sets up the standard
                    // input, output, and error streams.
                    // Allocate memory for the file descriptor table
  puVar1 = (undefined4 *)_malloc(0x480);
  if (puVar1 == (undefined4 *)0x0) {
    __amsg_exit(0x1b);
                    // Initialize the file descriptor table
  }
  DAT_11766560 = 0x20;
  DAT_11766460 = puVar1;
  for (; puVar1 < DAT_11766460 + 0x120; puVar1 = puVar1 + 9) {
    *(undefined1 *)(puVar1 + 1) = 0;
                    // If there is reserved data, use it to initialize the file descriptors
    *puVar1 = 0xffffffff;
    puVar1[2] = 0;
    *(undefined1 *)((int)puVar1 + 5) = 10;
  }
  GetStartupInfoA(&startup_info);
  if ((startup_info.cbReserved2 != 0) && ((UINT *)startup_info.lpReserved2 != (UINT *)0x0)) {
    UVar6 = *(UINT *)startup_info.lpReserved2;
    pUVar3 = (UINT *)((int)startup_info.lpReserved2 + 4);
    startup_info_handles = (byte *)((int)pUVar3 + UVar6);
    if (0x7ff < (int)UVar6) {
      UVar6 = 0x800;
    }
    UVar7 = UVar6;
    if ((int)DAT_11766560 < (int)UVar6) {
      puVar1 = &DAT_11766464;
      do {
        current_file_descriptor = (undefined4 *)_malloc(0x480);
        UVar7 = DAT_11766560;
        if (current_file_descriptor == (undefined4 *)0x0) break;
        DAT_11766560 = DAT_11766560 + 0x20;
        *puVar1 = current_file_descriptor;
        file_descriptor_table = current_file_descriptor;
        for (; current_file_descriptor < file_descriptor_table + 0x120;
            current_file_descriptor = current_file_descriptor + 9) {
          *(undefined1 *)(current_file_descriptor + 1) = 0;
          *current_file_descriptor = 0xffffffff;
                    // Initialize the file descriptors from the startup info
          current_file_descriptor[2] = 0;
          *(undefined1 *)((int)current_file_descriptor + 5) = 10;
          file_descriptor_table = (undefined4 *)*puVar1;
        }
        puVar1 = puVar1 + 1;
        UVar7 = UVar6;
      } while ((int)DAT_11766560 < (int)UVar6);
    }
    uVar5 = 0;
    if (0 < (int)UVar7) {
      do {
        if (((*(HANDLE *)startup_info_handles != (HANDLE)0xffffffff) && ((*pUVar3 & 1) != 0)) &&
           (((*pUVar3 & 8) != 0 ||
            (DVar2 = GetFileType(*(HANDLE *)startup_info_handles), DVar2 != 0)))) {
                    // Initialize the standard file descriptors (stdin, stdout, stderr)
          puVar1 = (undefined4 *)((int)(&DAT_11766460)[(int)uVar5 >> 5] + (uVar5 & 0x1f) * 0x24);
          *puVar1 = *(undefined4 *)startup_info_handles;
          *(byte *)(puVar1 + 1) = (byte)*pUVar3;
        }
        startup_info_handles = startup_info_handles + 4;
        uVar5 = uVar5 + 1;
        pUVar3 = (UINT *)((int)pUVar3 + 1);
      } while ((int)uVar5 < (int)UVar7);
    }
  }
  iVar4 = 0;
  do {
    puVar1 = DAT_11766460 + iVar4 * 9;
    if (DAT_11766460[iVar4 * 9] == -1) {
      *(undefined1 *)(puVar1 + 1) = 0x81;
      if (iVar4 == 0) {
        DVar2 = 0xfffffff6;
      }
      else {
        DVar2 = 0xfffffff5 - (iVar4 != 1);
      }
      std_handle = GetStdHandle(DVar2);
      if ((std_handle != (HANDLE)0xffffffff) && (DVar2 = GetFileType(std_handle), DVar2 != 0)) {
        *puVar1 = std_handle;
        if ((DVar2 & 0xff) != 2) {
          if ((DVar2 & 0xff) == 3) {
            *(byte *)(puVar1 + 1) = *(byte *)(puVar1 + 1) | 8;
          }
          goto fd_init_continue;
        }
      }
      *(byte *)(puVar1 + 1) = *(byte *)(puVar1 + 1) | 0x40;
    }
    else {
      *(byte *)(puVar1 + 1) = *(byte *)(puVar1 + 1) | 0x80;
    }
fd_init_continue:
    iVar4 = iVar4 + 1;
    if (2 < iVar4) {
      SetHandleCount(DAT_11766560);
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_shutdown(void)

void crt_shutdown(void)

{
  LPCRITICAL_SECTION lpCriticalSection;
  uint *puVar1;
  uint uVar2;
  
                    // 
                    // Performs C runtime shutdown, including freeing allocated resources and
                    // critical sections.
                    // 
  puVar1 = &DAT_11766460;
  do {
    uVar2 = *puVar1;
    if (uVar2 != 0) {
      if (uVar2 < uVar2 + 0x480) {
        lpCriticalSection = (LPCRITICAL_SECTION)(uVar2 + 0xc);
        do {
          if (lpCriticalSection[-1].SpinCount != 0) {
            DeleteCriticalSection(lpCriticalSection);
          }
          uVar2 = uVar2 + 0x24;
          lpCriticalSection = (LPCRITICAL_SECTION)&lpCriticalSection[1].OwningThread;
        } while (uVar2 < *puVar1 + 0x480);
      }
      free_memory((void *)*puVar1);
      *puVar1 = 0;
    }
    puVar1 = puVar1 + 1;
  } while ((int)puVar1 < 0x11766560);
  return;
}



// Setting prototype: uint32_t file_io_5(uint32_t file_descriptor, uint32_t offset, uint32_t origin)

uint32_t file_io_5(uint32_t file_descriptor,uint32_t offset,uint32_t origin)

{
  uint32_t uVar1;
  undefined4 *puVar2;
  
                    // 
                    // Handles file I/O operations, specifically seeking within a file.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   offset: The offset from the origin.
                    //   origin: The starting position for the offset (e.g., SEEK_SET, SEEK_CUR,
                    // SEEK_END).
                    // 
                    // Return values:
                    //   The new file position, or -1 on error.
                    // 
  if ((file_descriptor < DAT_11766560) &&
     ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + (file_descriptor & 0x1f) * 0x24) &
      1) != 0)) {
    file_management_13(file_descriptor);
    uVar1 = file_io_6(file_descriptor,offset,origin);
    file_management_14(file_descriptor);
    return uVar1;
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 9;
  puVar2 = (undefined4 *)get_last_error_2();
  *puVar2 = 0;
  return 0xffffffff;
}



// Setting prototype: uint32_t file_io_6(uint32_t file_descriptor, int32_t offset, uint32_t
// move_method)

uint32_t file_io_6(uint32_t file_descriptor,int32_t offset,uint32_t move_method)

{
  byte *pbVar1;
  HANDLE hFile;
  undefined4 *puVar2;
  DWORD DVar3;
  uint32_t input_error_code;
  
                    // 
                    // Handles file I/O operations, specifically setting the file pointer.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   offset: The offset from the origin.
                    //   move_method: The starting position for the offset (e.g., FILE_BEGIN,
                    // FILE_CURRENT, FILE_END).
                    // 
                    // Return values:
                    //   The new file pointer, or INVALID_SET_FILE_POINTER on error.
                    // 
  hFile = (HANDLE)file_management_12(file_descriptor);
  if (hFile == (HANDLE)0xffffffff) {
    puVar2 = (undefined4 *)get_last_error();
    *puVar2 = 9;
  }
  else {
    DVar3 = SetFilePointer(hFile,offset,(PLONG)0x0,move_method);
    if (DVar3 == 0xffffffff) {
      input_error_code = GetLastError();
    }
    else {
      input_error_code = 0;
    }
    if (input_error_code == 0) {
      pbVar1 = (byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 +
                       (file_descriptor & 0x1f) * 0x24);
      *pbVar1 = *pbVar1 & 0xfd;
      return DVar3;
    }
    get_error_code(input_error_code);
  }
  return 0xffffffff;
}



// Setting prototype: char *format_datetime(void *datetime_data)

char * format_datetime(undefined4 *datetime_data)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  void *pvVar4;
  char *pcVar5;
  char *pcVar6;
  undefined1 *puVar7;
  undefined4 uVar8;
  int iVar9;
  int iVar10;
  
                    // 
                    // Formats a datetime structure into a human-readable string.
                    // 
                    // Parameters:
                    //   datetime_data: Pointer to the datetime structure.
                    // 
                    // Return values:
                    //   A pointer to the formatted datetime string.
                    // 
  iVar3 = get_tls_block();
  if (*(int *)(iVar3 + 0x38) == 0) {
    pvVar4 = _malloc(0x1a);
    *(void **)(iVar3 + 0x38) = pvVar4;
    pcVar5 = &DAT_1003551c;
    if (pvVar4 == (void *)0x0) goto LAB_1001ccb5;
  }
  pcVar5 = *(char **)(iVar3 + 0x38);
LAB_1001ccb5:
  iVar3 = datetime_data[6];
  iVar1 = datetime_data[4];
  pcVar2 = pcVar5;
  iVar9 = 0;
  do {
    pcVar6 = pcVar2;
    iVar10 = iVar9 + 1;
    *pcVar6 = "SunMonTueWedThuFriSat"[iVar9 + iVar3 * 3];
    pcVar6[4] = "JanFebMarAprMayJunJulAugSepOctNovDec"[iVar1 * 3 + iVar9];
    pcVar2 = pcVar6 + 1;
    iVar9 = iVar10;
  } while (iVar10 < 3);
  pcVar6[1] = ' ';
  pcVar6[5] = ' ';
  puVar7 = (undefined1 *)format_number(pcVar6 + 6,datetime_data[3]);
  *puVar7 = 0x20;
  puVar7 = (undefined1 *)format_number(puVar7 + 1,datetime_data[2]);
  *puVar7 = 0x3a;
  puVar7 = (undefined1 *)format_number(puVar7 + 1,datetime_data[1]);
  *puVar7 = 0x3a;
  puVar7 = (undefined1 *)format_number(puVar7 + 1,*datetime_data);
  *puVar7 = 0x20;
  uVar8 = format_number(puVar7 + 1,(int)datetime_data[5] / 100 + 0x13);
  puVar7 = (undefined1 *)format_number(uVar8,(int)datetime_data[5] % 100);
  *puVar7 = 10;
  puVar7[1] = 0;
  return pcVar5;
}



// Setting prototype: char *format_number(char *buffer, int number)

char * format_number(char *buffer,int number)

{
                    // 
                    // Formats a two-digit number into a character string.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the buffer to store the formatted number.
                    //   number: The number to format (expected to be 0-99).
                    // 
                    // Return values:
                    //   A pointer to the end of the formatted string.
                    // 
  *buffer = (char)(number / 10) + '0';
  buffer[1] = (char)(number % 10) + '0';
  return buffer + 2;
}



// Setting prototype: void *time_to_tm(int *time_val)

int * time_to_tm(int *time_val)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
                    // 
                    // Converts a time_t value to a tm structure.
                    // 
                    // Parameters:
                    //   time_val: Pointer to the time_t value.
                    // 
                    // Return values:
                    //   A pointer to the tm structure, or NULL on error.
                    // 
  piVar1 = time_val;
  if (*time_val < 0) {
    piVar1 = (int *)0x0;
  }
  else {
    time_management();
    iVar2 = *piVar1;
    if ((iVar2 < 0x3f481) || (0x7ffc0b7e < iVar2)) {
      piVar1 = (int *)time_management_6(piVar1);
      iVar3 = time_management_3(piVar1);
      iVar2 = *piVar1;
      if (iVar3 != 0) {
        iVar2 = iVar2 - DAT_10033f88;
      }
      time_val = (int *)(iVar2 - DAT_10033f80);
      iVar2 = (int)time_val % 0x3c;
      *piVar1 = iVar2;
      if (iVar2 < 0) {
        *piVar1 = iVar2 + 0x3c;
        time_val = (int *)((int)time_val + -0x3c);
      }
      time_val = (int *)((int)time_val / 0x3c + piVar1[1]);
      iVar2 = (int)time_val % 0x3c;
      piVar1[1] = iVar2;
      if (iVar2 < 0) {
        piVar1[1] = iVar2 + 0x3c;
        time_val = (int *)((int)time_val + -0x3c);
      }
      time_val = (int *)((int)time_val / 0x3c + piVar1[2]);
      iVar2 = (int)time_val % 0x18;
      piVar1[2] = iVar2;
      if (iVar2 < 0) {
        piVar1[2] = iVar2 + 0x18;
        time_val = (int *)((int)time_val + -0x18);
      }
      iVar2 = (int)time_val / 0x18;
      if (iVar2 < 1) {
        if (-1 < iVar2) {
          return piVar1;
        }
        piVar1[6] = (piVar1[6] + 7 + iVar2) % 7;
        piVar1[3] = piVar1[3] + iVar2;
        if (piVar1[3] < 1) {
          piVar1[5] = piVar1[5] + -1;
          piVar1[3] = piVar1[3] + 0x1f;
          piVar1[7] = 0x16c;
          piVar1[4] = 0xb;
          return piVar1;
        }
      }
      else {
        piVar1[6] = (piVar1[6] + iVar2) % 7;
        piVar1[3] = piVar1[3] + iVar2;
      }
      piVar1[7] = piVar1[7] + iVar2;
    }
    else {
      time_val = (int *)(iVar2 - DAT_10033f80);
      piVar1 = (int *)time_management_6(&time_val);
      if ((DAT_10033f84 != 0) && (iVar2 = time_management_3(piVar1), iVar2 != 0)) {
        time_val = (int *)((int)time_val - DAT_10033f88);
        piVar1 = (int *)time_management_6(&time_val);
        piVar1[8] = 1;
      }
    }
  }
  return piVar1;
}



// Setting prototype: int tm_to_time(int year, int month, int day, int hour, int minute, int second,
// int is_dst)

int tm_to_time(int year,int month,int day,int hour,int minute,int second,int is_dst)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined1 local_28 [8];
  int local_20;
  int local_18;
  uint local_14;
  int local_c;
  
                    // 
                    // Converts a broken-down time (tm structure components) to a time_t value.
                    // 
                    // Parameters:
                    //   year: The year (e.g., 1900 for 1900).
                    //   month: The month (0-11).
                    //   day: The day of the month (1-31).
                    //   hour: The hour of the day (0-23).
                    //   minute: The minute of the hour (0-59).
                    //   second: The second of the minute (0-59).
                    //   is_dst: Daylight Saving Time flag (positive for DST, 0 for standard,
                    // negative for unknown).
                    // 
                    // Return values:
                    //   The time_t value, or -1 on error.
                    // 
  uVar2 = year - 0x76c;
  if (((int)uVar2 < 0x46) || (0x8a < (int)uVar2)) {
    iVar1 = -1;
  }
  else {
    iVar3 = *(int *)(&DAT_10034064 + month * 4) + day;
    if (((uVar2 & 3) == 0) && (2 < month)) {
      iVar3 = iVar3 + 1;
    }
    time_management();
    local_20 = hour;
    local_18 = month + -1;
    iVar1 = ((hour + (uVar2 * 0x16d + iVar3 + (year + -0x76d >> 2)) * 0x18) * 0x3c + minute) * 0x3c
            + DAT_10033f80 + 0x7c558180 + second;
    if ((is_dst == 1) ||
       (((is_dst == -1 && (DAT_10033f84 != 0)) &&
        (local_14 = uVar2, local_c = iVar3, iVar3 = time_management_3(local_28), iVar3 != 0)))) {
      iVar1 = iVar1 + DAT_10033f88;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_init(void)

void crt_init(void)

{
                    // 
                    // Initializes critical sections for C runtime components.
                    // 
  InitializeCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031af0);
  InitializeCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031ae0);
  InitializeCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031ad0);
  InitializeCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031ab0);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_deinit(void)

void crt_deinit(void)

{
  undefined **ppuVar1;
  
                    // 
                    // Deinitializes critical sections for C runtime components and frees associated
                    // memory.
                    // 
  ppuVar1 = (undefined **)&DAT_10031aac;
  do {
    if (((((LPCRITICAL_SECTION)*ppuVar1 != (LPCRITICAL_SECTION)0x0) &&
         (ppuVar1 != &PTR_DAT_10031af0)) && (ppuVar1 != &PTR_DAT_10031ae0)) &&
       ((ppuVar1 != &PTR_DAT_10031ad0 && (ppuVar1 != &PTR_DAT_10031ab0)))) {
      DeleteCriticalSection((LPCRITICAL_SECTION)*ppuVar1);
      free_memory(*ppuVar1);
    }
    ppuVar1 = ppuVar1 + 1;
  } while ((int)ppuVar1 < 0x10031b6c);
  DeleteCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031ad0);
  DeleteCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031ae0);
  DeleteCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031af0);
  DeleteCriticalSection((LPCRITICAL_SECTION)PTR_DAT_10031ab0);
  return;
}



// Setting prototype: void lock_resource(uint32_t resource_id)

void lock_resource(uint32_t resource_id)

{
  int *piVar1;
  LPCRITICAL_SECTION lpCriticalSection;
  
                    // 
                    // Locks a resource using a critical section.
                    // If the critical section for the resource ID is not initialized, it allocates
                    // and initializes it.
                    // 
                    // Parameters:
                    //   resource_id: The ID of the resource to lock.
                    // 
  piVar1 = &DAT_10031aac + resource_id;
  if ((&DAT_10031aac)[resource_id] == 0) {
    lpCriticalSection = (LPCRITICAL_SECTION)_malloc(0x18);
    if (lpCriticalSection == (LPCRITICAL_SECTION)0x0) {
      __amsg_exit(0x11);
    }
    lock_resource(0x11);
    if (*piVar1 == 0) {
      InitializeCriticalSection(lpCriticalSection);
      *piVar1 = (int)lpCriticalSection;
    }
    else {
      free_memory(lpCriticalSection);
    }
    unlock_resource(0x11);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)*piVar1);
  return;
}



// Setting prototype: void unlock_resource(uint32_t resource_id)

void unlock_resource(uint32_t resource_id)

{
                    // 
                    // Unlocks a resource, releasing the critical section.
                    // 
                    // Parameters:
                    //   resource_id: The ID of the resource to unlock.
                    // 
  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_10031aac)[resource_id]);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int tls_init(void)

int tls_init(void)

{
  DWORD *lpTlsValue;
  BOOL BVar1;
  DWORD DVar2;
  
                    // 
                    // Initializes thread-local storage (TLS) for the current thread.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  crt_init();
  DAT_10031b6c = TlsAlloc();
  if (DAT_10031b6c != 0xffffffff) {
    lpTlsValue = (DWORD *)malloc_internal_22(1,0x74);
    if (lpTlsValue != (DWORD *)0x0) {
      BVar1 = TlsSetValue(DAT_10031b6c,lpTlsValue);
      if (BVar1 != 0) {
        tls_init_block(lpTlsValue);
        DVar2 = GetCurrentThreadId();
        lpTlsValue[1] = 0xffffffff;
        *lpTlsValue = DVar2;
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void tls_deinit(void)

void tls_deinit(void)

{
                    // 
                    // Deinitializes thread-local storage (TLS) for the current thread.
                    // 
  crt_deinit();
  if (DAT_10031b6c != 0xffffffff) {
    TlsFree(DAT_10031b6c);
    DAT_10031b6c = 0xffffffff;
  }
  return;
}



// Setting prototype: void tls_init_block(void *tls_block_ptr)

void tls_init_block(void *tls_block_ptr)

{
                    // 
                    // Initializes a thread-local storage (TLS) block.
                    // 
                    // Parameters:
                    //   tls_block_ptr: Pointer to the TLS block to initialize.
                    // 
  *(undefined **)((int)tls_block_ptr + 0x50) = &DAT_100340a0;
  *(undefined4 *)((int)tls_block_ptr + 0x14) = 1;
  return;
}



// Setting prototype: void *get_tls_block(void)

DWORD * get_tls_block(void)

{
  DWORD dwErrCode;
  DWORD *lpTlsValue;
  BOOL BVar1;
  DWORD DVar2;
  
                    // 
                    // Retrieves the thread-local storage (TLS) block for the current thread.
                    // If the TLS block does not exist, it allocates and initializes a new one.
                    // 
                    // Return values:
                    //   A pointer to the TLS block.
                    // 
  dwErrCode = GetLastError();
  lpTlsValue = (DWORD *)TlsGetValue(DAT_10031b6c);
  if (lpTlsValue == (DWORD *)0x0) {
    lpTlsValue = (DWORD *)malloc_internal_22(1,0x74);
    if (lpTlsValue != (DWORD *)0x0) {
      BVar1 = TlsSetValue(DAT_10031b6c,lpTlsValue);
      if (BVar1 != 0) {
        tls_init_block(lpTlsValue);
        DVar2 = GetCurrentThreadId();
        lpTlsValue[1] = 0xffffffff;
        *lpTlsValue = DVar2;
        goto LAB_1001d18c;
      }
    }
    __amsg_exit(0x10);
  }
LAB_1001d18c:
  SetLastError(dwErrCode);
  return lpTlsValue;
}



// Setting prototype: void free_tls_block(void *tls_block_ptr)

void free_tls_block(void *tls_block_ptr)

{
                    // 
                    // Frees a thread-local storage (TLS) block and its associated memory.
                    // 
                    // Parameters:
                    //   tls_block_ptr: Pointer to the TLS block to free.
                    // 
  if (DAT_10031b6c != 0xffffffff) {
    if ((tls_block_ptr != (void *)0x0) ||
       (tls_block_ptr = TlsGetValue(DAT_10031b6c), tls_block_ptr != (LPVOID)0x0)) {
      if (*(void **)((int)tls_block_ptr + 0x24) != (void *)0x0) {
        free_memory(*(void **)((int)tls_block_ptr + 0x24));
      }
      if (*(void **)((int)tls_block_ptr + 0x28) != (void *)0x0) {
        free_memory(*(void **)((int)tls_block_ptr + 0x28));
      }
      if (*(void **)((int)tls_block_ptr + 0x30) != (void *)0x0) {
        free_memory(*(void **)((int)tls_block_ptr + 0x30));
      }
      if (*(void **)((int)tls_block_ptr + 0x38) != (void *)0x0) {
        free_memory(*(void **)((int)tls_block_ptr + 0x38));
      }
      if (*(void **)((int)tls_block_ptr + 0x40) != (void *)0x0) {
        free_memory(*(void **)((int)tls_block_ptr + 0x40));
      }
      if (*(void **)((int)tls_block_ptr + 0x44) != (void *)0x0) {
        free_memory(*(void **)((int)tls_block_ptr + 0x44));
      }
      if (*(undefined **)((int)tls_block_ptr + 0x50) != &DAT_100340a0) {
        free_memory(*(undefined **)((int)tls_block_ptr + 0x50));
      }
      free_memory(tls_block_ptr);
    }
    TlsSetValue(DAT_10031b6c,(LPVOID)0x0);
    return;
  }
  return;
}



// Setting prototype: int new_handler(uint32_t size)

int new_handler(uint32_t size)

{
  int iVar1;
  
                    // 
                    // Calls the currently set new handler function.
                    // 
                    // Parameters:
                    //   size: The size of the failed allocation.
                    // 
                    // Return values:
                    //   1 if the new handler successfully handled the allocation failure, 0
                    // otherwise.
                    // 
  if (DAT_100355a0 != (code *)0x0) {
    iVar1 = (*DAT_100355a0)(size);
    if (iVar1 != 0) {
      return 1;
    }
  }
  return 0;
}



// Setting prototype: void get_os_version(void *version_info)

void get_os_version(void *version_info)

{
  int iVar1;
  HMODULE pHVar2;
  
                    // 
                    // Retrieves the operating system version information.
                    // 
                    // Parameters:
                    //   version_info: Pointer to a buffer to store the version information.
                    // 
  *(undefined4 *)version_info = 0;
  pHVar2 = GetModuleHandleA((LPCSTR)0x0);
  if (((short)pHVar2->unused == 0x5a4d) && (iVar1 = pHVar2[0xf].unused, iVar1 != 0)) {
    *(undefined1 *)version_info = *(undefined1 *)((int)&pHVar2[6].unused + iVar1 + 2);
    *(undefined1 *)((int)version_info + 1) = *(undefined1 *)((int)&pHVar2[6].unused + iVar1 + 3);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int heap_management(void)

int heap_management(void)

{
  char cVar1;
  BOOL BVar2;
  DWORD DVar3;
  int iVar4;
  char *pcVar5;
  byte unaff_BL;
  char local_1230 [4240];
  char local_1a0 [260];
  DWORD local_9c;
  uint local_98;
  DWORD local_8c;
  CHAR aCStackY_18 [4];
  
                    // 
                    // Manages heap allocation, potentially selecting different heap implementations
                    // based on environment variables or OS version.
                    // 
                    // Return values:
                    //   A code indicating the selected heap management strategy.
                    // 
  memory_management_3();
  local_9c = 0x94;
  BVar2 = GetVersionExA((LPOSVERSIONINFOA)&local_9c);
  if (((BVar2 == 0) || (local_8c != 2)) || (local_98 < 5)) {
    aCStackY_18[0] = -0x26;
    aCStackY_18[1] = -0x2e;
    aCStackY_18[2] = '\x01';
    aCStackY_18[3] = '\x10';
    DVar3 = GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT",local_1230,0x1090);
    if (DVar3 != 0) {
      pcVar5 = local_1230;
      while (local_1230[0] != '\0') {
        cVar1 = *pcVar5;
        if (('`' < cVar1) && (cVar1 < '{')) {
          *pcVar5 = cVar1 + -0x20;
        }
        pcVar5 = pcVar5 + 1;
        local_1230[0] = *pcVar5;
      }
      aCStackY_18[0] = '\x18';
      aCStackY_18[1] = -0x2d;
      aCStackY_18[2] = '\x01';
      aCStackY_18[3] = '\x10';
      iVar4 = _strncmp("__GLOBAL_HEAP_SELECTED",local_1230,0x16);
      if (iVar4 == 0) {
        pcVar5 = local_1230;
      }
      else {
        aCStackY_18[0] = ':';
        aCStackY_18[1] = -0x2d;
        aCStackY_18[2] = '\x01';
        aCStackY_18[3] = '\x10';
        GetModuleFileNameA((HMODULE)0x0,local_1a0,0x104);
        pcVar5 = local_1a0;
        while (local_1a0[0] != '\0') {
          cVar1 = *pcVar5;
          if (('`' < cVar1) && (cVar1 < '{')) {
            *pcVar5 = cVar1 + -0x20;
          }
          pcVar5 = pcVar5 + 1;
          local_1a0[0] = *pcVar5;
        }
        pcVar5 = _strstr(local_1230,local_1a0);
      }
      if ((pcVar5 != (char *)0x0) && (pcVar5 = _strchr(pcVar5,0x2c), pcVar5 != (char *)0x0)) {
        pcVar5 = pcVar5 + 1;
        cVar1 = *pcVar5;
        while (cVar1 != '\0') {
          if (*pcVar5 == ';') {
            *pcVar5 = '\0';
          }
          else {
            pcVar5 = pcVar5 + 1;
          }
          cVar1 = *pcVar5;
        }
        aCStackY_18[0] = -0x60;
        aCStackY_18[1] = -0x2d;
        aCStackY_18[2] = '\x01';
        aCStackY_18[3] = '\x10';
        iVar4 = str_to_int();
        if (iVar4 == 2) {
          return 2;
        }
        if (iVar4 == 3) {
          return 3;
        }
        if (iVar4 == 1) {
          return 1;
        }
      }
    }
    get_os_version(&stack0xfffffff8);
    iVar4 = 3 - (uint)(unaff_BL < 6);
  }
  else {
    iVar4 = 1;
  }
  return iVar4;
}



// Setting prototype: int heap_init(uint32_t flags)

int heap_init(uint32_t flags)

{
  int iVar1;
  
                    // 
                    // Initializes the heap, creating a new heap and setting up the heap management
                    // strategy.
                    // 
                    // Parameters:
                    //   flags: Flags for heap creation.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  DAT_1176644c = HeapCreate((uint)(flags == 0),0x1000,0);
  if (DAT_1176644c != (HANDLE)0x0) {
    DAT_11766450 = heap_management();
    if (DAT_11766450 == 3) {
      iVar1 = heap_management_2(0x3f8);
    }
    else {
      if (DAT_11766450 != 2) {
        return 1;
      }
      iVar1 = heap_management_13();
    }
    if (iVar1 != 0) {
      return 1;
    }
    HeapDestroy(DAT_1176644c);
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void heap_deinit(void)

void heap_deinit(void)

{
  int iVar1;
  undefined4 *puVar2;
  undefined **ppuVar3;
  
                    // 
                    // Deinitializes the heap, freeing allocated memory and destroying the heap.
                    // 
  if (DAT_11766450 == 3) {
    iVar1 = 0;
    if (0 < DAT_11766440) {
      puVar2 = (undefined4 *)((int)DAT_11766444 + 0xc);
      do {
        VirtualFree((LPVOID)*puVar2,0x100000,0x4000);
        VirtualFree((LPVOID)*puVar2,0,0x8000);
        HeapFree(DAT_1176644c,0,(LPVOID)puVar2[1]);
        puVar2 = puVar2 + 5;
        iVar1 = iVar1 + 1;
      } while (iVar1 < DAT_11766440);
    }
    HeapFree(DAT_1176644c,0,DAT_11766444);
  }
  else if (DAT_11766450 == 2) {
    ppuVar3 = &PTR_LOOP_10031b78;
    do {
      if (ppuVar3[4] != (undefined *)0x0) {
        VirtualFree(ppuVar3[4],0,0x8000);
      }
      ppuVar3 = (undefined **)*ppuVar3;
    } while (ppuVar3 != &PTR_LOOP_10031b78);
  }
  HeapDestroy(DAT_1176644c);
  return;
}



// Setting prototype: int heap_management_2(uint32_t max_size)

int heap_management_2(uint32_t max_size)

{
                    // 
                    // Manages heap, likely initializing some internal structures for custom heap
                    // management.
                    // 
                    // Parameters:
                    //   max_size: The maximum size for some heap-related operation.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  DAT_11766444 = HeapAlloc(DAT_1176644c,0,0x140);
  if (DAT_11766444 == (LPVOID)0x0) {
    return 0;
  }
  DAT_1176643c = 0;
  DAT_11766440 = 0;
  DAT_11766438 = DAT_11766444;
  DAT_11766448 = max_size;
  DAT_11766430 = 0x10;
  return 1;
}



// Setting prototype: uint32_t heap_management_3(uint32_t address)

uint32_t heap_management_3(uint32_t address)

{
  uint uVar1;
  
                    // 
                    // Manages heap, likely searching for a specific address within allocated
                    // blocks.
                    // 
                    // Parameters:
                    //   address: The address to search for.
                    // 
                    // Return values:
                    //   The address of the found block, or 0 if not found.
                    // 
  uVar1 = DAT_11766444;
  while( true ) {
    if (DAT_11766444 + DAT_11766440 * 0x14 <= uVar1) {
      return 0;
    }
    if (address - *(int *)(uVar1 + 0xc) < 0x100000) break;
    uVar1 = uVar1 + 0x14;
  }
  return uVar1;
}



// Setting prototype: void heap_management_4(void *block_info, void *mem_ptr)

void heap_management_4(void *block_info,void *mem_ptr)

{
  char *pcVar1;
  uint *puVar2;
  int *piVar3;
  char cVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  byte bVar8;
  uint uVar9;
  void *pvVar10;
  void *pvVar11;
  uint *puVar12;
  uint uVar13;
  uint uVar14;
  uint local_8;
  
                    // 
                    // Manages heap, likely for freeing or consolidating memory blocks.
                    // 
                    // Parameters:
                    //   block_info: Pointer to the block information structure.
                    //   mem_ptr: Pointer to the memory block to manage.
                    // 
  iVar5 = *(int *)((int)block_info + 0x10);
  puVar12 = (uint *)((int)mem_ptr + -4);
  uVar14 = (uint)((int)mem_ptr - *(int *)((int)block_info + 0xc)) >> 0xf;
  piVar3 = (int *)(uVar14 * 0x204 + 0x144 + iVar5);
  uVar13 = *puVar12;
  local_8 = uVar13 - 1;
  if ((local_8 & 1) == 0) {
    uVar6 = *(uint *)(local_8 + (int)puVar12);
    uVar7 = *(uint *)((int)mem_ptr + -8);
    if ((uVar6 & 1) == 0) {
      uVar9 = ((int)uVar6 >> 4) - 1;
      if (0x3f < uVar9) {
        uVar9 = 0x3f;
      }
      if (*(int *)((int)puVar12 + uVar13 + 3) == *(int *)((int)puVar12 + uVar13 + 7)) {
        if (uVar9 < 0x20) {
          pcVar1 = (char *)(uVar9 + 4 + iVar5);
          uVar9 = ~(0x80000000U >> ((byte)uVar9 & 0x1f));
          puVar2 = (uint *)(iVar5 + 0x44 + uVar14 * 4);
          *puVar2 = *puVar2 & uVar9;
          *pcVar1 = *pcVar1 + -1;
          if (*pcVar1 == '\0') {
                    // WARNING: Load size is inaccurate
            *(uint *)block_info = *block_info & uVar9;
          }
        }
        else {
          pcVar1 = (char *)(uVar9 + 4 + iVar5);
          uVar9 = ~(0x80000000U >> ((byte)uVar9 - 0x20 & 0x1f));
          puVar2 = (uint *)(iVar5 + 0xc4 + uVar14 * 4);
          *puVar2 = *puVar2 & uVar9;
          *pcVar1 = *pcVar1 + -1;
          if (*pcVar1 == '\0') {
            *(uint *)((int)block_info + 4) = *(uint *)((int)block_info + 4) & uVar9;
          }
        }
      }
      local_8 = local_8 + uVar6;
      *(undefined4 *)(*(int *)((int)puVar12 + uVar13 + 7) + 4) =
           *(undefined4 *)((int)puVar12 + uVar13 + 3);
      *(undefined4 *)(*(int *)((int)puVar12 + uVar13 + 3) + 8) =
           *(undefined4 *)((int)puVar12 + uVar13 + 7);
    }
    pvVar10 = (void *)(((int)local_8 >> 4) - 1);
    if ((void *)0x3f < pvVar10) {
      pvVar10 = (void *)0x3f;
    }
    pvVar11 = block_info;
    if ((uVar7 & 1) == 0) {
      puVar12 = (uint *)((int)puVar12 - uVar7);
      pvVar11 = (void *)(((int)uVar7 >> 4) - 1);
      if ((void *)0x3f < pvVar11) {
        pvVar11 = (void *)0x3f;
      }
      local_8 = local_8 + uVar7;
      pvVar10 = (void *)(((int)local_8 >> 4) - 1);
      if ((void *)0x3f < pvVar10) {
        pvVar10 = (void *)0x3f;
      }
      if (pvVar11 != pvVar10) {
        if (puVar12[1] == puVar12[2]) {
          if (pvVar11 < (void *)0x20) {
            uVar13 = ~(0x80000000U >> ((byte)pvVar11 & 0x1f));
            puVar2 = (uint *)(iVar5 + 0x44 + uVar14 * 4);
            *puVar2 = *puVar2 & uVar13;
            pcVar1 = (char *)((int)pvVar11 + iVar5 + 4);
            *pcVar1 = *pcVar1 + -1;
            if (*pcVar1 == '\0') {
                    // WARNING: Load size is inaccurate
              *(uint *)block_info = *block_info & uVar13;
            }
          }
          else {
            uVar13 = ~(0x80000000U >> ((byte)pvVar11 - 0x20 & 0x1f));
            puVar2 = (uint *)(iVar5 + 0xc4 + uVar14 * 4);
            *puVar2 = *puVar2 & uVar13;
            pcVar1 = (char *)((int)pvVar11 + iVar5 + 4);
            *pcVar1 = *pcVar1 + -1;
            if (*pcVar1 == '\0') {
              *(uint *)((int)block_info + 4) = *(uint *)((int)block_info + 4) & uVar13;
            }
          }
        }
        *(uint *)(puVar12[2] + 4) = puVar12[1];
        *(uint *)(puVar12[1] + 8) = puVar12[2];
      }
    }
    if (((uVar7 & 1) != 0) || (pvVar11 != pvVar10)) {
      puVar12[1] = piVar3[(int)pvVar10 * 2 + 1];
      puVar12[2] = (uint)(piVar3 + (int)pvVar10 * 2);
      (piVar3 + (int)pvVar10 * 2)[1] = (int)puVar12;
      *(uint **)(puVar12[1] + 8) = puVar12;
      if (puVar12[1] == puVar12[2]) {
        cVar4 = *(char *)((int)pvVar10 + iVar5 + 4);
        *(char *)((int)pvVar10 + iVar5 + 4) = cVar4 + '\x01';
        bVar8 = (byte)pvVar10;
        if (pvVar10 < (void *)0x20) {
          if (cVar4 == '\0') {
                    // WARNING: Load size is inaccurate
            *(uint *)block_info = *block_info | 0x80000000U >> (bVar8 & 0x1f);
          }
          puVar2 = (uint *)(iVar5 + 0x44 + uVar14 * 4);
          *puVar2 = *puVar2 | 0x80000000U >> (bVar8 & 0x1f);
        }
        else {
          if (cVar4 == '\0') {
            *(uint *)((int)block_info + 4) =
                 *(uint *)((int)block_info + 4) | 0x80000000U >> (bVar8 - 0x20 & 0x1f);
          }
          puVar2 = (uint *)(iVar5 + 0xc4 + uVar14 * 4);
          *puVar2 = *puVar2 | 0x80000000U >> (bVar8 - 0x20 & 0x1f);
        }
      }
    }
    *puVar12 = local_8;
    *(uint *)((local_8 - 4) + (int)puVar12) = local_8;
    *piVar3 = *piVar3 + -1;
    if (*piVar3 == 0) {
      if (DAT_1176643c != (void *)0x0) {
        VirtualFree((LPVOID)(DAT_11766434 * 0x8000 + *(int *)((int)DAT_1176643c + 0xc)),0x8000,
                    0x4000);
        *(uint *)((int)DAT_1176643c + 8U) =
             *(uint *)((int)DAT_1176643c + 8U) | 0x80000000U >> ((byte)DAT_11766434 & 0x1f);
        *(undefined4 *)(*(int *)((int)DAT_1176643c + 0x10) + 0xc4 + DAT_11766434 * 4) = 0;
        pcVar1 = (char *)(*(int *)((int)DAT_1176643c + 0x10) + 0x43);
        *pcVar1 = *pcVar1 + -1;
        if (*(char *)(*(int *)((int)DAT_1176643c + 0x10) + 0x43) == '\0') {
          *(uint *)((int)DAT_1176643c + 4U) = *(uint *)((int)DAT_1176643c + 4U) & 0xfffffffe;
        }
        if (*(int *)((int)DAT_1176643c + 8) == -1) {
          VirtualFree(*(LPVOID *)((int)DAT_1176643c + 0xc),0,0x8000);
          HeapFree(DAT_1176644c,0,*(LPVOID *)((int)DAT_1176643c + 0x10));
          memcpy_internal(DAT_1176643c,(int)DAT_1176643c + 0x14,
                          (DAT_11766440 * 0x14 - (int)DAT_1176643c) + -0x14 + DAT_11766444);
          DAT_11766440 = DAT_11766440 + -1;
          if (DAT_1176643c < block_info) {
            block_info = (void *)((int)block_info + -0x14);
          }
          DAT_11766438 = DAT_11766444;
        }
      }
      DAT_1176643c = block_info;
      DAT_11766434 = uVar14;
    }
  }
  return;
}



// Setting prototype: void *heap_management_9(void *size_info)

int * heap_management_9(uint *size_info)

{
  char *pcVar1;
  int *piVar2;
  char cVar3;
  int *piVar4;
  byte bVar5;
  uint uVar6;
  int iVar7;
  uint *puVar8;
  int iVar9;
  int *piVar10;
  uint *puVar11;
  uint *puVar12;
  uint uVar13;
  int iVar14;
  uint local_10;
  uint local_c;
  int local_8;
  
                    // 
                    // Manages heap, likely allocating a block of memory of a specific size.
                    // 
                    // Parameters:
                    //   size_info: Pointer to information about the size to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL on failure.
                    // 
  puVar8 = DAT_11766444 + DAT_11766440 * 5;
  uVar6 = (int)size_info + 0x17U & 0xfffffff0;
  iVar7 = ((int)((int)size_info + 0x17U) >> 4) + -1;
  bVar5 = (byte)iVar7;
  if (iVar7 < 0x20) {
    local_10 = 0xffffffff >> (bVar5 & 0x1f);
    local_c = 0xffffffff;
  }
  else {
    local_c = 0xffffffff >> (bVar5 - 0x20 & 0x1f);
    local_10 = 0;
  }
  size_info = DAT_11766438;
  if (DAT_11766438 < puVar8) {
    do {
      if ((size_info[1] & local_c) != 0 || (*size_info & local_10) != 0) break;
      size_info = size_info + 5;
    } while (size_info < puVar8);
  }
  puVar11 = DAT_11766444;
  if (size_info == puVar8) {
    for (; (puVar11 < DAT_11766438 && ((puVar11[1] & local_c) == 0 && (*puVar11 & local_10) == 0));
        puVar11 = puVar11 + 5) {
    }
    size_info = puVar11;
    if (puVar11 == DAT_11766438) {
      for (; (puVar11 < puVar8 && (puVar11[2] == 0)); puVar11 = puVar11 + 5) {
      }
      puVar12 = DAT_11766444;
      size_info = puVar11;
      if (puVar11 == puVar8) {
        for (; (puVar12 < DAT_11766438 && (puVar12[2] == 0)); puVar12 = puVar12 + 5) {
        }
        size_info = puVar12;
        if ((puVar12 == DAT_11766438) &&
           (size_info = (uint *)heap_management_10(), size_info == (uint *)0x0)) {
          return (int *)0x0;
        }
      }
      iVar7 = heap_management_11(size_info);
      *(int *)size_info[4] = iVar7;
      if (*(int *)size_info[4] == -1) {
        return (int *)0x0;
      }
    }
  }
  piVar4 = (int *)size_info[4];
  local_8 = *piVar4;
  if ((local_8 == -1) ||
     ((piVar4[local_8 + 0x31] & local_c) == 0 && (piVar4[local_8 + 0x11] & local_10) == 0)) {
    local_8 = 0;
    puVar8 = (uint *)(piVar4 + 0x11);
    if ((piVar4[0x31] & local_c) == 0 && (piVar4[0x11] & local_10) == 0) {
      do {
        puVar11 = puVar8 + 0x21;
        local_8 = local_8 + 1;
        puVar8 = puVar8 + 1;
      } while ((*puVar11 & local_c) == 0 && (local_10 & *puVar8) == 0);
    }
  }
  iVar7 = 0;
  piVar2 = piVar4 + local_8 * 0x81 + 0x51;
  local_10 = piVar4[local_8 + 0x11] & local_10;
  if (local_10 == 0) {
    local_10 = piVar4[local_8 + 0x31] & local_c;
    iVar7 = 0x20;
  }
  for (; -1 < (int)local_10; local_10 = local_10 << 1) {
    iVar7 = iVar7 + 1;
  }
  piVar10 = (int *)piVar2[iVar7 * 2 + 1];
  iVar9 = *piVar10 - uVar6;
  iVar14 = (iVar9 >> 4) + -1;
  if (0x3f < iVar14) {
    iVar14 = 0x3f;
  }
  DAT_11766438 = size_info;
  if (iVar14 != iVar7) {
    if (piVar10[1] == piVar10[2]) {
      if (iVar7 < 0x20) {
        pcVar1 = (char *)((int)piVar4 + iVar7 + 4);
        uVar13 = ~(0x80000000U >> ((byte)iVar7 & 0x1f));
        piVar4[local_8 + 0x11] = uVar13 & piVar4[local_8 + 0x11];
        *pcVar1 = *pcVar1 + -1;
        if (*pcVar1 == '\0') {
          *size_info = *size_info & uVar13;
        }
      }
      else {
        pcVar1 = (char *)((int)piVar4 + iVar7 + 4);
        uVar13 = ~(0x80000000U >> ((byte)iVar7 - 0x20 & 0x1f));
        piVar4[local_8 + 0x31] = piVar4[local_8 + 0x31] & uVar13;
        *pcVar1 = *pcVar1 + -1;
        if (*pcVar1 == '\0') {
          size_info[1] = size_info[1] & uVar13;
        }
      }
    }
    *(int *)(piVar10[2] + 4) = piVar10[1];
    *(int *)(piVar10[1] + 8) = piVar10[2];
    if (iVar9 == 0) goto LAB_1001db2f;
    piVar10[1] = piVar2[iVar14 * 2 + 1];
    piVar10[2] = (int)(piVar2 + iVar14 * 2);
    (piVar2 + iVar14 * 2)[1] = (int)piVar10;
    *(int **)(piVar10[1] + 8) = piVar10;
    if (piVar10[1] == piVar10[2]) {
      cVar3 = *(char *)(iVar14 + 4 + (int)piVar4);
      bVar5 = (byte)iVar14;
      if (iVar14 < 0x20) {
        *(char *)(iVar14 + 4 + (int)piVar4) = cVar3 + '\x01';
        if (cVar3 == '\0') {
          *size_info = *size_info | 0x80000000U >> (bVar5 & 0x1f);
        }
        piVar4[local_8 + 0x11] = piVar4[local_8 + 0x11] | 0x80000000U >> (bVar5 & 0x1f);
      }
      else {
        *(char *)(iVar14 + 4 + (int)piVar4) = cVar3 + '\x01';
        if (cVar3 == '\0') {
          size_info[1] = size_info[1] | 0x80000000U >> (bVar5 - 0x20 & 0x1f);
        }
        piVar4[local_8 + 0x31] = piVar4[local_8 + 0x31] | 0x80000000U >> (bVar5 - 0x20 & 0x1f);
      }
    }
  }
  if (iVar9 != 0) {
    *piVar10 = iVar9;
    *(int *)(iVar9 + -4 + (int)piVar10) = iVar9;
  }
LAB_1001db2f:
  piVar10 = (int *)((int)piVar10 + iVar9);
  *piVar10 = uVar6 + 1;
  *(uint *)((int)piVar10 + (uVar6 - 4)) = uVar6 + 1;
  iVar7 = *piVar2;
  *piVar2 = iVar7 + 1;
  if (((iVar7 == 0) && (size_info == DAT_1176643c)) && (local_8 == DAT_11766434)) {
    DAT_1176643c = (uint *)0x0;
  }
  *piVar4 = local_8;
  return piVar10 + 1;
}



// Setting prototype: void *heap_management_10(void)

undefined4 * heap_management_10(void)

{
  undefined4 *puVar1;
  LPVOID pvVar2;
  
                    // 
                    // Manages heap, likely allocating new memory regions or extending existing
                    // ones.
                    // 
                    // Return values:
                    //   A pointer to the newly allocated memory region, or NULL on failure.
                    // 
  if (DAT_11766440 == DAT_11766430) {
    pvVar2 = HeapReAlloc(DAT_1176644c,0,DAT_11766444,(DAT_11766430 * 5 + 0x50) * 4);
    if (pvVar2 == (LPVOID)0x0) {
      return (undefined4 *)0x0;
    }
    DAT_11766430 = DAT_11766430 + 0x10;
    DAT_11766444 = pvVar2;
  }
  puVar1 = (undefined4 *)((int)DAT_11766444 + DAT_11766440 * 0x14);
  pvVar2 = HeapAlloc(DAT_1176644c,8,0x41c4);
  puVar1[4] = pvVar2;
  if (pvVar2 != (LPVOID)0x0) {
    pvVar2 = VirtualAlloc((LPVOID)0x0,0x100000,0x2000,4);
    puVar1[3] = pvVar2;
    if (pvVar2 != (LPVOID)0x0) {
      puVar1[2] = 0xffffffff;
      *puVar1 = 0;
      puVar1[1] = 0;
      DAT_11766440 = DAT_11766440 + 1;
      *(undefined4 *)puVar1[4] = 0xffffffff;
      return puVar1;
    }
    HeapFree(DAT_1176644c,0,(LPVOID)puVar1[4]);
  }
  return (undefined4 *)0x0;
}



// Setting prototype: int heap_management_11(void *heap_info)

int heap_management_11(void *heap_info)

{
  int *piVar1;
  char cVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  LPVOID pvVar6;
  int *piVar7;
  int iVar8;
  int iVar9;
  int *lpAddress;
  
                    // 
                    // Manages heap, likely allocating a new page or block within the heap.
                    // 
                    // Parameters:
                    //   heap_info: Pointer to the heap information structure.
                    // 
                    // Return values:
                    //   A status code indicating success or failure.
                    // 
  iVar3 = *(int *)((int)heap_info + 0x10);
  iVar9 = 0;
  for (iVar4 = *(int *)((int)heap_info + 8); -1 < iVar4; iVar4 = iVar4 << 1) {
    iVar9 = iVar9 + 1;
  }
  iVar8 = 0x3f;
  iVar4 = iVar9 * 0x204 + 0x144 + iVar3;
  iVar5 = iVar4;
  do {
    *(int *)(iVar5 + 8) = iVar5;
    *(int *)(iVar5 + 4) = iVar5;
    iVar5 = iVar5 + 8;
    iVar8 = iVar8 + -1;
  } while (iVar8 != 0);
  lpAddress = (int *)(iVar9 * 0x8000 + *(int *)((int)heap_info + 0xc));
  pvVar6 = VirtualAlloc(lpAddress,0x8000,0x1000,4);
  if (pvVar6 == (LPVOID)0x0) {
    iVar9 = -1;
  }
  else {
    if (lpAddress <= lpAddress + 0x1c00) {
      piVar7 = lpAddress + 4;
      do {
        piVar7[-2] = -1;
        piVar7[0x3fb] = -1;
        piVar7[-1] = 0xff0;
        *piVar7 = (int)(piVar7 + 0x3ff);
        piVar7[1] = (int)(piVar7 + -0x401);
        piVar7[0x3fa] = 0xff0;
        piVar1 = piVar7 + 0x3fc;
        piVar7 = piVar7 + 0x400;
      } while (piVar1 <= lpAddress + 0x1c00);
    }
    *(int **)(iVar4 + 0x1fc) = lpAddress + 3;
    lpAddress[5] = iVar4 + 0x1f8;
    *(int **)(iVar4 + 0x200) = lpAddress + 0x1c03;
    lpAddress[0x1c04] = iVar4 + 0x1f8;
    *(undefined4 *)(iVar3 + 0x44 + iVar9 * 4) = 0;
    *(undefined4 *)(iVar3 + 0xc4 + iVar9 * 4) = 1;
    cVar2 = *(char *)(iVar3 + 0x43);
    *(char *)(iVar3 + 0x43) = cVar2 + '\x01';
    if (cVar2 == '\0') {
      *(uint *)((int)heap_info + 4) = *(uint *)((int)heap_info + 4) | 1;
    }
    *(uint *)((int)heap_info + 8) =
         *(uint *)((int)heap_info + 8) & ~(0x80000000U >> ((byte)iVar9 & 0x1f));
  }
  return iVar9;
}



// Setting prototype: int heap_management_12(void *heap_info, void *mem_ptr, uint32_t new_size)

int heap_management_12(void *heap_info,void *mem_ptr,uint32_t new_size)

{
  uint32_t uVar1;
  char *pcVar2;
  int *piVar3;
  uint32_t *puVar4;
  int iVar5;
  char cVar6;
  int iVar7;
  int iVar8;
  uint *puVar9;
  byte bVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint local_c;
  
                    // 
                    // Manages heap, likely reallocating or resizing a memory block.
                    // 
                    // Parameters:
                    //   heap_info: Pointer to the heap information structure.
                    //   mem_ptr: Pointer to the memory block to resize.
                    //   new_size: The new size for the memory block.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
  iVar7 = *(int *)((int)heap_info + 0x10);
  uVar14 = new_size + 0x17 & 0xfffffff0;
  uVar12 = (uint)((int)mem_ptr - *(int *)((int)heap_info + 0xc)) >> 0xf;
  iVar5 = uVar12 * 0x204 + 0x144 + iVar7;
  iVar8 = *(int *)((int)mem_ptr + -4);
  iVar11 = iVar8 + -1;
  uVar15 = *(uint *)(iVar8 + -5 + (int)mem_ptr);
  if (iVar11 < (int)uVar14) {
    if (((uVar15 & 1) != 0) || ((int)(uVar15 + iVar11) < (int)uVar14)) {
      return 0;
    }
    local_c = ((int)uVar15 >> 4) - 1;
    if (0x3f < local_c) {
      local_c = 0x3f;
    }
    if (*(int *)((int)mem_ptr + iVar8 + -1) == *(int *)((int)mem_ptr + iVar8 + 3)) {
      if (local_c < 0x20) {
        pcVar2 = (char *)(local_c + 4 + iVar7);
        uVar13 = ~(0x80000000U >> ((byte)local_c & 0x1f));
        puVar9 = (uint *)(iVar7 + 0x44 + uVar12 * 4);
        *puVar9 = *puVar9 & uVar13;
        *pcVar2 = *pcVar2 + -1;
        if (*pcVar2 == '\0') {
                    // WARNING: Load size is inaccurate
          *(uint *)heap_info = *heap_info & uVar13;
        }
      }
      else {
        pcVar2 = (char *)(local_c + 4 + iVar7);
        uVar13 = ~(0x80000000U >> ((byte)local_c - 0x20 & 0x1f));
        puVar9 = (uint *)(iVar7 + 0xc4 + uVar12 * 4);
        *puVar9 = *puVar9 & uVar13;
        *pcVar2 = *pcVar2 + -1;
        if (*pcVar2 == '\0') {
          *(uint *)((int)heap_info + 4) = *(uint *)((int)heap_info + 4) & uVar13;
        }
      }
    }
    *(undefined4 *)(*(int *)((int)mem_ptr + iVar8 + 3) + 4) =
         *(undefined4 *)((int)mem_ptr + iVar8 + -1);
    *(undefined4 *)(*(int *)((int)mem_ptr + iVar8 + -1) + 8) =
         *(undefined4 *)((int)mem_ptr + iVar8 + 3);
    iVar8 = uVar15 + (iVar11 - uVar14);
    if (0 < iVar8) {
      uVar15 = (iVar8 >> 4) - 1;
      iVar11 = (int)mem_ptr + (uVar14 - 4);
      if (0x3f < uVar15) {
        uVar15 = 0x3f;
      }
      iVar5 = iVar5 + uVar15 * 8;
      *(undefined4 *)(iVar11 + 4) = *(undefined4 *)(iVar5 + 4);
      *(int *)(iVar11 + 8) = iVar5;
      *(int *)(iVar5 + 4) = iVar11;
      *(int *)(*(int *)(iVar11 + 4) + 8) = iVar11;
      if (*(int *)(iVar11 + 4) == *(int *)(iVar11 + 8)) {
        cVar6 = *(char *)(uVar15 + 4 + iVar7);
        *(char *)(uVar15 + 4 + iVar7) = cVar6 + '\x01';
        bVar10 = (byte)uVar15;
        if (uVar15 < 0x20) {
          if (cVar6 == '\0') {
                    // WARNING: Load size is inaccurate
            *(uint *)heap_info = *heap_info | 0x80000000U >> (bVar10 & 0x1f);
          }
          puVar9 = (uint *)(iVar7 + 0x44 + uVar12 * 4);
        }
        else {
          if (cVar6 == '\0') {
            *(uint *)((int)heap_info + 4) =
                 *(uint *)((int)heap_info + 4) | 0x80000000U >> (bVar10 - 0x20 & 0x1f);
          }
          puVar9 = (uint *)(iVar7 + 0xc4 + uVar12 * 4);
          bVar10 = bVar10 - 0x20;
        }
        *puVar9 = *puVar9 | 0x80000000U >> (bVar10 & 0x1f);
      }
      piVar3 = (int *)((int)mem_ptr + (uVar14 - 4));
      *piVar3 = iVar8;
      *(int *)(iVar8 + -4 + (int)piVar3) = iVar8;
    }
    *(uint *)((int)mem_ptr + -4) = uVar14 + 1;
    *(uint *)((int)mem_ptr + (uVar14 - 8)) = uVar14 + 1;
  }
  else if ((int)uVar14 < iVar11) {
    new_size = iVar11 - uVar14;
    *(uint *)((int)mem_ptr + -4) = uVar14 + 1;
    puVar4 = (uint32_t *)((int)mem_ptr + (uVar14 - 4));
    uVar13 = ((int)new_size >> 4) - 1;
    puVar4[-1] = uVar14 + 1;
    if (0x3f < uVar13) {
      uVar13 = 0x3f;
    }
    if ((uVar15 & 1) == 0) {
      uVar14 = ((int)uVar15 >> 4) - 1;
      if (0x3f < uVar14) {
        uVar14 = 0x3f;
      }
      if (*(int *)((int)mem_ptr + iVar8 + -1) == *(int *)((int)mem_ptr + iVar8 + 3)) {
        if (uVar14 < 0x20) {
          pcVar2 = (char *)(uVar14 + 4 + iVar7);
          uVar14 = ~(0x80000000U >> ((byte)uVar14 & 0x1f));
          puVar9 = (uint *)(iVar7 + 0x44 + uVar12 * 4);
          *puVar9 = *puVar9 & uVar14;
          *pcVar2 = *pcVar2 + -1;
          if (*pcVar2 == '\0') {
                    // WARNING: Load size is inaccurate
            *(uint *)heap_info = *heap_info & uVar14;
          }
        }
        else {
          pcVar2 = (char *)(uVar14 + 4 + iVar7);
          uVar14 = ~(0x80000000U >> ((byte)uVar14 - 0x20 & 0x1f));
          puVar9 = (uint *)(iVar7 + 0xc4 + uVar12 * 4);
          *puVar9 = *puVar9 & uVar14;
          *pcVar2 = *pcVar2 + -1;
          if (*pcVar2 == '\0') {
            *(uint *)((int)heap_info + 4) = *(uint *)((int)heap_info + 4) & uVar14;
          }
        }
      }
      *(undefined4 *)(*(int *)((int)mem_ptr + iVar8 + 3) + 4) =
           *(undefined4 *)((int)mem_ptr + iVar8 + -1);
      *(undefined4 *)(*(int *)((int)mem_ptr + iVar8 + -1) + 8) =
           *(undefined4 *)((int)mem_ptr + iVar8 + 3);
      new_size = new_size + uVar15;
      uVar13 = ((int)new_size >> 4) - 1;
      if (0x3f < uVar13) {
        uVar13 = 0x3f;
      }
    }
    uVar1 = iVar5 + uVar13 * 8;
    puVar4[1] = *(uint32_t *)(iVar5 + 4 + uVar13 * 8);
    puVar4[2] = uVar1;
    *(uint32_t **)(uVar1 + 4) = puVar4;
    *(uint32_t **)(puVar4[1] + 8) = puVar4;
    if (puVar4[1] == puVar4[2]) {
      cVar6 = *(char *)(uVar13 + 4 + iVar7);
      *(char *)(uVar13 + 4 + iVar7) = cVar6 + '\x01';
      bVar10 = (byte)uVar13;
      if (uVar13 < 0x20) {
        if (cVar6 == '\0') {
                    // WARNING: Load size is inaccurate
          *(uint *)heap_info = *heap_info | 0x80000000U >> (bVar10 & 0x1f);
        }
        puVar9 = (uint *)(iVar7 + 0x44 + uVar12 * 4);
      }
      else {
        if (cVar6 == '\0') {
          *(uint *)((int)heap_info + 4) =
               *(uint *)((int)heap_info + 4) | 0x80000000U >> (bVar10 - 0x20 & 0x1f);
        }
        puVar9 = (uint *)(iVar7 + 0xc4 + uVar12 * 4);
        bVar10 = bVar10 - 0x20;
      }
      *puVar9 = *puVar9 | 0x80000000U >> (bVar10 & 0x1f);
    }
    *puVar4 = new_size;
    *(uint32_t *)((new_size - 4) + (int)puVar4) = new_size;
  }
  return 1;
}



// Setting prototype: void *heap_management_13(void)

undefined ** heap_management_13(void)

{
  bool bVar1;
  int *lpAddress;
  LPVOID pvVar2;
  undefined **ppuVar3;
  int iVar4;
  undefined **lpMem;
  
                    // 
                    // Manages heap, likely allocating and initializing memory for a custom heap
                    // implementation.
                    // 
                    // Return values:
                    //   A pointer to the allocated heap structure, or NULL on failure.
                    // 
  if (DAT_10031b88 == -1) {
    lpMem = &PTR_LOOP_10031b78;
  }
  else {
    lpMem = (undefined **)HeapAlloc(DAT_1176644c,0,0x2020);
    if (lpMem == (undefined **)0x0) {
      return (undefined **)0x0;
    }
  }
  lpAddress = (int *)VirtualAlloc((LPVOID)0x0,0x400000,0x2000,4);
  if (lpAddress != (int *)0x0) {
    pvVar2 = VirtualAlloc(lpAddress,0x10000,0x1000,4);
    if (pvVar2 != (LPVOID)0x0) {
      if (lpMem == &PTR_LOOP_10031b78) {
        if (PTR_LOOP_10031b78 == (undefined *)0x0) {
          PTR_LOOP_10031b78 = (undefined *)&PTR_LOOP_10031b78;
        }
        if (PTR_LOOP_10031b7c == (undefined *)0x0) {
          PTR_LOOP_10031b7c = (undefined *)&PTR_LOOP_10031b78;
        }
      }
      else {
        *lpMem = (undefined *)&PTR_LOOP_10031b78;
        lpMem[1] = PTR_LOOP_10031b7c;
        PTR_LOOP_10031b7c = (undefined *)lpMem;
        *(undefined ***)lpMem[1] = lpMem;
      }
      lpMem[5] = (undefined *)(lpAddress + 0x100000);
      ppuVar3 = lpMem + 6;
      lpMem[3] = (undefined *)(lpMem + 0x26);
      lpMem[4] = (undefined *)lpAddress;
      lpMem[2] = (undefined *)ppuVar3;
      iVar4 = 0;
      do {
        bVar1 = 0xf < iVar4;
        iVar4 = iVar4 + 1;
        *ppuVar3 = (undefined *)((bVar1 - 1 & 0xf1) - 1);
        ppuVar3[1] = (undefined *)0xf1;
        ppuVar3 = ppuVar3 + 2;
      } while (iVar4 < 0x400);
      _memset(lpAddress,0,0x10000);
      for (; lpAddress < lpMem[4] + 0x10000; lpAddress = lpAddress + 0x400) {
        *(undefined1 *)(lpAddress + 0x3e) = 0xff;
        *lpAddress = (int)(lpAddress + 2);
        lpAddress[1] = 0xf0;
      }
      return lpMem;
    }
    VirtualFree(lpAddress,0,0x8000);
  }
  if (lpMem != &PTR_LOOP_10031b78) {
    HeapFree(DAT_1176644c,0,lpMem);
  }
  return (undefined **)0x0;
}



// Setting prototype: void heap_management_14(void *heap_ptr)

void heap_management_14(void *heap_ptr)

{
                    // 
                    // Manages heap, likely deallocating a heap structure.
                    // 
                    // Parameters:
                    //   heap_ptr: Pointer to the heap structure to deallocate.
                    // 
  VirtualFree(*(LPVOID *)((int)heap_ptr + 0x10),0,0x8000);
  if (PTR_LOOP_10033b98 == (undefined *)heap_ptr) {
    PTR_LOOP_10033b98 = *(undefined **)((int)heap_ptr + 4);
  }
  if ((undefined **)heap_ptr != &PTR_LOOP_10031b78) {
                    // WARNING: Load size is inaccurate
    **(undefined4 **)((int)heap_ptr + 4) = *heap_ptr;
                    // WARNING: Load size is inaccurate
    *(undefined4 *)(*heap_ptr + 4) = *(undefined4 *)((int)heap_ptr + 4);
    HeapFree(DAT_1176644c,0,heap_ptr);
    return;
  }
  DAT_10031b88 = 0xffffffff;
  return;
}



// Setting prototype: void heap_management_15(int count)

void heap_management_15(int count)

{
  BOOL BVar1;
  int *piVar2;
  int iVar3;
  undefined *heap_ptr;
  undefined *puVar4;
  int local_8;
  
                    // 
                    // Manages heap, likely freeing unused pages or blocks within the heap.
                    // 
                    // Parameters:
                    //   count: The number of blocks to free.
                    // 
  heap_ptr = PTR_LOOP_10031b7c;
  do {
    puVar4 = heap_ptr;
    if (*(int *)(heap_ptr + 0x10) != -1) {
      local_8 = 0;
      piVar2 = (int *)(heap_ptr + 0x2010);
      iVar3 = 0x3ff000;
      do {
        if (*piVar2 == 0xf0) {
          BVar1 = VirtualFree((LPVOID)(iVar3 + *(int *)(heap_ptr + 0x10)),0x1000,0x4000);
          if (BVar1 != 0) {
            *piVar2 = -1;
            DAT_100355a4 = DAT_100355a4 + -1;
            if ((*(int **)(heap_ptr + 0xc) == (int *)0x0) || (piVar2 < *(int **)(heap_ptr + 0xc))) {
              *(int **)(heap_ptr + 0xc) = piVar2;
            }
            local_8 = local_8 + 1;
            count = count + -1;
            if (count == 0) break;
          }
        }
        iVar3 = iVar3 + -0x1000;
        piVar2 = piVar2 + -2;
      } while (-1 < iVar3);
      puVar4 = *(undefined **)(heap_ptr + 4);
      if ((local_8 != 0) && (*(int *)(heap_ptr + 0x18) == -1)) {
        piVar2 = (int *)(heap_ptr + 0x20);
        iVar3 = 1;
        do {
          if (*piVar2 != -1) break;
          iVar3 = iVar3 + 1;
          piVar2 = piVar2 + 2;
        } while (iVar3 < 0x400);
        if (iVar3 == 0x400) {
          heap_management_14(heap_ptr);
        }
      }
    }
    if ((puVar4 == PTR_LOOP_10031b7c) || (heap_ptr = puVar4, count < 1)) {
      return;
    }
  } while( true );
}



// Setting prototype: int heap_management_16(void *mem_ptr, void **heap_info_ptr, uint32_t
// *page_base_ptr)

int heap_management_16(void *mem_ptr,void **heap_info_ptr,uint32_t *page_base_ptr)

{
  undefined **ppuVar1;
  uint uVar2;
  
                    // 
                    // Manages heap, likely retrieving information about a memory block within the
                    // heap.
                    // 
                    // Parameters:
                    //   mem_ptr: Pointer to the memory block.
                    //   heap_info_ptr: Pointer to store the heap information structure.
                    //   page_base_ptr: Pointer to store the base address of the memory page.
                    // 
                    // Return values:
                    //   A status code indicating success or failure.
                    // 
  ppuVar1 = &PTR_LOOP_10031b78;
  while ((mem_ptr <= ppuVar1[4] || (ppuVar1[5] <= mem_ptr))) {
    ppuVar1 = (undefined **)*ppuVar1;
    if (ppuVar1 == &PTR_LOOP_10031b78) {
      return 0;
    }
  }
  if (((uint)mem_ptr & 0xf) != 0) {
    return 0;
  }
  if (((uint)mem_ptr & 0xfff) < 0x100) {
    return 0;
  }
  *heap_info_ptr = ppuVar1;
  uVar2 = (uint)mem_ptr & 0xfffff000;
  *page_base_ptr = uVar2;
  return ((int)((int)mem_ptr + (-0x100 - uVar2)) >> 4) + 8 + uVar2;
}



// Setting prototype: void heap_management_17(void *heap_info, uint32_t page_base, void *mem_ptr)

void heap_management_17(void *heap_info,uint32_t page_base,void *mem_ptr)

{
  int *piVar1;
  
                    // 
                    // Manages heap, likely marking a memory block as free and potentially
                    // consolidating free blocks.
                    // 
                    // Parameters:
                    //   heap_info: Pointer to the heap information structure.
                    //   page_base: The base address of the memory page.
                    //   mem_ptr: Pointer to the memory block to free.
                    // 
  piVar1 = (int *)((int)heap_info +
                  ((int)(page_base - *(int *)((int)heap_info + 0x10)) >> 0xc) * 8 + 0x18);
                    // WARNING: Load size is inaccurate
  *piVar1 = *piVar1 + (uint)*mem_ptr;
  *(undefined1 *)mem_ptr = 0;
  piVar1[1] = 0xf1;
  if ((*piVar1 == 0xf0) && (DAT_100355a4 = DAT_100355a4 + 1, DAT_100355a4 == 0x20)) {
    heap_management_15(0x10);
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// Setting prototype: void *heap_management_18(uint32_t size)

int * heap_management_18(uint size)

{
  int *piVar1;
  undefined **ppuVar2;
  int iVar3;
  int *piVar4;
  int *piVar5;
  undefined *puVar6;
  undefined **ppuVar7;
  int *piVar8;
  undefined **ppuVar9;
  int local_8;
  
                    // 
                    // Manages heap, likely allocating a memory block of a specific size.
                    // 
                    // Parameters:
                    //   size: The size of the memory block to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL on failure.
                    // 
  piVar8 = (int *)PTR_LOOP_10033b98;
  do {
    if (piVar8[4] != -1) {
      piVar5 = (int *)piVar8[2];
      iVar3 = ((int)piVar5 + (-0x18 - (int)piVar8) >> 3) * 0x1000 + piVar8[4];
      if (piVar5 < piVar8 + 0x806) {
        do {
          if (((int)size <= *piVar5) && (size < (uint)piVar5[1])) {
            piVar4 = (int *)heap_management_19(iVar3,*piVar5,size);
            if (piVar4 != (int *)0x0) goto LAB_1001e3d7;
            piVar5[1] = size;
          }
          piVar5 = piVar5 + 2;
          iVar3 = iVar3 + 0x1000;
        } while (piVar5 < piVar8 + 0x806);
      }
      piVar1 = (int *)piVar8[2];
      iVar3 = piVar8[4];
      for (piVar5 = piVar8 + 6; piVar5 < piVar1; piVar5 = piVar5 + 2) {
        if (((int)size <= *piVar5) && (size < (uint)piVar5[1])) {
          piVar4 = (int *)heap_management_19(iVar3,*piVar5,size);
          if (piVar4 != (int *)0x0) {
LAB_1001e3d7:
            PTR_LOOP_10033b98 = (undefined *)piVar8;
            *piVar5 = *piVar5 - size;
            piVar8[2] = (int)piVar5;
            return piVar4;
          }
          piVar5[1] = size;
        }
        iVar3 = iVar3 + 0x1000;
      }
    }
    piVar8 = (int *)*piVar8;
    if (piVar8 == (int *)PTR_LOOP_10033b98) {
      ppuVar9 = &PTR_LOOP_10031b78;
      while ((ppuVar9[4] == (undefined *)0xffffffff || (ppuVar9[3] == (undefined *)0x0))) {
        ppuVar9 = (undefined **)*ppuVar9;
        if (ppuVar9 == &PTR_LOOP_10031b78) {
          puVar6 = (undefined *)heap_management_13();
          if (puVar6 == (undefined *)0x0) {
            return (int *)0x0;
          }
          piVar8 = *(int **)(puVar6 + 0x10);
          *(char *)(piVar8 + 2) = (char)size;
          PTR_LOOP_10033b98 = puVar6;
          *piVar8 = (int)piVar8 + size + 8;
          piVar8[1] = 0xf0 - size;
          *(uint *)(puVar6 + 0x18) = *(int *)(puVar6 + 0x18) - (size & 0xff);
          return piVar8 + 0x40;
        }
      }
      ppuVar2 = (undefined **)ppuVar9[3];
      local_8 = 0;
      piVar8 = (int *)(ppuVar9[4] + ((int)ppuVar2 + (-0x18 - (int)ppuVar9) >> 3) * 0x1000);
      puVar6 = *ppuVar2;
      ppuVar7 = ppuVar2;
      for (; (puVar6 == (undefined *)0xffffffff && (local_8 < 0x10)); local_8 = local_8 + 1) {
        ppuVar7 = ppuVar7 + 2;
        puVar6 = *ppuVar7;
      }
      piVar5 = (int *)VirtualAlloc(piVar8,local_8 << 0xc,0x1000,4);
      if (piVar5 != piVar8) {
        return (int *)0x0;
      }
      _memset(piVar8,local_8 << 0xc,0);
      ppuVar7 = ppuVar2;
      if (0 < local_8) {
        piVar5 = piVar8 + 1;
        do {
          *(undefined1 *)(piVar5 + 0x3d) = 0xff;
          piVar5[-1] = (int)(piVar5 + 1);
          *piVar5 = 0xf0;
          *ppuVar7 = (undefined *)0xf0;
          ppuVar7[1] = (undefined *)0xf1;
          piVar5 = piVar5 + 0x400;
          ppuVar7 = ppuVar7 + 2;
          local_8 = local_8 + -1;
        } while (local_8 != 0);
      }
      for (; (ppuVar7 < ppuVar9 + 0x806 && (*ppuVar7 != (undefined *)0xffffffff));
          ppuVar7 = ppuVar7 + 2) {
      }
      PTR_LOOP_10033b98 = (undefined *)ppuVar9;
      ppuVar9[3] = (undefined *)(-(uint)(ppuVar7 < ppuVar9 + 0x806) & (uint)ppuVar7);
      *(char *)(piVar8 + 2) = (char)size;
      ppuVar9[2] = (undefined *)ppuVar2;
      *ppuVar2 = *ppuVar2 + -size;
      piVar8[1] = piVar8[1] - size;
      *piVar8 = (int)piVar8 + size + 8;
      return piVar8 + 0x40;
    }
  } while( true );
}



// Setting prototype: void *heap_management_19(void *block_info, uint32_t offset, uint32_t size)

int heap_management_19(int *block_info,uint offset,uint size)

{
  byte *pbVar1;
  byte *pbVar2;
  byte bVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  
                    // 
                    // Manages heap, likely allocating a block of memory within a larger block.
                    // 
                    // Parameters:
                    //   block_info: Pointer to the block information structure.
                    //   offset: The offset within the block to allocate from.
                    //   size: The size of the memory to allocate.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory, or NULL on failure.
                    // 
  pbVar2 = (byte *)*block_info;
  pbVar1 = (byte *)(block_info + 0x3e);
  bVar3 = (byte)size;
  if ((uint)block_info[1] < size) {
    pbVar6 = pbVar2;
    if (pbVar2[block_info[1]] != 0) {
      pbVar6 = pbVar2 + block_info[1];
    }
    while( true ) {
      while( true ) {
        if (pbVar1 <= pbVar6 + size) {
          pbVar6 = (byte *)(block_info + 2);
          while( true ) {
            while( true ) {
              if (pbVar2 <= pbVar6) {
                return 0;
              }
              if (pbVar1 <= pbVar6 + size) {
                return 0;
              }
              if (*pbVar6 == 0) break;
              pbVar6 = pbVar6 + *pbVar6;
            }
            uVar5 = 1;
            pbVar4 = pbVar6;
            while (pbVar4 = pbVar4 + 1, *pbVar4 == 0) {
              uVar5 = uVar5 + 1;
            }
            if (size <= uVar5) break;
            offset = offset - uVar5;
            pbVar6 = pbVar4;
            if (offset < size) {
              return 0;
            }
          }
          if (pbVar6 + size < pbVar1) {
            *block_info = (int)(pbVar6 + size);
            block_info[1] = uVar5 - size;
          }
          else {
            block_info[1] = 0;
            *block_info = (int)(block_info + 2);
          }
          *pbVar6 = bVar3;
          pbVar2 = pbVar6 + 8;
          goto LAB_1001e627;
        }
        if (*pbVar6 == 0) break;
        pbVar6 = pbVar6 + *pbVar6;
      }
      uVar5 = 1;
      pbVar4 = pbVar6;
      while (pbVar4 = pbVar4 + 1, *pbVar4 == 0) {
        uVar5 = uVar5 + 1;
      }
      if (size <= uVar5) break;
      if (pbVar6 == pbVar2) {
        block_info[1] = uVar5;
        pbVar6 = pbVar4;
      }
      else {
        offset = offset - uVar5;
        pbVar6 = pbVar4;
        if (offset < size) {
          return 0;
        }
      }
    }
    if (pbVar6 + size < pbVar1) {
      *block_info = (int)(pbVar6 + size);
      block_info[1] = uVar5 - size;
    }
    else {
      block_info[1] = 0;
      *block_info = (int)(block_info + 2);
    }
    *pbVar6 = bVar3;
    pbVar2 = pbVar6 + 8;
  }
  else {
    *pbVar2 = bVar3;
    if (pbVar2 + size < pbVar1) {
      *block_info = *block_info + size;
      block_info[1] = block_info[1] - size;
    }
    else {
      block_info[1] = 0;
      *block_info = (int)(block_info + 2);
    }
    pbVar2 = pbVar2 + 8;
  }
LAB_1001e627:
  return (int)pbVar2 * 0x10 + (int)block_info * -0xf;
}



// Setting prototype: int heap_management_20(void *heap_info, void *page_info, void *mem_ptr,
// uint32_t new_size)

int heap_management_20(void *heap_info,void *page_info,void *mem_ptr,uint32_t new_size)

{
  char *pcVar1;
  int *piVar2;
  char cVar3;
  char *pcVar4;
  int iVar5;
  uint uVar6;
  
                    // 
                    // Manages heap, likely resizing a memory block within a page.
                    // 
                    // Parameters:
                    //   heap_info: Pointer to the heap information structure.
                    //   page_info: Pointer to the page information structure.
                    //   mem_ptr: Pointer to the memory block to resize.
                    //   new_size: The new size for the memory block.
                    // 
                    // Return values:
                    //   1 if successful, 0 otherwise.
                    // 
                    // WARNING: Load size is inaccurate
  uVar6 = (uint)*mem_ptr;
  piVar2 = (int *)((int)heap_info +
                  ((int)page_info - *(int *)((int)heap_info + 0x10) >> 0xc) * 8 + 0x18);
  if (new_size < uVar6) {
    *(undefined1 *)mem_ptr = (undefined1)new_size;
    *piVar2 = *piVar2 + (uVar6 - new_size);
    piVar2[1] = 0xf1;
  }
  else {
    if (new_size <= uVar6) {
      return 0;
    }
    pcVar1 = (char *)((int)mem_ptr + new_size);
    if ((char *)((int)page_info + 0xf8U) < pcVar1) {
      return 0;
    }
    for (pcVar4 = (char *)(uVar6 + (int)mem_ptr); (pcVar4 < pcVar1 && (*pcVar4 == '\0'));
        pcVar4 = pcVar4 + 1) {
    }
    if (pcVar4 != pcVar1) {
      return 0;
    }
    *(undefined1 *)mem_ptr = (undefined1)new_size;
                    // WARNING: Load size is inaccurate
    if ((mem_ptr <= *page_info) && (*page_info < pcVar1)) {
      if (pcVar1 < (char *)((int)page_info + 0xf8U)) {
        iVar5 = 0;
        *(char **)page_info = pcVar1;
        cVar3 = *pcVar1;
        while (cVar3 == '\0') {
          iVar5 = iVar5 + 1;
          cVar3 = pcVar1[iVar5];
        }
        *(int *)((int)page_info + 4) = iVar5;
      }
      else {
        *(undefined4 *)((int)page_info + 4) = 0;
        *(int *)page_info = (int)page_info + 8;
      }
    }
    *piVar2 = *piVar2 + (uVar6 - new_size);
  }
  return 1;
}



// Setting prototype: void __global_unwind2(void *target_frame)

void __global_unwind2(void *target_frame)

{
                    // 
                    // Performs a global unwind operation, typically used for exception handling.
                    // 
                    // Parameters:
                    //   target_frame: The target frame to unwind to.
                    // 
  RtlUnwind(target_frame,(PVOID)0x1001e6fc,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
  return;
}



// Setting prototype: void __local_unwind2(void *frame_info, int target_state)

void __local_unwind2(void *frame_info,int target_state)

{
  int iVar1;
  int iVar2;
  void *pvStack_1c;
  undefined1 *puStack_18;
  undefined4 local_14;
  void *pvStack_10;
  
                    // 
                    // Performs a local unwind operation, typically used for exception handling
                    // within a function.
                    // 
                    // Parameters:
                    //   frame_info: Pointer to the frame information.
                    //   target_state: The target state to unwind to.
                    // 
  pvStack_10 = frame_info;
  puStack_18 = &LAB_1001e704;
  pvStack_1c = ExceptionList;
  ExceptionList = &pvStack_1c;
  while( true ) {
    iVar1 = *(int *)((int)frame_info + 8);
    iVar2 = *(int *)((int)frame_info + 0xc);
    if ((iVar2 == -1) || (iVar2 == target_state)) break;
    local_14 = *(undefined4 *)(iVar1 + iVar2 * 0xc);
    *(undefined4 *)((int)frame_info + 0xc) = local_14;
    if (*(int *)(iVar1 + 4 + iVar2 * 0xc) == 0) {
      exception_handler();
      (**(code **)(iVar1 + 8 + iVar2 * 0xc))();
    }
  }
  ExceptionList = pvStack_1c;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void exception_handler(void)

void exception_handler(void)

{
  undefined4 in_EAX;
  int unaff_EBP;
  
                    // 
                    // Exception handler function, likely stores exception context information.
                    // 
  DAT_10033ba8 = *(undefined4 *)(unaff_EBP + 8);
  DAT_10033ba4 = in_EAX;
  DAT_10033bac = unaff_EBP;
  return;
}



// Setting prototype: void exception_handler_2(void *exception_info)

void exception_handler_2(void *exception_info)

{
                    // 
                    // Exception handler function, likely dispatches to a local unwind based on
                    // exception information.
                    // 
                    // Parameters:
                    //   exception_info: Pointer to the exception information structure.
                    // 
  __local_unwind2(*(void **)((int)exception_info + 0x18),*(int *)((int)exception_info + 0x1c));
  return;
}



// Setting prototype: uint32_t file_write_11(uint32_t file_descriptor, void *buffer, uint32_t count)

uint32_t file_write_11(uint32_t file_descriptor,void *buffer,uint32_t count)

{
  uint32_t uVar1;
  undefined4 *puVar2;
  
                    // 
                    // Writes data to a file using a file descriptor.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   buffer: Pointer to the buffer containing the data to write.
                    //   count: The number of bytes to write.
                    // 
                    // Return values:
                    //   The number of bytes written, or -1 on error.
                    // 
  if ((file_descriptor < DAT_11766560) &&
     ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + (file_descriptor & 0x1f) * 0x24) &
      1) != 0)) {
    file_management_13(file_descriptor);
    uVar1 = file_write_12(file_descriptor,buffer,count);
    file_management_14(file_descriptor);
    return uVar1;
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 9;
  puVar2 = (undefined4 *)get_last_error_2();
  *puVar2 = 0;
  return 0xffffffff;
}



// Setting prototype: int file_write_12(uint32_t file_descriptor, void *buffer, uint32_t count)

int file_write_12(uint32_t file_descriptor,void *buffer,uint32_t count)

{
  int *piVar1;
  char *pcVar2;
  char cVar3;
  int iVar4;
  char *pcVar5;
  BOOL BVar6;
  undefined4 *puVar7;
  char local_418 [1028];
  int local_14;
  DWORD local_10;
  DWORD local_c;
  char *local_8;
  
                    // 
                    // Writes data to a file using a file descriptor.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   buffer: Pointer to the buffer containing the data to write.
                    //   count: The number of bytes to write.
                    // 
                    // Return values:
                    //   The number of bytes written, or -1 on error.
                    // 
  local_c = 0;
  local_14 = 0;
  if (count == 0) {
LAB_1001e932:
    iVar4 = 0;
  }
  else {
    piVar1 = &DAT_11766460 + ((int)file_descriptor >> 5);
    iVar4 = (file_descriptor & 0x1f) * 0x24;
    if ((*(byte *)(*piVar1 + 4 + iVar4) & 0x20) != 0) {
      file_io_6(file_descriptor,0,2);
    }
    if ((*(byte *)((undefined4 *)(*piVar1 + iVar4) + 1) & 0x80) == 0) {
      BVar6 = WriteFile(*(HANDLE *)(*piVar1 + iVar4),buffer,count,&local_10,(LPOVERLAPPED)0x0);
      if (BVar6 == 0) {
        file_descriptor = GetLastError();
      }
      else {
        local_c = local_10;
        file_descriptor = 0;
      }
LAB_1001ea01:
      if (local_c != 0) {
        return local_c - local_14;
      }
      if (file_descriptor == 0) goto LAB_1001ea73;
      if (file_descriptor == 5) {
        puVar7 = (undefined4 *)get_last_error();
        *puVar7 = 9;
        puVar7 = (undefined4 *)get_last_error_2();
        *puVar7 = 5;
      }
      else {
        get_error_code(file_descriptor);
      }
    }
    else {
      local_8 = (char *)buffer;
      file_descriptor = 0;
      if (count != 0) {
        do {
          pcVar5 = local_418;
          do {
            if (count <= (uint)((int)local_8 - (int)buffer)) break;
            pcVar2 = local_8 + 1;
            cVar3 = *local_8;
            local_8 = pcVar2;
            if (cVar3 == '\n') {
              local_14 = local_14 + 1;
              *pcVar5 = '\r';
              pcVar5 = pcVar5 + 1;
            }
            *pcVar5 = cVar3;
            pcVar5 = pcVar5 + 1;
          } while ((int)pcVar5 - (int)local_418 < 0x400);
          BVar6 = WriteFile(*(HANDLE *)(*piVar1 + iVar4),local_418,(int)pcVar5 - (int)local_418,
                            &local_10,(LPOVERLAPPED)0x0);
          if (BVar6 == 0) {
            file_descriptor = GetLastError();
            goto LAB_1001ea01;
          }
          local_c = local_c + local_10;
          if (((int)local_10 < (int)pcVar5 - (int)local_418) ||
             (count <= (uint)((int)local_8 - (int)buffer))) goto LAB_1001ea01;
        } while( true );
      }
LAB_1001ea73:
                    // WARNING: Load size is inaccurate
      if (((*(byte *)(*piVar1 + 4 + iVar4) & 0x40) != 0) && (*buffer == '\x1a')) goto LAB_1001e932;
      puVar7 = (undefined4 *)get_last_error();
      *puVar7 = 0x1c;
      puVar7 = (undefined4 *)get_last_error_2();
      *puVar7 = 0;
    }
    iVar4 = -1;
  }
  return iVar4;
}



// Setting prototype: void *memcpy_internal_6(void *destination, const void *source, size_t count)

undefined4 * memcpy_internal_6(undefined4 *destination,undefined4 *source,uint count)

{
  uint uVar1;
  undefined4 *puVar2;
  
                    // 
                    // Copies a specified number of bytes from a source memory area to a destination
                    // memory area.
                    // 
                    // Parameters:
                    //   destination: Pointer to the destination memory area.
                    //   source: Pointer to the source memory area.
                    //   count: The number of bytes to copy.
                    // 
                    // Return values:
                    //   A pointer to the destination memory area.
                    // 
  if ((source < destination) && (destination < (undefined4 *)(count + (int)source))) {
    source = (undefined4 *)((count - 4) + (int)source);
    puVar2 = (undefined4 *)((count - 4) + (int)destination);
    if (((uint)puVar2 & 3) == 0) {
      uVar1 = count >> 2;
      count = count & 3;
      if (7 < uVar1) {
        for (; uVar1 != 0; uVar1 = uVar1 - 1) {
          *puVar2 = *source;
          source = source + -1;
          puVar2 = puVar2 + -1;
        }
        switch(count) {
        case 0:
          return destination;
        case 2:
          goto switchD_1001ec67_caseD_2;
        case 3:
          goto switchD_1001ec67_caseD_3;
        }
        goto switchD_1001ec67_caseD_1;
      }
    }
    else {
      switch(count) {
      case 0:
        goto switchD_1001ec67_caseD_0;
      case 1:
        goto switchD_1001ec67_caseD_1;
      case 2:
        goto switchD_1001ec67_caseD_2;
      case 3:
        goto switchD_1001ec67_caseD_3;
      default:
        uVar1 = count - ((uint)puVar2 & 3);
        switch((uint)puVar2 & 3) {
        case 1:
          count = uVar1 & 3;
          *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
          source = (undefined4 *)((int)source + -1);
          uVar1 = uVar1 >> 2;
          puVar2 = (undefined4 *)((int)puVar2 - 1);
          if (7 < uVar1) {
            for (; uVar1 != 0; uVar1 = uVar1 - 1) {
              *puVar2 = *source;
              source = source + -1;
              puVar2 = puVar2 + -1;
            }
            switch(count) {
            case 0:
              return destination;
            case 2:
              goto switchD_1001ec67_caseD_2;
            case 3:
              goto switchD_1001ec67_caseD_3;
            }
            goto switchD_1001ec67_caseD_1;
          }
          break;
        case 2:
          count = uVar1 & 3;
          *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
          uVar1 = uVar1 >> 2;
          *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
          source = (undefined4 *)((int)source + -2);
          puVar2 = (undefined4 *)((int)puVar2 - 2);
          if (7 < uVar1) {
            for (; uVar1 != 0; uVar1 = uVar1 - 1) {
              *puVar2 = *source;
              source = source + -1;
              puVar2 = puVar2 + -1;
            }
            switch(count) {
            case 0:
              return destination;
            case 2:
              goto switchD_1001ec67_caseD_2;
            case 3:
              goto switchD_1001ec67_caseD_3;
            }
            goto switchD_1001ec67_caseD_1;
          }
          break;
        case 3:
          count = uVar1 & 3;
          *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
          *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
          uVar1 = uVar1 >> 2;
          *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
          source = (undefined4 *)((int)source + -3);
          puVar2 = (undefined4 *)((int)puVar2 - 3);
          if (7 < uVar1) {
            for (; uVar1 != 0; uVar1 = uVar1 - 1) {
              *puVar2 = *source;
              source = source + -1;
              puVar2 = puVar2 + -1;
            }
            switch(count) {
            case 0:
              return destination;
            case 2:
              goto switchD_1001ec67_caseD_2;
            case 3:
              goto switchD_1001ec67_caseD_3;
            }
            goto switchD_1001ec67_caseD_1;
          }
        }
      }
    }
    switch(uVar1) {
    case 7:
      puVar2[7 - uVar1] = source[7 - uVar1];
    case 6:
      puVar2[6 - uVar1] = source[6 - uVar1];
    case 5:
      puVar2[5 - uVar1] = source[5 - uVar1];
    case 4:
      puVar2[4 - uVar1] = source[4 - uVar1];
    case 3:
      puVar2[3 - uVar1] = source[3 - uVar1];
    case 2:
      puVar2[2 - uVar1] = source[2 - uVar1];
    case 1:
      puVar2[1 - uVar1] = source[1 - uVar1];
      source = source + -uVar1;
      puVar2 = puVar2 + -uVar1;
    }
    switch(count) {
    case 1:
switchD_1001ec67_caseD_1:
      *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
      return destination;
    case 2:
switchD_1001ec67_caseD_2:
      *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
      *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
      return destination;
    case 3:
switchD_1001ec67_caseD_3:
      *(undefined1 *)((int)puVar2 + 3) = *(undefined1 *)((int)source + 3);
      *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
      *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
      return destination;
    }
switchD_1001ec67_caseD_0:
    return destination;
  }
  puVar2 = destination;
  if (((uint)destination & 3) == 0) {
    uVar1 = count >> 2;
    count = count & 3;
    if (7 < uVar1) {
      for (; uVar1 != 0; uVar1 = uVar1 - 1) {
        *puVar2 = *source;
        source = source + 1;
        puVar2 = puVar2 + 1;
      }
      switch(count) {
      case 0:
        return destination;
      case 2:
        goto switchD_1001eae5_caseD_2;
      case 3:
        goto switchD_1001eae5_caseD_3;
      }
      goto switchD_1001eae5_caseD_1;
    }
  }
  else {
    switch(count) {
    case 0:
      goto switchD_1001eae5_caseD_0;
    case 1:
      goto switchD_1001eae5_caseD_1;
    case 2:
      goto switchD_1001eae5_caseD_2;
    case 3:
      goto switchD_1001eae5_caseD_3;
    default:
      uVar1 = (count - 4) + ((uint)destination & 3);
      switch((uint)destination & 3) {
      case 1:
        count = uVar1 & 3;
        *(undefined1 *)destination = *(undefined1 *)source;
        *(undefined1 *)((int)destination + 1) = *(undefined1 *)((int)source + 1);
        uVar1 = uVar1 >> 2;
        *(undefined1 *)((int)destination + 2) = *(undefined1 *)((int)source + 2);
        source = (undefined4 *)((int)source + 3);
        puVar2 = (undefined4 *)((int)destination + 3);
        if (7 < uVar1) {
          for (; uVar1 != 0; uVar1 = uVar1 - 1) {
            *puVar2 = *source;
            source = source + 1;
            puVar2 = puVar2 + 1;
          }
          switch(count) {
          case 0:
            return destination;
          case 2:
            goto switchD_1001eae5_caseD_2;
          case 3:
            goto switchD_1001eae5_caseD_3;
          }
          goto switchD_1001eae5_caseD_1;
        }
        break;
      case 2:
        count = uVar1 & 3;
        *(undefined1 *)destination = *(undefined1 *)source;
        uVar1 = uVar1 >> 2;
        *(undefined1 *)((int)destination + 1) = *(undefined1 *)((int)source + 1);
        source = (undefined4 *)((int)source + 2);
        puVar2 = (undefined4 *)((int)destination + 2);
        if (7 < uVar1) {
          for (; uVar1 != 0; uVar1 = uVar1 - 1) {
            *puVar2 = *source;
            source = source + 1;
            puVar2 = puVar2 + 1;
          }
          switch(count) {
          case 0:
            return destination;
          case 2:
            goto switchD_1001eae5_caseD_2;
          case 3:
            goto switchD_1001eae5_caseD_3;
          }
          goto switchD_1001eae5_caseD_1;
        }
        break;
      case 3:
        count = uVar1 & 3;
        *(undefined1 *)destination = *(undefined1 *)source;
        source = (undefined4 *)((int)source + 1);
        uVar1 = uVar1 >> 2;
        puVar2 = (undefined4 *)((int)destination + 1);
        if (7 < uVar1) {
          for (; uVar1 != 0; uVar1 = uVar1 - 1) {
            *puVar2 = *source;
            source = source + 1;
            puVar2 = puVar2 + 1;
          }
          switch(count) {
          case 0:
            return destination;
          case 2:
            goto switchD_1001eae5_caseD_2;
          case 3:
            goto switchD_1001eae5_caseD_3;
          }
          goto switchD_1001eae5_caseD_1;
        }
      }
    }
  }
  switch(uVar1) {
  case 7:
    puVar2[uVar1 - 7] = source[uVar1 - 7];
  case 6:
    puVar2[uVar1 - 6] = source[uVar1 - 6];
  case 5:
    puVar2[uVar1 - 5] = source[uVar1 - 5];
  case 4:
    puVar2[uVar1 - 4] = source[uVar1 - 4];
  case 3:
    puVar2[uVar1 - 3] = source[uVar1 - 3];
  case 2:
    puVar2[uVar1 - 2] = source[uVar1 - 2];
  case 1:
    puVar2[uVar1 - 1] = source[uVar1 - 1];
    source = source + uVar1;
    puVar2 = puVar2 + uVar1;
  }
  switch(count) {
  case 1:
switchD_1001eae5_caseD_1:
    *(undefined1 *)puVar2 = *(undefined1 *)source;
    return destination;
  case 2:
switchD_1001eae5_caseD_2:
    *(undefined1 *)puVar2 = *(undefined1 *)source;
    *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
    return destination;
  case 3:
switchD_1001eae5_caseD_3:
    *(undefined1 *)puVar2 = *(undefined1 *)source;
    *(undefined1 *)((int)puVar2 + 1) = *(undefined1 *)((int)source + 1);
    *(undefined1 *)((int)puVar2 + 2) = *(undefined1 *)((int)source + 2);
    return destination;
  }
switchD_1001eae5_caseD_0:
  return destination;
}



// Setting prototype: uint32_t file_io_15(void *file_ptr)

uint32_t file_io_15(void *file_ptr)

{
  byte bVar1;
  uint uVar2;
  uint32_t uVar3;
  undefined *puVar4;
  
                    // 
                    // Handles file I/O operations, specifically reading from a file.
                    // 
                    // Parameters:
                    //   file_ptr: Pointer to the FILE structure.
                    // 
                    // Return values:
                    //   The character read, or EOF on error.
                    // 
  uVar2 = *(uint *)((int)file_ptr + 0xc);
  if (((uVar2 & 0x83) != 0) && ((uVar2 & 0x40) == 0)) {
    if ((uVar2 & 2) == 0) {
      *(uint *)((int)file_ptr + 0xc) = uVar2 | 1;
      if ((uVar2 & 0x10c) == 0) {
        file_io_31(file_ptr);
      }
      else {
        *(undefined4 *)file_ptr = *(undefined4 *)((int)file_ptr + 8);
      }
      uVar3 = file_io_16(*(uint32_t *)((int)file_ptr + 0x10),*(void **)((int)file_ptr + 8),
                         *(uint32_t *)((int)file_ptr + 0x18));
      *(uint32_t *)((int)file_ptr + 4) = uVar3;
      if ((uVar3 != 0) && (uVar3 != 0xffffffff)) {
        if ((*(uint *)((int)file_ptr + 0xc) & 0x82) == 0) {
          uVar2 = *(uint *)((int)file_ptr + 0x10);
          if (uVar2 == 0xffffffff) {
            puVar4 = &DAT_10031a88;
          }
          else {
            puVar4 = (undefined *)((&DAT_11766460)[(int)uVar2 >> 5] + (uVar2 & 0x1f) * 0x24);
          }
          if ((puVar4[4] & 0x82) == 0x82) {
            *(uint *)((int)file_ptr + 0xc) = *(uint *)((int)file_ptr + 0xc) | 0x2000;
          }
        }
        if (((*(int *)((int)file_ptr + 0x18) == 0x200) &&
            ((*(uint *)((int)file_ptr + 0xc) & 8) != 0)) &&
           ((*(uint *)((int)file_ptr + 0xc) & 0x400) == 0)) {
          *(undefined4 *)((int)file_ptr + 0x18) = 0x1000;
        }
                    // WARNING: Load size is inaccurate
        *(uint32_t *)((int)file_ptr + 4) = uVar3 - 1;
        bVar1 = **file_ptr;
        *(byte **)file_ptr = *file_ptr + 1;
        return (uint)bVar1;
      }
      *(uint *)((int)file_ptr + 0xc) =
           *(uint *)((int)file_ptr + 0xc) | (-(uint)(uVar3 != 0) & 0x10) + 0x10;
      *(undefined4 *)((int)file_ptr + 4) = 0;
    }
    else {
      *(uint *)((int)file_ptr + 0xc) = uVar2 | 0x20;
    }
  }
  return 0xffffffff;
}



// Setting prototype: uint32_t file_io_16(uint32_t file_descriptor, void *buffer, uint32_t count)

uint32_t file_io_16(uint32_t file_descriptor,void *buffer,uint32_t count)

{
  uint32_t uVar1;
  undefined4 *puVar2;
  
                    // 
                    // Handles file I/O operations, specifically reading from a file using a file
                    // descriptor.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   buffer: Pointer to the destination buffer.
                    //   count: The number of bytes to read.
                    // 
                    // Return values:
                    //   The number of bytes read, or -1 on error.
                    // 
  if ((file_descriptor < DAT_11766560) &&
     ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + (file_descriptor & 0x1f) * 0x24) &
      1) != 0)) {
    file_management_13(file_descriptor);
    uVar1 = file_io_17(file_descriptor,buffer,count);
    file_management_14(file_descriptor);
    return uVar1;
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 9;
  puVar2 = (undefined4 *)get_last_error_2();
  *puVar2 = 0;
  return 0xffffffff;
}



// Setting prototype: int file_io_17(uint32_t file_descriptor, void *buffer, uint32_t count)

int file_io_17(uint32_t file_descriptor,void *buffer,uint32_t count)

{
  int *piVar1;
  byte *pbVar2;
  char cVar3;
  byte bVar4;
  BOOL BVar5;
  DWORD DVar6;
  undefined4 *puVar7;
  LPVOID lpBuffer;
  char *pcVar8;
  int iVar9;
  DWORD local_10;
  void *local_c;
  char local_5;
  
                    // 
                    // Handles file I/O operations, specifically reading from a file using a file
                    // descriptor.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    //   buffer: Pointer to the destination buffer.
                    //   count: The number of bytes to read.
                    // 
                    // Return values:
                    //   The number of bytes read, or -1 on error.
                    // 
  local_c = (void *)0x0;
  if (count != 0) {
    piVar1 = &DAT_11766460 + ((int)file_descriptor >> 5);
    iVar9 = (file_descriptor & 0x1f) * 0x24;
    bVar4 = *(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + iVar9 + 4);
    if ((bVar4 & 2) == 0) {
      lpBuffer = buffer;
      if (((bVar4 & 0x48) != 0) &&
         (cVar3 = *(char *)((&DAT_11766460)[(int)file_descriptor >> 5] + iVar9 + 5), cVar3 != '\n'))
      {
        count = count - 1;
        *(char *)buffer = cVar3;
        lpBuffer = (LPVOID)((int)buffer + 1);
        local_c = (void *)0x1;
        *(undefined1 *)(*piVar1 + 5 + iVar9) = 10;
      }
      BVar5 = ReadFile(*(HANDLE *)(*piVar1 + iVar9),lpBuffer,count,&local_10,(LPOVERLAPPED)0x0);
      if (BVar5 == 0) {
        DVar6 = GetLastError();
        if (DVar6 == 5) {
          puVar7 = (undefined4 *)get_last_error();
          *puVar7 = 9;
          puVar7 = (undefined4 *)get_last_error_2();
          *puVar7 = 5;
        }
        else {
          if (DVar6 == 0x6d) {
            return 0;
          }
          get_error_code(DVar6);
        }
        return -1;
      }
      bVar4 = *(byte *)(*piVar1 + 4 + iVar9);
      if ((bVar4 & 0x80) == 0) {
        return (int)local_c + local_10;
      }
                    // WARNING: Load size is inaccurate
      if ((local_10 == 0) || (*buffer != '\n')) {
        bVar4 = bVar4 & 0xfb;
      }
      else {
        bVar4 = bVar4 | 4;
      }
      *(byte *)(*piVar1 + 4 + iVar9) = bVar4;
      count = (uint32_t)buffer;
      local_c = (void *)((int)local_c + local_10 + (int)buffer);
      pcVar8 = (char *)buffer;
      if (buffer < local_c) {
        do {
          cVar3 = *(char *)count;
          if (cVar3 == '\x1a') {
            pbVar2 = (byte *)(*piVar1 + 4 + iVar9);
            bVar4 = *pbVar2;
            if ((bVar4 & 0x40) == 0) {
              *pbVar2 = bVar4 | 2;
            }
            break;
          }
          if (cVar3 == '\r') {
            if (count < (int)local_c - 1U) {
              if (*(char *)(count + 1) == '\n') {
                count = count + 2;
                goto LAB_1001f0b1;
              }
              *pcVar8 = '\r';
              pcVar8 = pcVar8 + 1;
              count = count + 1;
            }
            else {
              count = count + 1;
              BVar5 = ReadFile(*(HANDLE *)(*piVar1 + iVar9),&local_5,1,&local_10,(LPOVERLAPPED)0x0);
              if (((BVar5 == 0) && (DVar6 = GetLastError(), DVar6 != 0)) || (local_10 == 0)) {
LAB_1001f0cb:
                *pcVar8 = '\r';
LAB_1001f0ce:
                pcVar8 = pcVar8 + 1;
              }
              else if ((*(byte *)(*piVar1 + 4 + iVar9) & 0x48) == 0) {
                if ((pcVar8 == (char *)buffer) && (local_5 == '\n')) {
LAB_1001f0b1:
                  *pcVar8 = '\n';
                  goto LAB_1001f0ce;
                }
                file_io_6(file_descriptor,-1,1);
                if (local_5 != '\n') goto LAB_1001f0cb;
              }
              else {
                if (local_5 == '\n') goto LAB_1001f0b1;
                *pcVar8 = '\r';
                pcVar8 = pcVar8 + 1;
                *(char *)(*piVar1 + 5 + iVar9) = local_5;
              }
            }
          }
          else {
            *pcVar8 = cVar3;
            pcVar8 = pcVar8 + 1;
            count = count + 1;
          }
        } while (count < local_c);
      }
      return (int)pcVar8 - (int)buffer;
    }
  }
  return 0;
}



// Setting prototype: uint32_t file_io_22(uint32_t file_descriptor)

uint32_t file_io_22(uint32_t file_descriptor)

{
  HANDLE hFile;
  BOOL BVar1;
  DWORD DVar2;
  DWORD *pDVar3;
  undefined4 *puVar4;
  int iVar5;
  
                    // 
                    // Handles file I/O operations, specifically flushing file buffers.
                    // 
                    // Parameters:
                    //   file_descriptor: The file descriptor.
                    // 
                    // Return values:
                    //   0 if successful, or -1 on error.
                    // 
  if (DAT_11766560 <= file_descriptor) {
LAB_1001f180:
    puVar4 = (undefined4 *)get_last_error();
    *puVar4 = 9;
    return 0xffffffff;
  }
  iVar5 = (file_descriptor & 0x1f) * 0x24;
  if ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + iVar5) & 1) == 0)
  goto LAB_1001f180;
  file_management_13(file_descriptor);
  if ((*(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + iVar5) & 1) != 0) {
    hFile = (HANDLE)file_management_12(file_descriptor);
    BVar1 = FlushFileBuffers(hFile);
    if (BVar1 == 0) {
      DVar2 = GetLastError();
    }
    else {
      DVar2 = 0;
    }
    if (DVar2 == 0) goto LAB_1001f175;
    pDVar3 = (DWORD *)get_last_error_2();
    *pDVar3 = DVar2;
  }
  puVar4 = (undefined4 *)get_last_error();
  *puVar4 = 9;
  DVar2 = 0xffffffff;
LAB_1001f175:
  file_management_14(file_descriptor);
  return DVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_startup_10(void)

void crt_startup_10(void)

{
                    // 
                    // Performs C runtime startup initialization, likely related to memory
                    // management or bitwise operations.
                    // 
  bitwise_op_2(0x10000,0x30000);
  return;
}



// WARNING: Removing unreachable block (ram,0x1001f1d9)
// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: int crt_startup_11(void)

int crt_startup_11(void)

{
                    // 
                    // Performs C runtime startup initialization, likely related to some conditional
                    // check.
                    // 
                    // Return values:
                    //   1 if a condition is met, 0 otherwise.
                    // 
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void crt_startup_12(void)

void crt_startup_12(void)

{
  HMODULE hModule;
  FARPROC pFVar1;
  
                    // 
                    // Performs C runtime startup initialization, checking for processor features.
                    // 
  hModule = GetModuleHandleA("KERNEL32");
  if (hModule != (HMODULE)0x0) {
    pFVar1 = GetProcAddress(hModule,"IsProcessorFeaturePresent");
    if (pFVar1 != (FARPROC)0x0) {
      (*pFVar1)(0);
      return;
    }
  }
  crt_startup_11();
  return;
}



// Setting prototype: void str_to_float(char *str)

void str_to_float(char *str)

{
  char cVar1;
  char cVar2;
  undefined *this;
  int iVar3;
  uint32_t uVar4;
  uint32_t unaff_ESI;
  undefined *puVar5;
  
                    // 
                    // Converts a string representation of a number to a floating-point value.
                    // 
                    // Parameters:
                    //   str: The string to convert.
                    // 
  this = (undefined *)(int)*str;
  iVar3 = char_to_upper_19();
  if (iVar3 != 0x65) {
    do {
      str = str + 1;
      if (DAT_10033ee0 < 2) {
        uVar4 = (byte)PTR_DAT_10033cd4[*str * 2] & 4;
        this = PTR_DAT_10033cd4;
      }
      else {
        puVar5 = (undefined *)0x4;
        uVar4 = get_char_property(this,(int)*str,4,unaff_ESI);
        this = puVar5;
      }
    } while (uVar4 != 0);
  }
  cVar2 = *str;
  *str = DAT_10033ee4;
  do {
    str = str + 1;
    cVar1 = *str;
    *str = cVar2;
    cVar2 = cVar1;
  } while (*str != '\0');
  return;
}



// Setting prototype: void __fassign(int flag, void *destination, void *source)

void __cdecl __fassign(int flag,void *destination,void *source)

{
  undefined4 local_c;
  undefined4 local_8;
  
                    // 
                    // Assigns a floating-point value to a destination, handling different
                    // assignment types.
                    // 
                    // Parameters:
                    //   flag: A flag indicating the type of assignment.
                    //   destination: Pointer to the destination for the assignment.
                    //   source: Pointer to the source floating-point value.
                    // 
  if (flag != 0) {
    float_conversion_4(&local_c);
    *(undefined4 *)destination = local_c;
    *(undefined4 *)((int)destination + 4) = local_8;
    return;
  }
  float_conversion_5(&source,source);
  *(void **)destination = source;
  return;
}



// Setting prototype: int float_to_str(double value, char *buffer, int precision, char format_type)

int float_to_str(double value,char *buffer,int precision,char format_type)

{
  undefined1 local_2c [24];
  int local_14 [4];
  
                    // 
                    // Converts a floating-point value to its string representation.
                    // 
                    // Parameters:
                    //   value: The floating-point value to convert.
                    //   buffer: Pointer to the buffer to store the string.
                    //   precision: The number of digits after the decimal point.
                    //   format_type: The format type (e.g., 'f' for fixed-point, 'e' for
                    // scientific).
                    // 
                    // Return values:
                    //   The number of characters written to the buffer.
                    // 
  string_format_2(*value._0_4_,local_14,local_2c);
  string_format((uint)(0 < (int)buffer) + value._4_4_ + (uint)(local_14[0] == 0x2d),buffer + 1,
                local_14);
  float_to_str_2(value._4_4_,buffer,precision,local_14,0);
  return value._4_4_;
}



// Setting prototype: char *float_to_str_2(char *buffer, int precision, int format_type, void
// *internal_data, char is_scientific)

undefined1 *
float_to_str_2(undefined1 *buffer,int precision,int format_type,int *internal_data,
              char is_scientific)

{
  undefined1 *puVar1;
  undefined1 *puVar2;
  int iVar3;
  
                    // 
                    // Converts a floating-point value to its string representation, handling
                    // scientific notation and precision.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the buffer to store the string.
                    //   precision: The number of digits after the decimal point.
                    //   format_type: The format type (e.g., 'f' for fixed-point, 'e' for
                    // scientific).
                    //   internal_data: Internal data structure for conversion.
                    //   is_scientific: Flag indicating if scientific notation should be used.
                    // 
                    // Return values:
                    //   A pointer to the formatted string.
                    // 
  if (is_scientific != '\0') {
    strcpy_internal(buffer + (*internal_data == 0x2d),(uint)(0 < precision));
  }
  puVar2 = buffer;
  if (*internal_data == 0x2d) {
    *buffer = 0x2d;
    puVar2 = buffer + 1;
  }
  puVar1 = puVar2;
  if (0 < precision) {
    puVar1 = puVar2 + 1;
    *puVar2 = puVar2[1];
    *puVar1 = DAT_10033ee4;
  }
  puVar2 = (undefined1 *)
           strcpy_internal_2(puVar1 + precision + (uint)(is_scientific == '\0'),"e+000");
  if (format_type != 0) {
    *puVar2 = 0x45;
  }
  if (*(char *)internal_data[3] != '0') {
    iVar3 = internal_data[1] + -1;
    if (iVar3 < 0) {
      iVar3 = -iVar3;
      puVar2[1] = 0x2d;
    }
    if (99 < iVar3) {
      puVar2[2] = puVar2[2] + (char)(iVar3 / 100);
      iVar3 = iVar3 % 100;
    }
    if (9 < iVar3) {
      puVar2[3] = puVar2[3] + (char)(iVar3 / 10);
      iVar3 = iVar3 % 10;
    }
    puVar2[4] = puVar2[4] + (char)iVar3;
  }
  return buffer;
}



// Setting prototype: int float_to_str_3(double value, char *buffer, int precision)

int float_to_str_3(double value,char *buffer,int precision)

{
  undefined1 local_2c [24];
  int local_14;
  int local_10;
  
                    // 
                    // Converts a floating-point value to its string representation.
                    // 
                    // Parameters:
                    //   value: The floating-point value to convert.
                    //   buffer: Pointer to the buffer to store the string.
                    //   precision: The number of digits after the decimal point.
                    // 
                    // Return values:
                    //   The number of characters written to the buffer.
                    // 
  string_format_2(*value._0_4_,&local_14,local_2c);
  string_format((uint)(local_14 == 0x2d) + value._4_4_,buffer + local_10,&local_14);
  float_to_str_4(value._4_4_,buffer,&local_14,0);
  return value._4_4_;
}



// Setting prototype: char *float_to_str_4(char *buffer, size_t precision, void *internal_data, char
// is_scientific)

char * float_to_str_4(char *buffer,size_t precision,int *internal_data,char is_scientific)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  
                    // 
                    // Converts a floating-point value to its string representation, handling
                    // precision and scientific notation.
                    // 
                    // Parameters:
                    //   buffer: Pointer to the buffer to store the string.
                    //   precision: The number of digits after the decimal point.
                    //   internal_data: Internal data structure for conversion.
                    //   is_scientific: Flag indicating if scientific notation should be used.
                    // 
                    // Return values:
                    //   A pointer to the formatted string.
                    // 
  iVar1 = internal_data[1];
  if ((is_scientific != '\0') && (iVar1 - 1U == precision)) {
    iVar2 = *internal_data;
    buffer[(uint)(iVar2 == 0x2d) + (iVar1 - 1U)] = '0';
    (buffer + (uint)(iVar2 == 0x2d) + (iVar1 - 1U))[1] = '\0';
  }
  pcVar3 = buffer;
  if (*internal_data == 0x2d) {
    *buffer = '-';
    pcVar3 = buffer + 1;
  }
  if (internal_data[1] < 1) {
    strcpy_internal(pcVar3,1);
    *pcVar3 = '0';
    pcVar3 = pcVar3 + 1;
  }
  else {
    pcVar3 = pcVar3 + internal_data[1];
  }
  if (0 < (int)precision) {
    strcpy_internal(pcVar3,1);
    *pcVar3 = DAT_10033ee4;
    iVar1 = internal_data[1];
    if (iVar1 < 0) {
      if ((is_scientific != '\0') || (SBORROW4(precision,-iVar1) == (int)(precision + iVar1) < 0)) {
        precision = -iVar1;
      }
      strcpy_internal(pcVar3 + 1,precision);
      _memset(pcVar3 + 1,0x30,precision);
    }
  }
  return buffer;
}



// Setting prototype: void float_to_str_5(double value, char *buffer, int precision, char
// format_type)

void float_to_str_5(double value,char *buffer,int precision,char format_type)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  undefined1 local_2c [24];
  int local_14;
  int local_10;
  
                    // 
                    // Converts a floating-point value to its string representation, handling
                    // precision and scientific notation.
                    // 
                    // Parameters:
                    //   value: The floating-point value to convert.
                    //   buffer: Pointer to the buffer to store the string.
                    //   precision: The number of digits after the decimal point.
                    //   format_type: The format type (e.g., 'f' for fixed-point, 'e' for
                    // scientific).
                    // 
  string_format_2(*value._0_4_,&local_14,local_2c);
  iVar1 = local_10 + -1;
  pcVar2 = (char *)((uint)(local_14 == 0x2d) + value._4_4_);
  string_format(pcVar2,buffer,&local_14);
  local_10 = local_10 + -1;
  if ((local_10 < -4) || ((int)buffer <= local_10)) {
    float_to_str_2(value._4_4_,buffer,precision,&local_14,1);
  }
  else {
    if (iVar1 < local_10) {
      do {
        pcVar3 = pcVar2;
        pcVar2 = pcVar3 + 1;
      } while (*pcVar3 != '\0');
      pcVar3[-1] = '\0';
    }
    float_to_str_4(value._4_4_,buffer,&local_14,1);
  }
  return;
}



// Setting prototype: int __cfltcvt(double *value, char *buffer, size_t buffer_size, int format, int
// precision, int caps)

int __cdecl
__cfltcvt(double *value,char *buffer,size_t buffer_size,int format,int precision,int caps)

{
  int in_EAX;
  int iVar1;
  int unaff_EBP;
  
                    // 
                    // Converts a floating-point value to its string representation based on the
                    // specified format and precision.
                    // 
                    // Parameters:
                    //   value: The floating-point value to convert.
                    //   buffer: Pointer to the buffer to store the string.
                    //   buffer_size: The size of the buffer.
                    //   format: The format type (e.g., 'f' for fixed-point, 'e' for scientific).
                    //   precision: The number of digits after the decimal point.
                    //   caps: Flag indicating whether to use uppercase for scientific notation.
                    // 
                    // Return values:
                    //   0 if successful, or an error code otherwise.
                    // 
  if ((buffer_size == 0x65) || (buffer_size == 0x45)) {
    in_EAX = float_to_str((double)CONCAT44(buffer,value),(char *)format,precision,(char)unaff_EBP);
  }
  else {
    if (buffer_size == 0x66) {
      iVar1 = float_to_str_3((double)CONCAT44(buffer,value),(char *)format,unaff_EBP);
      return iVar1;
    }
    float_to_str_5((double)CONCAT44(buffer,value),(char *)format,precision,(char)unaff_EBP);
  }
  return in_EAX;
}



// Setting prototype: void strcpy_internal(char *destination, int offset)

void strcpy_internal(char *destination,int offset)

{
  size_t sVar1;
  
                    // 
                    // Copies a string to a new location with an offset.
                    // 
                    // Parameters:
                    //   destination: Pointer to the destination buffer.
                    //   offset: The offset to apply to the destination.
                    // 
  if (offset != 0) {
    sVar1 = _strlen(destination);
    memcpy_internal(destination + offset,destination,sVar1 + 1);
  }
  return;
}



int string_map(LCID param_1,uint param_2,LPCSTR param_3,int param_4,LPWSTR param_5,int param_6,
              UINT param_7,int param_8)

{
  int iVar1;
  int iVar2;
  void *local_14;
  undefined1 *puStack_10;
  undefined *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &DAT_100260f8;
  puStack_10 = &LAB_1001e7dc;
  local_14 = ExceptionList;
  ExceptionList = &local_14;
  if (DAT_100355d4 == 0) {
    ExceptionList = &local_14;
    iVar1 = LCMapStringW(0,0x100,L"",1,(LPWSTR)0x0,0);
    if (iVar1 == 0) {
      iVar1 = LCMapStringA(0,0x100,"",1,(LPSTR)0x0,0);
      if (iVar1 == 0) {
        ExceptionList = local_14;
        return 0;
      }
      DAT_100355d4 = 2;
    }
    else {
      DAT_100355d4 = 1;
    }
  }
  if (0 < param_4) {
    param_4 = str_to_int_8(param_3,param_4);
  }
  if (DAT_100355d4 == 2) {
    iVar1 = LCMapStringA(param_1,param_2,param_3,param_4,(LPSTR)param_5,param_6);
    ExceptionList = local_14;
    return iVar1;
  }
  if (DAT_100355d4 == 1) {
    if (param_7 == 0) {
      param_7 = DAT_100355cc;
    }
    iVar1 = MultiByteToWideChar(param_7,(-(uint)(param_8 != 0) & 8) + 1,param_3,param_4,(LPWSTR)0x0,
                                0);
    if (iVar1 != 0) {
      local_8 = 0;
      memory_management_3();
      local_8 = 0xffffffff;
      if ((&stack0x00000000 != (undefined1 *)0x3c) &&
         (iVar2 = MultiByteToWideChar(param_7,1,param_3,param_4,(LPWSTR)&stack0xffffffc4,iVar1),
         iVar2 != 0)) {
        iVar2 = LCMapStringW(param_1,param_2,(LPCWSTR)&stack0xffffffc4,iVar1,(LPWSTR)0x0,0);
        if (iVar2 != 0) {
          if ((param_2 & 0x400) == 0) {
            local_8 = 1;
            memory_management_3();
            local_8 = 0xffffffff;
            if (&stack0x00000000 == (undefined1 *)0x3c) {
              ExceptionList = local_14;
              return 0;
            }
            iVar1 = LCMapStringW(param_1,param_2,(LPCWSTR)&stack0xffffffc4,iVar1,
                                 (LPWSTR)&stack0xffffffc4,iVar2);
            if (iVar1 == 0) {
              ExceptionList = local_14;
              return 0;
            }
            if (param_6 == 0) {
              param_6 = 0;
              param_5 = (LPWSTR)0x0;
            }
            iVar2 = WideCharToMultiByte(param_7,0x220,(LPCWSTR)&stack0xffffffc4,iVar2,(LPSTR)param_5
                                        ,param_6,(LPCSTR)0x0,(LPBOOL)0x0);
            iVar1 = iVar2;
          }
          else {
            if (param_6 == 0) {
              ExceptionList = local_14;
              return iVar2;
            }
            if (param_6 < iVar2) {
              ExceptionList = local_14;
              return 0;
            }
            iVar1 = LCMapStringW(param_1,param_2,(LPCWSTR)&stack0xffffffc4,iVar1,param_5,param_6);
          }
          if (iVar1 != 0) {
            ExceptionList = local_14;
            return iVar2;
          }
        }
      }
    }
  }
  ExceptionList = local_14;
  return 0;
}



// Setting prototype: uint32_t get_char_property(uint32_t char_val, int property_type, uint32_t
// mask)

uint32_t __thiscall get_char_property(void *this,uint32_t char_val,int property_type,uint32_t mask)

{
  BOOL BVar1;
  int cchSrc;
  undefined4 local_8;
  
                    // 
                    // Retrieves a property of a character based on its value and a property type
                    // mask.
                    // 
                    // Parameters:
                    //   char_val: The character value.
                    //   property_type: The type of property to retrieve.
                    //   mask: A mask to apply to the retrieved property.
                    // 
                    // Return values:
                    //   The character property after applying the mask.
                    // 
  if (char_val + 1 < 0x101) {
    char_val._2_2_ = *(ushort *)(PTR_DAT_10033cd4 + char_val * 2);
  }
  else {
    if ((PTR_DAT_10033cd4[((int)char_val >> 8 & 0xffU) * 2 + 1] & 0x80) == 0) {
      local_8 = CONCAT31((int3)((uint)this >> 8),(char)char_val) & 0xffff00ff;
      cchSrc = 1;
    }
    else {
      local_8._0_2_ = CONCAT11((char)char_val,(char)(char_val >> 8));
      local_8 = CONCAT22((short)((uint)this >> 0x10),(undefined2)local_8) & 0xff00ffff;
      cchSrc = 2;
    }
    BVar1 = get_string_type(1,(LPCSTR)&local_8,cchSrc,(LPWORD)((int)&char_val + 2));
    if (BVar1 == 0) {
      return 0;
    }
  }
  return (uint)char_val._2_2_ & property_type;
}



// Setting prototype: char *strcpy_internal_2(char *destination, const char *source)

uint * strcpy_internal_2(uint *destination,uint *source)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  
                    // 
                    // Copies a null-terminated string from source to destination.
                    // 
                    // Parameters:
                    //   destination: Pointer to the destination buffer.
                    //   source: Pointer to the source string.
                    // 
                    // Return values:
                    //   A pointer to the destination string.
                    // 
  uVar3 = (uint)source & 3;
  puVar4 = destination;
  while (uVar3 != 0) {
    bVar1 = (byte)*source;
    uVar3 = (uint)bVar1;
    source = (uint *)((int)source + 1);
    if (bVar1 == 0) goto LAB_1001f9b8;
    *(byte *)puVar4 = bVar1;
    puVar4 = (uint *)((int)puVar4 + 1);
    uVar3 = (uint)source & 3;
  }
  do {
    uVar2 = *source;
    uVar3 = *source;
    source = source + 1;
    if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {
      if ((char)uVar3 == '\0') {
LAB_1001f9b8:
        *(byte *)puVar4 = (byte)uVar3;
        return destination;
      }
      if ((char)(uVar3 >> 8) == '\0') {
        *(short *)puVar4 = (short)uVar3;
        return destination;
      }
      if ((uVar3 & 0xff0000) == 0) {
        *(short *)puVar4 = (short)uVar3;
        *(byte *)((int)puVar4 + 2) = 0;
        return destination;
      }
      if ((uVar3 & 0xff000000) == 0) {
        *puVar4 = uVar3;
        return destination;
      }
    }
    *puVar4 = uVar3;
    puVar4 = puVar4 + 1;
  } while( true );
}



// Setting prototype: char *strcat_internal(char *destination, const char *source)

uint * strcat_internal(uint *destination,uint *source)

{
  byte bVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  uint *puVar5;
  
                    // 
                    // Concatenates a source string to the end of a destination string.
                    // 
                    // Parameters:
                    //   destination: Pointer to the destination string.
                    //   source: Pointer to the source string.
                    // 
                    // Return values:
                    //   A pointer to the destination string.
                    // 
  uVar4 = (uint)destination & 3;
  puVar3 = destination;
  while (uVar4 != 0) {
    uVar4 = *puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    if ((byte)uVar4 == 0) goto LAB_1001f92f;
    uVar4 = (uint)puVar3 & 3;
  }
  do {
    do {
      puVar5 = puVar3;
      puVar3 = puVar5 + 1;
    } while (((*puVar5 ^ 0xffffffff ^ *puVar5 + 0x7efefeff) & 0x81010100) == 0);
    uVar4 = *puVar5;
    if ((char)uVar4 == '\0') goto LAB_1001f941;
    if ((char)(uVar4 >> 8) == '\0') {
      puVar5 = (uint *)((int)puVar5 + 1);
      goto LAB_1001f941;
    }
    if ((uVar4 & 0xff0000) == 0) {
      puVar5 = (uint *)((int)puVar5 + 2);
      goto LAB_1001f941;
    }
  } while ((uVar4 & 0xff000000) != 0);
LAB_1001f92f:
  puVar5 = (uint *)((int)puVar3 + -1);
LAB_1001f941:
  uVar4 = (uint)source & 3;
  while (uVar4 != 0) {
    bVar1 = (byte)*source;
    uVar4 = (uint)bVar1;
    source = (uint *)((int)source + 1);
    if (bVar1 == 0) goto LAB_1001f9b8;
    *(byte *)puVar5 = bVar1;
    puVar5 = (uint *)((int)puVar5 + 1);
    uVar4 = (uint)source & 3;
  }
  do {
    uVar2 = *source;
    uVar4 = *source;
    source = source + 1;
    if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {
      if ((char)uVar4 == '\0') {
LAB_1001f9b8:
        *(byte *)puVar5 = (byte)uVar4;
        return destination;
      }
      if ((char)(uVar4 >> 8) == '\0') {
        *(short *)puVar5 = (short)uVar4;
        return destination;
      }
      if ((uVar4 & 0xff0000) == 0) {
        *(short *)puVar5 = (short)uVar4;
        *(byte *)((int)puVar5 + 2) = 0;
        return destination;
      }
      if ((uVar4 & 0xff000000) == 0) {
        *puVar5 = uVar4;
        return destination;
      }
    }
    *puVar5 = uVar4;
    puVar5 = puVar5 + 1;
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void env_var_management(void)

void env_var_management(void)

{
  char cVar1;
  size_t sVar2;
  undefined4 *puVar3;
  void *pvVar4;
  int iVar5;
  char *pcVar6;
  
                    // 
                    // Manages environment variables, parsing them and storing them in an internal
                    // structure.
                    // 
  if (DAT_11767590 == 0) {
    crt_startup_25();
  }
  iVar5 = 0;
  for (pcVar6 = g_envStrings; *pcVar6 != '\0'; pcVar6 = pcVar6 + sVar2 + 1) {
    if (*pcVar6 != '=') {
      iVar5 = iVar5 + 1;
    }
    sVar2 = _strlen(pcVar6);
  }
  puVar3 = (undefined4 *)_malloc(iVar5 * 4 + 4);
  DAT_100354d0 = puVar3;
  if (puVar3 == (undefined4 *)0x0) {
    __amsg_exit(9);
  }
  cVar1 = *g_envStrings;
  pcVar6 = g_envStrings;
  while (cVar1 != '\0') {
    sVar2 = _strlen(pcVar6);
    if (*pcVar6 != '=') {
      pvVar4 = _malloc(sVar2 + 1);
      *puVar3 = pvVar4;
      if (pvVar4 == (void *)0x0) {
        __amsg_exit(9);
      }
      strcpy_internal_2(*puVar3,pcVar6);
      puVar3 = puVar3 + 1;
    }
    pcVar6 = pcVar6 + sVar2 + 1;
    cVar1 = *pcVar6;
  }
  free_memory(g_envStrings);
  g_envStrings = (char *)0x0;
  *puVar3 = 0;
  DAT_1176758c = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void env_var_management_2(void)

void env_var_management_2(void)

{
  char **argv;
  char *command_line;
  int local_c;
  int local_8;
  
                    // 
                    // Manages environment variables, including retrieving module file name and
                    // command line arguments.
                    // 
  if (DAT_11767590 == 0) {
    crt_startup_25();
  }
  GetModuleFileNameA((HMODULE)0x0,&DAT_100355d8,0x104);
  _DAT_100354e0 = &DAT_100355d8;
  command_line = &DAT_100355d8;
  if (*g_commandLine != '\0') {
    command_line = g_commandLine;
  }
  env_var_management_3(command_line,(char **)0x0,(char **)0x0,&local_8,&local_c);
  argv = (char **)_malloc(local_c + local_8 * 4);
  if (argv == (char **)0x0) {
    __amsg_exit(8);
  }
  env_var_management_3(command_line,argv,argv + local_8,&local_8,&local_c);
  _DAT_100354c8 = argv;
  _DAT_100354c4 = local_8 + -1;
  return;
}



// Setting prototype: void env_var_management_3(char *command_line, char **argv, char **envp, int
// *argc, int *env_size)

void env_var_management_3(char *command_line,char **argv,char **envp,int *argc,int *env_size)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  byte *pbVar4;
  byte *pbVar5;
  uint uVar6;
  char **ppcVar7;
  
                    // 
                    // Parses command-line arguments and environment variables.
                    // 
                    // Parameters:
                    //   command_line: The command-line string.
                    //   argv: Pointer to an array to store argument pointers.
                    //   envp: Pointer to an array to store environment variable pointers.
                    //   argc: Pointer to an integer to store the argument count.
                    //   env_size: Pointer to an integer to store the environment size.
                    // 
  *env_size = 0;
  *argc = 1;
  if (argv != (char **)0x0) {
    *argv = (char *)envp;
    argv = argv + 1;
  }
  if (*command_line == '\"') {
    while( true ) {
      bVar1 = ((byte *)command_line)[1];
      pbVar4 = (byte *)command_line + 1;
      if ((bVar1 == 0x22) || (bVar1 == 0)) break;
      if ((((&DAT_11766321)[bVar1] & 4) != 0) && (*env_size = *env_size + 1, envp != (char **)0x0))
      {
        *(byte *)envp = *pbVar4;
        envp = (char **)((int)envp + 1);
        pbVar4 = (byte *)command_line + 2;
      }
      *env_size = *env_size + 1;
      command_line = (char *)pbVar4;
      if (envp != (char **)0x0) {
        *(byte *)envp = *pbVar4;
        envp = (char **)((int)envp + 1);
      }
    }
    *env_size = *env_size + 1;
    if (envp != (char **)0x0) {
      *(byte *)envp = 0;
      envp = (char **)((int)envp + 1);
    }
    if (*pbVar4 == 0x22) {
      pbVar4 = (byte *)command_line + 2;
    }
  }
  else {
    do {
      *env_size = *env_size + 1;
      if (envp != (char **)0x0) {
        *(char *)envp = *command_line;
        envp = (char **)((int)envp + 1);
      }
      bVar1 = *command_line;
      pbVar4 = (byte *)command_line + 1;
      if (((&DAT_11766321)[bVar1] & 4) != 0) {
        *env_size = *env_size + 1;
        if (envp != (char **)0x0) {
          *(byte *)envp = *pbVar4;
          envp = (char **)((int)envp + 1);
        }
        pbVar4 = (byte *)command_line + 2;
      }
      if (bVar1 == 0x20) break;
      if (bVar1 == 0) goto LAB_1001fbbd;
      command_line = (char *)pbVar4;
    } while (bVar1 != 9);
    if (bVar1 == 0) {
LAB_1001fbbd:
      pbVar4 = pbVar4 + -1;
    }
    else if (envp != (char **)0x0) {
      *(byte *)((int)envp + -1) = 0;
    }
  }
  bVar2 = false;
  ppcVar7 = argv;
  while (*pbVar4 != 0) {
    for (; (*pbVar4 == 0x20 || (*pbVar4 == 9)); pbVar4 = pbVar4 + 1) {
    }
    if (*pbVar4 == 0) break;
    if (ppcVar7 != (char **)0x0) {
      *ppcVar7 = (char *)envp;
      ppcVar7 = ppcVar7 + 1;
      argv = ppcVar7;
    }
    *argc = *argc + 1;
    while( true ) {
      bVar3 = true;
      uVar6 = 0;
      for (; *pbVar4 == 0x5c; pbVar4 = pbVar4 + 1) {
        uVar6 = uVar6 + 1;
      }
      if (*pbVar4 == 0x22) {
        pbVar5 = pbVar4;
        if ((uVar6 & 1) == 0) {
          if ((!bVar2) || (pbVar5 = pbVar4 + 1, pbVar4[1] != 0x22)) {
            bVar3 = false;
            pbVar5 = pbVar4;
          }
          bVar2 = !bVar2;
          ppcVar7 = argv;
        }
        uVar6 = uVar6 >> 1;
        pbVar4 = pbVar5;
      }
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        if (envp != (char **)0x0) {
          *(byte *)envp = 0x5c;
          envp = (char **)((int)envp + 1);
        }
        *env_size = *env_size + 1;
      }
      bVar1 = *pbVar4;
      if ((bVar1 == 0) || ((!bVar2 && ((bVar1 == 0x20 || (bVar1 == 9)))))) break;
      if (bVar3) {
        if (envp == (char **)0x0) {
          if (((&DAT_11766321)[bVar1] & 4) != 0) {
            pbVar4 = pbVar4 + 1;
            *env_size = *env_size + 1;
          }
        }
        else {
          if (((&DAT_11766321)[bVar1] & 4) != 0) {
            *(byte *)envp = bVar1;
            envp = (char **)((int)envp + 1);
            pbVar4 = pbVar4 + 1;
            *env_size = *env_size + 1;
          }
          *(byte *)envp = *pbVar4;
          envp = (char **)((int)envp + 1);
        }
        *env_size = *env_size + 1;
      }
      pbVar4 = pbVar4 + 1;
    }
    if (envp != (char **)0x0) {
      *(byte *)envp = 0;
      envp = (char **)((int)envp + 1);
    }
    *env_size = *env_size + 1;
  }
  if (ppcVar7 != (char **)0x0) {
    *ppcVar7 = (char *)0x0;
  }
  *argc = *argc + 1;
  return;
}



// Setting prototype: char *get_environment_strings(void)

LPSTR get_environment_strings(void)

{
  char cVar1;
  WCHAR WVar2;
  WCHAR *pWVar3;
  WCHAR *pWVar4;
  int iVar5;
  size_t size;
  LPSTR pCVar6;
  char *pcVar7;
  LPWCH lpWideCharStr;
  LPCH pCVar9;
  LPSTR local_8;
  char *pcVar8;
  
                    // 
                    // Retrieves environment variables as a block of strings.
                    // 
                    // Return values:
                    //   A pointer to the environment block, or NULL on error.
                    // 
  lpWideCharStr = (LPWCH)0x0;
  pCVar9 = (LPCH)0x0;
  if (DAT_100356dc == 0) {
    lpWideCharStr = GetEnvironmentStringsW();
    if (lpWideCharStr != (LPWCH)0x0) {
      DAT_100356dc = 1;
LAB_1001fd1d:
      if ((lpWideCharStr == (LPWCH)0x0) &&
         (lpWideCharStr = GetEnvironmentStringsW(), lpWideCharStr == (LPWCH)0x0)) {
        return (LPSTR)0x0;
      }
      WVar2 = *lpWideCharStr;
      pWVar4 = lpWideCharStr;
      while (WVar2 != L'\0') {
        do {
          pWVar3 = pWVar4;
          pWVar4 = pWVar3 + 1;
        } while (*pWVar4 != L'\0');
        pWVar4 = pWVar3 + 2;
        WVar2 = *pWVar4;
      }
      iVar5 = ((int)pWVar4 - (int)lpWideCharStr >> 1) + 1;
      size = WideCharToMultiByte(0,0,lpWideCharStr,iVar5,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
      local_8 = (LPSTR)0x0;
      if (((size != 0) && (pCVar6 = (LPSTR)_malloc(size), pCVar6 != (LPSTR)0x0)) &&
         (iVar5 = WideCharToMultiByte(0,0,lpWideCharStr,iVar5,pCVar6,size,(LPCSTR)0x0,(LPBOOL)0x0),
         local_8 = pCVar6, iVar5 == 0)) {
        free_memory(pCVar6);
        local_8 = (LPSTR)0x0;
      }
      FreeEnvironmentStringsW(lpWideCharStr);
      return local_8;
    }
    pCVar9 = GetEnvironmentStrings();
    if (pCVar9 == (LPCH)0x0) {
      return (LPSTR)0x0;
    }
    DAT_100356dc = 2;
  }
  else {
    if (DAT_100356dc == 1) goto LAB_1001fd1d;
    if (DAT_100356dc != 2) {
      return (LPSTR)0x0;
    }
  }
  if ((pCVar9 == (LPCH)0x0) && (pCVar9 = GetEnvironmentStrings(), pCVar9 == (LPCH)0x0)) {
    return (LPSTR)0x0;
  }
  cVar1 = *pCVar9;
  pcVar7 = pCVar9;
  while (cVar1 != '\0') {
    do {
      pcVar8 = pcVar7;
      pcVar7 = pcVar8 + 1;
    } while (*pcVar7 != '\0');
    pcVar7 = pcVar8 + 2;
    cVar1 = *pcVar7;
  }
  pCVar6 = (LPSTR)_malloc((size_t)(pcVar7 + (1 - (int)pCVar9)));
  if (pCVar6 == (LPSTR)0x0) {
    pCVar6 = (LPSTR)0x0;
  }
  else {
    memcpy_internal_6(pCVar6,pCVar9,pcVar7 + (1 - (int)pCVar9));
  }
  FreeEnvironmentStringsA(pCVar9);
  return pCVar6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void exit_program_44(void)

void exit_program_44(void)

{
                    // 
                    // Exits the program, performing cleanup and calling a specific exit routine.
                    // 
  if ((DAT_10035508 == 1) || ((DAT_10035508 == 0 && (DAT_1003550c == 1)))) {
    exit_program_45(0xfc);
    if (DAT_100356e0 != (code *)0x0) {
      (*DAT_100356e0)();
    }
    exit_program_45(0xff);
  }
  return;
}



// Setting prototype: void exit_program_45(uint32_t exit_code)

void exit_program_45(uint32_t exit_code)

{
  undefined4 *puVar1;
  uint32_t *puVar2;
  DWORD DVar3;
  size_t sVar4;
  HANDLE hFile;
  int iVar5;
  char acStackY_1e3 [7];
  undefined1 *puStackY_1dc;
  char *pcStackY_1d8;
  undefined4 uStackY_1d4;
  undefined1 *puStackY_1d0;
  undefined4 uStackY_1cc;
  undefined1 *puStackY_1c8;
  undefined *puStackY_1c4;
  LPCVOID lpBuffer;
  LPOVERLAPPED lpOverlapped;
  CHAR local_1a8 [260];
  undefined1 local_a4 [160];
  
                    // 
                    // Exits the program, displaying an error message based on the exit code.
                    // 
                    // Parameters:
                    //   exit_code: The exit code.
                    // 
  iVar5 = 0;
  puVar2 = &DAT_10033ef0;
  do {
    if (exit_code == *puVar2) break;
    puVar2 = puVar2 + 2;
    iVar5 = iVar5 + 1;
  } while ((int)puVar2 < 0x10033f80);
  if (exit_code == (&DAT_10033ef0)[iVar5 * 2]) {
    if ((DAT_10035508 == 1) || ((DAT_10035508 == 0 && (DAT_1003550c == 1)))) {
      puVar2 = &exit_code;
      puVar1 = (undefined4 *)(iVar5 * 8 + 0x10033ef4);
      lpOverlapped = (LPOVERLAPPED)0x0;
      sVar4 = _strlen((char *)*puVar1);
      lpBuffer = (LPCVOID)*puVar1;
      puStackY_1c4 = (undefined *)0x1001ff7a;
      hFile = GetStdHandle(0xfffffff4);
      puStackY_1c4 = (undefined *)0x1001ff81;
      WriteFile(hFile,lpBuffer,sVar4,puVar2,lpOverlapped);
    }
    else if (exit_code != 0xfc) {
      DVar3 = GetModuleFileNameA((HMODULE)0x0,local_1a8,0x104);
      if (DVar3 == 0) {
        strcpy_internal_2();
      }
      sVar4 = _strlen(local_1a8);
      if (0x3c < sVar4 + 1) {
        sVar4 = _strlen(local_1a8);
        puStackY_1c4 = (undefined *)0x1001fefb;
        _strncpy(acStackY_1e3 + sVar4,"...",3);
      }
      strcpy_internal_2();
      puStackY_1c4 = (undefined *)0x1001ff1c;
      strcat_internal();
      puStackY_1c8 = local_a4;
      puStackY_1c4 = &DAT_100263c0;
      uStackY_1cc = 0x1001ff2d;
      strcat_internal();
      uStackY_1cc = *(undefined4 *)(iVar5 * 8 + 0x10033ef4);
      puStackY_1d0 = local_a4;
      uStackY_1d4 = 0x1001ff3f;
      strcat_internal();
      uStackY_1d4 = 0x12010;
      puStackY_1dc = local_a4;
      pcStackY_1d8 = "Microsoft Visual C++ Runtime Library";
      acStackY_1e3[3] = 'U';
      acStackY_1e3[4] = -1;
      acStackY_1e3[5] = '\x01';
      acStackY_1e3[6] = '\x10';
      show_message_box();
    }
  }
  return;
}



// Setting prototype: void *malloc_internal_22(uint32_t num_elements, uint32_t element_size)

LPVOID malloc_internal_22(int num_elements,int element_size)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint _Size;
  LPVOID local_24;
  void *local_14;
  undefined1 *puStack_10;
  undefined *puStack_c;
  undefined4 local_8;
  
                    // 
                    // Internal memory allocation function, allocating memory for a specified number
                    // of elements of a given size.
                    // 
                    // Parameters:
                    //   num_elements: The number of elements to allocate.
                    //   element_size: The size of each element.
                    // 
                    // Return values:
                    //   A pointer to the allocated memory block, or NULL if allocation fails.
                    // 
  local_8 = 0xffffffff;
  puStack_c = &DAT_10026400;
  puStack_10 = &LAB_1001e7dc;
  local_14 = ExceptionList;
  uVar2 = num_elements * element_size;
  uVar3 = uVar2;
  ExceptionList = &local_14;
  if (uVar2 < 0xffffffe1) {
    if (uVar2 == 0) {
      uVar3 = 1;
    }
    uVar3 = uVar3 + 0xf & 0xfffffff0;
    ExceptionList = &local_14;
  }
  do {
    local_24 = (LPVOID)0x0;
    if (uVar3 < 0xffffffe1) {
      if (DAT_11766450 == 3) {
        if (uVar2 <= DAT_11766448) {
          lock_resource(9);
          local_8 = 0;
          local_24 = (LPVOID)heap_management_9(uVar2);
          local_8 = 0xffffffff;
          memory_management_39();
          _Size = uVar2;
          if (local_24 == (void *)0x0) goto LAB_10020071;
LAB_10020060:
          _memset(local_24,0,_Size);
        }
LAB_1002006c:
        if (local_24 != (LPVOID)0x0) {
          ExceptionList = local_14;
          return local_24;
        }
      }
      else {
        if ((DAT_11766450 != 2) || (DAT_10033b9c < uVar3)) goto LAB_1002006c;
        lock_resource(9);
        local_8 = 1;
        local_24 = (LPVOID)heap_management_18(uVar3 >> 4);
        local_8 = 0xffffffff;
        memory_management_40();
        _Size = uVar3;
        if (local_24 != (void *)0x0) goto LAB_10020060;
      }
LAB_10020071:
      local_24 = HeapAlloc(DAT_1176644c,8,uVar3);
    }
    if (local_24 != (LPVOID)0x0) {
      ExceptionList = local_14;
      return local_24;
    }
    if (DAT_1003559c == 0) {
      ExceptionList = local_14;
      return (LPVOID)0x0;
    }
    iVar1 = new_handler(uVar3);
    if (iVar1 == 0) {
      ExceptionList = local_14;
      return (LPVOID)0x0;
    }
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void memory_management_39(void)

void memory_management_39(void)

{
                    // 
                    // Manages memory, likely by unlocking a resource.
                    // 
  unlock_resource(9);
  return;
}



void memory_management_40(void)

{
  unlock_resource(9);
  return;
}



int file_management_9(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int *piVar3;
  int iVar4;
  int local_8;
  int local_4;
  
  iVar4 = -1;
  lock_resource(0x12);
  local_8 = 0;
  local_4 = 0;
  piVar3 = &DAT_11766460;
  while (puVar2 = (undefined4 *)*piVar3, puVar1 = puVar2, puVar2 != (undefined4 *)0x0) {
    for (; puVar2 < puVar1 + 0x120; puVar2 = puVar2 + 9) {
      if ((*(byte *)(puVar2 + 1) & 1) == 0) {
        if (puVar2[2] == 0) {
          lock_resource(0x11);
          if (puVar2[2] == 0) {
            InitializeCriticalSection((LPCRITICAL_SECTION)(puVar2 + 3));
            puVar2[2] = puVar2[2] + 1;
          }
          unlock_resource(0x11);
        }
        EnterCriticalSection((LPCRITICAL_SECTION)(puVar2 + 3));
        if ((*(byte *)(puVar2 + 1) & 1) == 0) {
          *puVar2 = 0xffffffff;
          iVar4 = ((int)puVar2 - *piVar3) / 0x24 + local_4;
          if (iVar4 != -1) goto LAB_10020254;
          break;
        }
        LeaveCriticalSection((LPCRITICAL_SECTION)(puVar2 + 3));
      }
      puVar1 = (undefined4 *)*piVar3;
    }
    local_4 = local_4 + 0x20;
    piVar3 = piVar3 + 1;
    local_8 = local_8 + 1;
    if (0x1176655f < (int)piVar3) goto LAB_10020254;
  }
  puVar2 = (undefined4 *)_malloc(0x480);
  if (puVar2 != (undefined4 *)0x0) {
    DAT_11766560 = DAT_11766560 + 0x20;
    (&DAT_11766460)[local_8] = puVar2;
    puVar1 = puVar2;
    for (; puVar2 < puVar1 + 0x120; puVar2 = puVar2 + 9) {
      *(undefined1 *)(puVar2 + 1) = 0;
      *puVar2 = 0xffffffff;
      puVar2[2] = 0;
      *(undefined1 *)((int)puVar2 + 5) = 10;
      puVar1 = (undefined4 *)(&DAT_11766460)[local_8];
    }
    iVar4 = local_8 << 5;
    file_management_13(iVar4);
  }
LAB_10020254:
  unlock_resource(0x12);
  return iVar4;
}



undefined4 file_management_10(uint param_1,HANDLE param_2)

{
  undefined4 *puVar1;
  int iVar2;
  DWORD nStdHandle;
  
  if (param_1 < DAT_11766560) {
    iVar2 = (param_1 & 0x1f) * 0x24;
    if (*(int *)((&DAT_11766460)[(int)param_1 >> 5] + iVar2) == -1) {
      if (DAT_1003550c == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_100202be;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,param_2);
      }
LAB_100202be:
      *(HANDLE *)((&DAT_11766460)[(int)param_1 >> 5] + iVar2) = param_2;
      return 0;
    }
  }
  puVar1 = (undefined4 *)get_last_error();
  *puVar1 = 9;
  puVar1 = (undefined4 *)get_last_error_2();
  *puVar1 = 0;
  return 0xffffffff;
}



undefined4 file_management_11(uint param_1)

{
  int *piVar1;
  undefined4 *puVar2;
  int iVar3;
  DWORD nStdHandle;
  
  if (param_1 < DAT_11766560) {
    iVar3 = (param_1 & 0x1f) * 0x24;
    piVar1 = (int *)((&DAT_11766460)[(int)param_1 >> 5] + iVar3);
    if (((*(byte *)(piVar1 + 1) & 1) != 0) && (*piVar1 != -1)) {
      if (DAT_1003550c == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_1002033d;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,(HANDLE)0x0);
      }
LAB_1002033d:
      *(undefined4 *)((&DAT_11766460)[(int)param_1 >> 5] + iVar3) = 0xffffffff;
      return 0;
    }
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 9;
  puVar2 = (undefined4 *)get_last_error_2();
  *puVar2 = 0;
  return 0xffffffff;
}



undefined4 file_management_12(uint param_1)

{
  undefined4 *puVar1;
  
  if ((param_1 < DAT_11766560) &&
     ((*(byte *)((&DAT_11766460)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x24) & 1) != 0)) {
    return *(undefined4 *)((&DAT_11766460)[(int)param_1 >> 5] + (param_1 & 0x1f) * 0x24);
  }
  puVar1 = (undefined4 *)get_last_error();
  *puVar1 = 9;
  puVar1 = (undefined4 *)get_last_error_2();
  *puVar1 = 0;
  return 0xffffffff;
}



void file_management_13(uint param_1)

{
  int iVar1;
  int iVar2;
  
  iVar2 = (param_1 & 0x1f) * 0x24;
  iVar1 = (&DAT_11766460)[(int)param_1 >> 5] + iVar2;
  if (*(int *)(iVar1 + 8) == 0) {
    lock_resource(0x11);
    if (*(int *)(iVar1 + 8) == 0) {
      InitializeCriticalSection((LPCRITICAL_SECTION)(iVar1 + 0xc));
      *(int *)(iVar1 + 8) = *(int *)(iVar1 + 8) + 1;
    }
    unlock_resource(0x11);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((&DAT_11766460)[(int)param_1 >> 5] + 0xc + iVar2));
  return;
}



void file_management_14(uint param_1)

{
  LeaveCriticalSection
            ((LPCRITICAL_SECTION)
             ((&DAT_11766460)[(int)param_1 >> 5] + 0xc + (param_1 & 0x1f) * 0x24));
  return;
}



byte file_management_15(uint param_1)

{
  if (DAT_11766560 <= param_1) {
    return 0;
  }
  return *(byte *)((&DAT_11766460)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x24) & 0x40;
}



uint file_management_16(LPCSTR param_1,uint param_2,uint param_3,uint param_4)

{
  byte *pbVar1;
  uint uVar2;
  uint file_descriptor;
  undefined4 *puVar3;
  HANDLE hFile;
  DWORD DVar4;
  int *piVar5;
  int iVar6;
  uint32_t uVar7;
  int iVar8;
  bool bVar9;
  _SECURITY_ATTRIBUTES local_20;
  DWORD local_14;
  DWORD local_10;
  DWORD local_c;
  byte local_5;
  
  bVar9 = (param_2 & 0x80) == 0;
  local_20.nLength = 0xc;
  local_20.lpSecurityDescriptor = (LPVOID)0x0;
  if (bVar9) {
    local_5 = 0;
  }
  else {
    local_5 = 0x10;
  }
  local_20.bInheritHandle = (BOOL)bVar9;
  if (((param_2 & 0x8000) == 0) && (((param_2 & 0x4000) != 0 || (DAT_10035844 != 0x8000)))) {
    local_5 = local_5 | 0x80;
  }
  uVar2 = param_2 & 3;
  if (uVar2 == 0) {
    local_10 = 0x80000000;
  }
  else if (uVar2 == 1) {
    local_10 = 0x40000000;
  }
  else {
    if (uVar2 != 2) goto LAB_10020550;
    local_10 = 0xc0000000;
  }
  if (param_3 == 0x10) {
    local_14 = 0;
  }
  else if (param_3 == 0x20) {
    local_14 = 1;
  }
  else if (param_3 == 0x30) {
    local_14 = 2;
  }
  else {
    if (param_3 != 0x40) goto LAB_10020550;
    local_14 = 3;
  }
  uVar2 = param_2 & 0x700;
  if (uVar2 < 0x401) {
    if ((uVar2 == 0x400) || (uVar2 == 0)) {
      local_c = 3;
    }
    else if (uVar2 == 0x100) {
      local_c = 4;
    }
    else {
      if (uVar2 == 0x200) goto LAB_1002056a;
      if (uVar2 != 0x300) goto LAB_10020550;
      local_c = 2;
    }
  }
  else {
    if (uVar2 != 0x500) {
      if (uVar2 == 0x600) {
LAB_1002056a:
        local_c = 5;
        goto LAB_1002057a;
      }
      if (uVar2 != 0x700) {
LAB_10020550:
        puVar3 = (undefined4 *)get_last_error();
        *puVar3 = 0x16;
        puVar3 = (undefined4 *)get_last_error_2();
        *puVar3 = 0;
        return 0xffffffff;
      }
    }
    local_c = 1;
  }
LAB_1002057a:
  uVar2 = 0x80;
  if (((param_2 & 0x100) != 0) && ((~DAT_100354b0 & param_4 & 0x80) == 0)) {
    uVar2 = 1;
  }
  if ((param_2 & 0x40) != 0) {
    uVar2 = uVar2 | 0x4000000;
    local_10 = CONCAT13(local_10._3_1_,0x10000);
  }
  if ((param_2 & 0x1000) != 0) {
    uVar2 = uVar2 | 0x100;
  }
  if ((param_2 & 0x20) == 0) {
    if ((param_2 & 0x10) != 0) {
      uVar2 = uVar2 | 0x10000000;
    }
  }
  else {
    uVar2 = uVar2 | 0x8000000;
  }
  file_descriptor = file_management_9();
  if (file_descriptor == 0xffffffff) {
    puVar3 = (undefined4 *)get_last_error();
    *puVar3 = 0x18;
    puVar3 = (undefined4 *)get_last_error_2();
    *puVar3 = 0;
    return 0xffffffff;
  }
  hFile = CreateFileA(param_1,local_10,local_14,&local_20,local_c,uVar2,(HANDLE)0x0);
  if (hFile != (HANDLE)0xffffffff) {
    DVar4 = GetFileType(hFile);
    if (DVar4 != 0) {
      if (DVar4 == 2) {
        local_5 = local_5 | 0x40;
      }
      else if (DVar4 == 3) {
        local_5 = local_5 | 8;
      }
      file_management_10(file_descriptor,hFile);
      iVar8 = (file_descriptor & 0x1f) * 0x24;
      param_1._3_1_ = local_5 & 0x48;
      *(byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + iVar8) = local_5 | 1;
      if ((((local_5 & 0x48) == 0) && ((local_5 & 0x80) != 0)) && ((param_2 & 2) != 0)) {
        local_14 = file_io_6(file_descriptor,-1,2);
        if (local_14 == 0xffffffff) {
          piVar5 = (int *)get_last_error_2();
          if (*piVar5 == 0x83) goto LAB_100206f4;
        }
        else {
          param_3 = param_3 & 0xffffff;
          iVar6 = file_io_17(file_descriptor,(void *)((int)&param_3 + 3),1);
          if ((((iVar6 != 0) || (param_3._3_1_ != '\x1a')) ||
              (iVar6 = file_io_48(file_descriptor,local_14), iVar6 != -1)) &&
             (uVar7 = file_io_6(file_descriptor,0,0), uVar7 != 0xffffffff)) goto LAB_100206f4;
        }
        close_file_handle(file_descriptor);
        uVar2 = 0xffffffff;
      }
      else {
LAB_100206f4:
        uVar2 = file_descriptor;
        if ((param_1._3_1_ == 0) && ((param_2 & 8) != 0)) {
          pbVar1 = (byte *)((&DAT_11766460)[(int)file_descriptor >> 5] + 4 + iVar8);
          *pbVar1 = *pbVar1 | 0x20;
        }
      }
      goto LAB_1002070d;
    }
    CloseHandle(hFile);
  }
  DVar4 = GetLastError();
  get_error_code(DVar4);
  uVar2 = 0xffffffff;
LAB_1002070d:
  file_management_14(file_descriptor);
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void file_io_31(undefined4 *param_1)

{
  void *pvVar1;
  
  _DAT_10035510 = _DAT_10035510 + 1;
  pvVar1 = _malloc(0x1000);
  param_1[2] = pvVar1;
  if (pvVar1 == (void *)0x0) {
    param_1[3] = param_1[3] | 4;
    param_1[2] = param_1 + 5;
    param_1[6] = 2;
  }
  else {
    param_1[3] = param_1[3] | 8;
    param_1[6] = 0x1000;
  }
  param_1[1] = 0;
  *param_1 = param_1[2];
  return;
}



undefined4 char_to_upper_15(undefined4 param_1,undefined4 param_2)

{
  undefined4 uVar1;
  bool bVar2;
  
  InterlockedIncrement((LONG *)&DAT_1176642c);
  bVar2 = DAT_11766428 != 0;
  if (bVar2) {
    InterlockedDecrement((LONG *)&DAT_1176642c);
    lock_resource(0x13);
  }
  uVar1 = char_to_upper_16(param_1,param_2);
  if (bVar2) {
    unlock_resource(0x13);
  }
  else {
    InterlockedDecrement((LONG *)&DAT_1176642c);
  }
  return uVar1;
}



LPSTR char_to_upper_16(LPSTR param_1,WCHAR param_2)

{
  LPSTR pCVar1;
  undefined4 *puVar2;
  
  pCVar1 = param_1;
  if (param_1 == (LPSTR)0x0) {
    return param_1;
  }
  if (DAT_100355bc == 0) {
    if ((ushort)param_2 < 0x100) {
      *param_1 = (CHAR)param_2;
      return (LPSTR)0x1;
    }
  }
  else {
    param_1 = (LPSTR)0x0;
    pCVar1 = (LPSTR)WideCharToMultiByte(DAT_100355cc,0x220,&param_2,1,pCVar1,DAT_10033ee0,
                                        (LPCSTR)0x0,(LPBOOL)&param_1);
    if ((pCVar1 != (LPSTR)0x0) && (param_1 == (LPSTR)0x0)) {
      return pCVar1;
    }
  }
  puVar2 = (undefined4 *)get_last_error();
  *puVar2 = 0x2a;
  return (LPSTR)0xffffffff;
}



// Library Function - Single Match
//  __aulldiv
// 
// Library: Visual Studio

undefined8 __aulldiv(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar3 = param_1;
  uVar8 = param_4;
  uVar6 = param_2;
  uVar9 = param_3;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar5 = uVar8 >> 1;
      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar8 = uVar5;
      uVar6 = uVar7;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar8 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  __aullrem
// 
// Library: Visual Studio

undefined8 __aullrem(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  bool bVar11;
  
  uVar3 = param_1;
  uVar4 = param_4;
  uVar9 = param_2;
  uVar10 = param_3;
  if (param_4 == 0) {
    iVar6 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) %
                 (ulonglong)param_3);
    iVar7 = 0;
  }
  else {
    do {
      uVar5 = uVar4 >> 1;
      uVar10 = uVar10 >> 1 | (uint)((uVar4 & 1) != 0) << 0x1f;
      uVar8 = uVar9 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar4 = uVar5;
      uVar9 = uVar8;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar8,uVar3) / (ulonglong)uVar10;
    uVar3 = (int)uVar1 * param_4;
    lVar2 = (uVar1 & 0xffffffff) * (ulonglong)param_3;
    uVar9 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar4 = (uint)lVar2;
    uVar10 = uVar9 + uVar3;
    if (((CARRY4(uVar9,uVar3)) || (param_2 < uVar10)) || ((param_2 <= uVar10 && (param_1 < uVar4))))
    {
      bVar11 = uVar4 < param_3;
      uVar4 = uVar4 - param_3;
      uVar10 = (uVar10 - param_4) - (uint)bVar11;
    }
    iVar6 = -(uVar4 - param_1);
    iVar7 = -(uint)(uVar4 - param_1 != 0) - ((uVar10 - param_2) - (uint)(uVar4 < param_1));
  }
  return CONCAT44(iVar7,iVar6);
}



void time_management(void)

{
  if (DAT_100357a0 == 0) {
    lock_resource(0xb);
    if (DAT_100357a0 == 0) {
      time_management_2();
      DAT_100357a0 = DAT_100357a0 + 1;
    }
    unlock_resource(0xb);
  }
  return;
}



void time_management_2(void)

{
  char cVar1;
  char cVar2;
  char *_Str1;
  DWORD DVar3;
  int iVar4;
  size_t sVar5;
  char *source;
  int local_8;
  
  lock_resource(0xc);
  DAT_10034028 = 0xffffffff;
  DAT_10034018 = 0xffffffff;
  DAT_100356e8 = 0;
  _Str1 = (char *)env_var_management_13(&DAT_10026458);
  if (_Str1 == (char *)0x0) {
    unlock_resource(0xc);
    DVar3 = GetTimeZoneInformation((LPTIME_ZONE_INFORMATION)&DAT_100356f0);
    if (DVar3 == 0xffffffff) {
      return;
    }
    DAT_10033f80 = DAT_100356f0 * 0x3c;
    DAT_100356e8 = 1;
    if (DAT_10035736 != 0) {
      DAT_10033f80 = DAT_10033f80 + DAT_10035744 * 0x3c;
    }
    if ((DAT_1003578a == 0) || (DAT_10035798 == 0)) {
      DAT_10033f84 = 0;
      DAT_10033f88 = 0;
    }
    else {
      DAT_10033f84 = 1;
      DAT_10033f88 = (DAT_10035798 - DAT_10035744) * 0x3c;
    }
    iVar4 = WideCharToMultiByte(DAT_100355cc,0x220,(LPCWSTR)&DAT_100356f4,-1,PTR_DAT_1003400c,0x3f,
                                (LPCSTR)0x0,&local_8);
    if ((iVar4 == 0) || (local_8 != 0)) {
      *PTR_DAT_1003400c = 0;
    }
    else {
      PTR_DAT_1003400c[0x3f] = 0;
    }
    iVar4 = WideCharToMultiByte(DAT_100355cc,0x220,(LPCWSTR)&DAT_10035748,-1,PTR_DAT_10034010,0x3f,
                                (LPCSTR)0x0,&local_8);
    if ((iVar4 != 0) && (local_8 == 0)) {
      PTR_DAT_10034010[0x3f] = 0;
      return;
    }
LAB_10020bb4:
    *PTR_DAT_10034010 = 0;
  }
  else {
    if ((*_Str1 != '\0') &&
       ((DAT_1003579c == (char *)0x0 || (iVar4 = _strcmp(_Str1,DAT_1003579c), iVar4 != 0)))) {
      free_memory(DAT_1003579c);
      sVar5 = _strlen(_Str1);
      DAT_1003579c = (char *)_malloc(sVar5 + 1);
      if (DAT_1003579c != (char *)0x0) {
        strcpy_internal_2(DAT_1003579c,_Str1);
        unlock_resource(0xc);
        _strncpy(PTR_DAT_1003400c,_Str1,3);
        source = _Str1 + 3;
        PTR_DAT_1003400c[3] = 0;
        cVar2 = *source;
        if (cVar2 == '-') {
          source = _Str1 + 4;
        }
        iVar4 = str_to_int_7(source);
        DAT_10033f80 = iVar4 * 0xe10;
        for (; (cVar1 = *source, cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':'))));
            source = source + 1) {
        }
        if (*source == ':') {
          source = source + 1;
          iVar4 = str_to_int_7(source);
          DAT_10033f80 = DAT_10033f80 + iVar4 * 0x3c;
          for (; ('/' < *source && (*source < ':')); source = source + 1) {
          }
          if (*source == ':') {
            source = source + 1;
            iVar4 = str_to_int_7(source);
            DAT_10033f80 = DAT_10033f80 + iVar4;
            for (; ('/' < *source && (*source < ':')); source = source + 1) {
            }
          }
        }
        if (cVar2 == '-') {
          DAT_10033f80 = -DAT_10033f80;
        }
        DAT_10033f84 = (int)*source;
        if (DAT_10033f84 != 0) {
          _strncpy(PTR_DAT_10034010,source,3);
          PTR_DAT_10034010[3] = 0;
          return;
        }
        goto LAB_10020bb4;
      }
    }
    unlock_resource(0xc);
  }
  return;
}



undefined4 time_management_3(undefined4 param_1)

{
  undefined4 uVar1;
  
  lock_resource(0xb);
  uVar1 = time_management_4(param_1);
  unlock_resource(0xb);
  return uVar1;
}



bool time_management_4(int *param_1)

{
  int iVar1;
  int iVar2;
  undefined2 uVar3;
  undefined2 uVar4;
  undefined2 uVar5;
  
  if (DAT_10033f84 != 0) {
    iVar2 = param_1[5];
    if ((iVar2 != DAT_10034018) || (iVar2 != DAT_10034028)) {
      if (DAT_100356e8 == 0) {
        time_management_5(1,1,iVar2,4,1,0,0,2,0,0,0);
        time_management_5(0,1,param_1[5],10,5,0,0,2,0,0,0);
      }
      else {
        if (DAT_10035788 != 0) {
          uVar4 = 0;
          uVar3 = 0;
          uVar5 = DAT_1003578e;
        }
        else {
          uVar4 = DAT_1003578c;
          uVar3 = DAT_1003578e;
          uVar5 = 0;
        }
        time_management_5(1,DAT_10035788 == 0,iVar2,DAT_1003578a,uVar3,uVar4,uVar5,DAT_10035790,
                          DAT_10035792,DAT_10035794,DAT_10035796);
        if (DAT_10035734 != 0) {
          uVar4 = 0;
          uVar3 = 0;
          iVar2 = param_1[5];
          uVar5 = DAT_1003573a;
        }
        else {
          iVar2 = param_1[5];
          uVar4 = DAT_10035738;
          uVar3 = DAT_1003573a;
          uVar5 = 0;
        }
        time_management_5(0,DAT_10035734 == 0,iVar2,DAT_10035736,uVar3,uVar4,uVar5,DAT_1003573c,
                          DAT_1003573e,DAT_10035740,DAT_10035742);
      }
    }
    iVar2 = param_1[7];
    if (DAT_1003401c < DAT_1003402c) {
      if ((DAT_1003401c <= iVar2) && (iVar2 <= DAT_1003402c)) {
        if ((DAT_1003401c < iVar2) && (iVar2 < DAT_1003402c)) {
          return true;
        }
LAB_10020d63:
        iVar1 = ((param_1[2] * 0x3c + param_1[1]) * 0x3c + *param_1) * 1000;
        if (iVar2 == DAT_1003401c) {
          return DAT_10034020 <= iVar1;
        }
        return iVar1 < DAT_10034030;
      }
    }
    else {
      if (iVar2 < DAT_1003402c) {
        return true;
      }
      if (DAT_1003401c < iVar2) {
        return true;
      }
      if ((iVar2 <= DAT_1003402c) || (DAT_1003401c <= iVar2)) goto LAB_10020d63;
    }
  }
  return false;
}



void time_management_5(int param_1,int param_2,uint param_3,int param_4,int param_5,int param_6,
                      int param_7,int param_8,int param_9,int param_10,int param_11)

{
  int iVar1;
  int iVar2;
  
  if (param_2 == 1) {
    if ((param_3 & 3) == 0) {
      iVar1 = (&DAT_10034030)[param_4];
    }
    else {
      iVar1 = *(int *)(&DAT_10034064 + param_4 * 4);
    }
    iVar2 = (int)(param_3 * 0x16d + -0x63db + iVar1 + 1 + ((int)(param_3 - 1) >> 2)) % 7;
    if (param_6 < iVar2) {
      iVar1 = iVar1 + 1 + (param_5 * 7 - iVar2) + param_6;
    }
    else {
      iVar1 = iVar1 + -6 + (param_5 * 7 - iVar2) + param_6;
    }
    if (param_5 == 5) {
      if ((param_3 & 3) == 0) {
        iVar2 = *(int *)(&DAT_10034034 + param_4 * 4);
      }
      else {
        iVar2 = (&DAT_10034068)[param_4];
      }
      if (iVar2 < iVar1) {
        iVar1 = iVar1 + -7;
      }
    }
  }
  else {
    if ((param_3 & 3) == 0) {
      iVar1 = (&DAT_10034030)[param_4];
    }
    else {
      iVar1 = *(int *)(&DAT_10034064 + param_4 * 4);
    }
    iVar1 = iVar1 + param_7;
  }
  if (param_1 == 1) {
    DAT_10034018 = param_3;
    DAT_10034020 = ((param_8 * 0x3c + param_9) * 0x3c + param_10) * 1000 + param_11;
    DAT_1003401c = iVar1;
  }
  else {
    DAT_10034030 = ((param_8 * 0x3c + param_9) * 0x3c + DAT_10033f88 + param_10) * 1000 + param_11;
    if (DAT_10034030 < 0) {
      DAT_10034030 = DAT_10034030 + 86400000;
      DAT_1003402c = iVar1 + -1;
    }
    else {
      DAT_1003402c = iVar1;
      if (86399999 < DAT_10034030) {
        DAT_10034030 = DAT_10034030 + -86400000;
        DAT_1003402c = iVar1 + 1;
      }
    }
    DAT_10034028 = param_3;
  }
  return;
}



int * time_management_6(int *param_1)

{
  bool bVar1;
  int iVar2;
  void *pvVar3;
  int iVar4;
  int *piVar5;
  int *piVar6;
  int iVar7;
  int iVar8;
  int *piVar9;
  
  iVar4 = *param_1;
  bVar1 = false;
  iVar2 = get_tls_block();
  if (iVar4 < 0) {
    return (int *)0x0;
  }
  if (*(int *)(iVar2 + 0x40) == 0) {
    pvVar3 = _malloc(0x24);
    *(void **)(iVar2 + 0x40) = pvVar3;
    piVar5 = (int *)&DAT_100357a8;
    if (pvVar3 == (void *)0x0) goto LAB_10020f11;
  }
  piVar5 = *(int **)(iVar2 + 0x40);
LAB_10020f11:
  iVar7 = iVar4 % 0x7861f80;
  iVar4 = (iVar4 / 0x7861f80) * 4;
  iVar2 = iVar4 + 0x46;
  iVar8 = iVar7;
  if (0x1e1337f < iVar7) {
    iVar8 = iVar7 + -0x1e13380;
    iVar2 = iVar4 + 0x47;
    if (0x1e1337f < iVar8) {
      iVar8 = iVar7 + -0x3c26700;
      iVar2 = iVar4 + 0x48;
      if (iVar8 < 0x1e28500) {
        bVar1 = true;
      }
      else {
        iVar2 = iVar4 + 0x49;
        iVar8 = iVar7 + -0x5a4ec00;
      }
    }
  }
  piVar5[5] = iVar2;
  piVar9 = (int *)&DAT_10034034;
  piVar5[7] = iVar8 / 0x15180;
  if (!bVar1) {
    piVar9 = &DAT_10034068;
  }
  iVar4 = 1;
  piVar6 = piVar9;
  while (piVar6 = piVar6 + 1, *piVar6 < piVar5[7]) {
    iVar4 = iVar4 + 1;
  }
  piVar5[4] = iVar4 + -1;
  piVar5[3] = piVar5[7] - piVar9[iVar4 + -1];
  piVar5[6] = (*param_1 / 0x15180 + 4) % 7;
  piVar5[2] = (iVar8 % 0x15180) / 0xe10;
  iVar4 = (iVar8 % 0x15180) % 0xe10;
  piVar5[1] = iVar4 / 0x3c;
  piVar5[8] = 0;
  *piVar5 = iVar4 % 0x3c;
  return piVar5;
}



void str_to_int(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  str_to_int_2(param_1,param_2,param_3,0);
  return;
}



void * __thiscall
str_to_int_2(undefined *param_1,byte *param_2,int *param_3,void *param_4,uint param_5)

{
  void *pvVar1;
  uint32_t uVar2;
  void *pvVar3;
  int iVar4;
  undefined4 *puVar5;
  void *this;
  byte bVar6;
  uint char_val;
  uint32_t unaff_EDI;
  undefined *puVar7;
  void *local_c;
  byte *local_8;
  
  local_c = (void *)0x0;
  bVar6 = *param_2;
  local_8 = param_2 + 1;
  while( true ) {
    if (DAT_10033ee0 < 2) {
      uVar2 = (byte)PTR_DAT_10033cd4[(uint)bVar6 * 2] & 8;
      param_1 = PTR_DAT_10033cd4;
    }
    else {
      puVar7 = (undefined *)0x8;
      uVar2 = get_char_property(param_1,(uint)bVar6,8,unaff_EDI);
      param_1 = puVar7;
    }
    if (uVar2 == 0) break;
    bVar6 = *local_8;
    local_8 = local_8 + 1;
  }
  if (bVar6 == 0x2d) {
    param_5 = param_5 | 2;
LAB_10021053:
    bVar6 = *local_8;
    local_8 = local_8 + 1;
  }
  else if (bVar6 == 0x2b) goto LAB_10021053;
  if ((((int)param_4 < 0) || (param_4 == (void *)0x1)) || (0x24 < (int)param_4)) {
    if (param_3 != (int *)0x0) {
      *param_3 = (int)param_2;
    }
    return (void *)0x0;
  }
  this = (void *)0x10;
  if (param_4 == (void *)0x0) {
    if (bVar6 != 0x30) {
      param_4 = (void *)0xa;
      goto LAB_100210bd;
    }
    if ((*local_8 != 0x78) && (*local_8 != 0x58)) {
      param_4 = (void *)0x8;
      goto LAB_100210bd;
    }
    param_4 = (void *)0x10;
  }
  if (((param_4 == (void *)0x10) && (bVar6 == 0x30)) && ((*local_8 == 0x78 || (*local_8 == 0x58))))
  {
    bVar6 = local_8[1];
    local_8 = local_8 + 2;
  }
LAB_100210bd:
  pvVar3 = (void *)(0xffffffff / ZEXT48(param_4));
  do {
    char_val = (uint)bVar6;
    if (DAT_10033ee0 < 2) {
      uVar2 = (byte)PTR_DAT_10033cd4[char_val * 2] & 4;
    }
    else {
      pvVar1 = (void *)0x4;
      uVar2 = get_char_property(this,char_val,4,unaff_EDI);
      this = pvVar1;
    }
    if (uVar2 == 0) {
      if (DAT_10033ee0 < 2) {
        uVar2 = *(ushort *)(PTR_DAT_10033cd4 + char_val * 2) & 0x103;
      }
      else {
        uVar2 = get_char_property(this,char_val,0x103,unaff_EDI);
      }
      if (uVar2 == 0) {
LAB_10021169:
        local_8 = local_8 + -1;
        if ((param_5 & 8) == 0) {
          if (param_3 != (int *)0x0) {
            local_8 = param_2;
          }
          local_c = (void *)0x0;
        }
        else if (((param_5 & 4) != 0) ||
                (((param_5 & 1) == 0 &&
                 ((((param_5 & 2) != 0 && ((void *)0x80000000 < local_c)) ||
                  (((param_5 & 2) == 0 && ((void *)0x7fffffff < local_c)))))))) {
          puVar5 = (undefined4 *)get_last_error();
          *puVar5 = 0x22;
          if ((param_5 & 1) == 0) {
            local_c = (void *)(((param_5 & 2) != 0) + 0x7fffffff);
          }
          else {
            local_c = (void *)0xffffffff;
          }
        }
        if (param_3 != (int *)0x0) {
          *param_3 = (int)local_8;
        }
        if ((param_5 & 2) == 0) {
          return local_c;
        }
        return (void *)-(int)local_c;
      }
      iVar4 = char_to_upper((int)(char)bVar6);
      this = (void *)(iVar4 + -0x37);
    }
    else {
      this = (void *)((char)bVar6 + -0x30);
    }
    if (param_4 <= this) goto LAB_10021169;
    if ((local_c < pvVar3) ||
       ((local_c == pvVar3 && (this <= (void *)(0xffffffff % ZEXT48(param_4)))))) {
      local_c = (void *)((int)local_c * (int)param_4 + (int)this);
      param_5 = param_5 | 8;
    }
    else {
      param_5 = param_5 | 0xc;
    }
    bVar6 = *local_8;
    local_8 = local_8 + 1;
  } while( true );
}



// Library Function - Single Match
//  _strncmp
// 
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  char cVar1;
  char cVar2;
  size_t sVar3;
  int iVar4;
  uint uVar5;
  char *pcVar6;
  char *pcVar7;
  
  sVar3 = _MaxCount;
  pcVar6 = _Str1;
  if (_MaxCount != 0) {
    do {
      if (sVar3 == 0) break;
      sVar3 = sVar3 - 1;
      cVar1 = *pcVar6;
      pcVar6 = pcVar6 + 1;
    } while (cVar1 != '\0');
    iVar4 = _MaxCount - sVar3;
    do {
      pcVar6 = _Str2;
      pcVar7 = _Str1;
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      pcVar7 = _Str1 + 1;
      pcVar6 = _Str2 + 1;
      cVar2 = *_Str1;
      cVar1 = *_Str2;
      _Str2 = pcVar6;
      _Str1 = pcVar7;
    } while (cVar1 == cVar2);
    uVar5 = 0;
    if ((byte)pcVar6[-1] <= (byte)pcVar7[-1]) {
      if (pcVar6[-1] == pcVar7[-1]) {
        return 0;
      }
      uVar5 = 0xfffffffe;
    }
    _MaxCount = ~uVar5;
  }
  return _MaxCount;
}



// Library Function - Single Match
//  _memset
// 
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  uint uVar1;
  uint uVar2;
  size_t sVar3;
  uint *puVar4;
  
  if (_Size == 0) {
    return _Dst;
  }
  uVar1 = _Val & 0xff;
  puVar4 = (uint *)_Dst;
  if (3 < _Size) {
    uVar2 = -(int)_Dst & 3;
    sVar3 = _Size;
    if (uVar2 != 0) {
      sVar3 = _Size - uVar2;
      do {
        *(undefined1 *)puVar4 = (undefined1)_Val;
        puVar4 = (uint *)((int)puVar4 + 1);
        uVar2 = uVar2 - 1;
      } while (uVar2 != 0);
    }
    uVar1 = uVar1 * 0x1010101;
    _Size = sVar3 & 3;
    uVar2 = sVar3 >> 2;
    if (uVar2 != 0) {
      for (; uVar2 != 0; uVar2 = uVar2 - 1) {
        *puVar4 = uVar1;
        puVar4 = puVar4 + 1;
      }
      if (_Size == 0) {
        return _Dst;
      }
    }
  }
  do {
    *(char *)puVar4 = (char)uVar1;
    puVar4 = (uint *)((int)puVar4 + 1);
    _Size = _Size - 1;
  } while (_Size != 0);
  return _Dst;
}



uint bitwise_op(uint param_1,uint param_2)

{
  uint uVar1;
  
  uVar1 = bitwise_op_3();
  uVar1 = uVar1 & ~param_2 | param_1 & param_2;
  bitwise_op_4(uVar1);
  return uVar1;
}



void bitwise_op_2(undefined4 param_1,uint param_2)

{
  bitwise_op(param_1,param_2 & 0xfff7ffff);
  return;
}



uint bitwise_op_3(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  if ((param_1 & 1) != 0) {
    uVar1 = 0x10;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((param_1 & 0x10) != 0) {
    uVar1 = uVar1 | 2;
  }
  if ((param_1 & 0x20) != 0) {
    uVar1 = uVar1 | 1;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x80000;
  }
  uVar2 = param_1 & 0xc00;
  if (uVar2 != 0) {
    if (uVar2 == 0x400) {
      uVar1 = uVar1 | 0x100;
    }
    else if (uVar2 == 0x800) {
      uVar1 = uVar1 | 0x200;
    }
    else if (uVar2 == 0xc00) {
      uVar1 = uVar1 | 0x300;
    }
  }
  if ((param_1 & 0x300) == 0) {
    uVar1 = uVar1 | 0x20000;
  }
  else if ((param_1 & 0x300) == 0x200) {
    uVar1 = uVar1 | 0x10000;
  }
  if ((param_1 & 0x1000) != 0) {
    uVar1 = uVar1 | 0x40000;
  }
  return uVar1;
}



uint bitwise_op_4(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = (uint)((param_1 & 0x10) != 0);
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x20;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 2;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x400;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x800;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0xc00;
    }
  }
  if ((param_1 & 0x30000) == 0) {
    uVar1 = uVar1 | 0x300;
  }
  else if ((param_1 & 0x30000) == 0x10000) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 0x40000) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  return uVar1;
}



int char_to_upper_19(int param_1)

{
  bool bVar1;
  
  if (DAT_100355bc == 0) {
    if ((0x40 < param_1) && (param_1 < 0x5b)) {
      return param_1 + 0x20;
    }
  }
  else {
    InterlockedIncrement((LONG *)&DAT_1176642c);
    bVar1 = DAT_11766428 != 0;
    if (bVar1) {
      InterlockedDecrement((LONG *)&DAT_1176642c);
      lock_resource(0x13);
    }
    param_1 = char_to_upper_20(param_1);
    if (bVar1) {
      unlock_resource(0x13);
    }
    else {
      InterlockedDecrement((LONG *)&DAT_1176642c);
    }
  }
  return param_1;
}



uint32_t __thiscall char_to_upper_20(void *param_1,uint32_t param_2)

{
  uint uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  undefined4 uVar4;
  int iVar5;
  uint32_t unaff_EDI;
  void *local_8;
  
  uVar2 = param_2;
  if (DAT_100355bc == 0) {
    if ((0x40 < (int)param_2) && ((int)param_2 < 0x5b)) {
      uVar2 = param_2 + 0x20;
    }
  }
  else {
    uVar4 = 1;
    local_8 = param_1;
    if ((int)param_2 < 0x100) {
      if (DAT_10033ee0 < 2) {
        uVar3 = (byte)PTR_DAT_10033cd4[param_2 * 2] & 1;
      }
      else {
        uVar3 = get_char_property(param_1,param_2,1,unaff_EDI);
      }
      if (uVar3 == 0) {
        return uVar2;
      }
    }
    if ((PTR_DAT_10033cd4[((int)uVar2 >> 8 & 0xffU) * 2 + 1] & 0x80) == 0) {
      param_2 = CONCAT31((int3)(param_2 >> 8),(char)uVar2) & 0xffff00ff;
    }
    else {
      uVar1 = param_2 >> 0x10;
      param_2._0_2_ = CONCAT11((char)uVar2,(char)(uVar2 >> 8));
      param_2 = CONCAT22((short)uVar1,(undefined2)param_2) & 0xff00ffff;
      uVar4 = 2;
    }
    iVar5 = string_map(DAT_100355bc,0x100,&param_2,uVar4,&local_8,3,0,1);
    if (iVar5 != 0) {
      if (iVar5 == 1) {
        uVar2 = (uint)local_8 & 0xff;
      }
      else {
        uVar2 = (uint)local_8 & 0xffff;
      }
    }
  }
  return uVar2;
}



undefined4 bitwise_op_5(int param_1,int param_2)

{
  int *piVar1;
  int iVar2;
  
  if ((*(uint *)(param_1 + (param_2 / 0x20) * 4) & ~(-1 << (0x1fU - (char)(param_2 % 0x20) & 0x1f)))
      != 0) {
    return 0;
  }
  iVar2 = param_2 / 0x20 + 1;
  if (iVar2 < 3) {
    piVar1 = (int *)(param_1 + iVar2 * 4);
    do {
      if (*piVar1 != 0) {
        return 0;
      }
      iVar2 = iVar2 + 1;
      piVar1 = piVar1 + 1;
    } while (iVar2 < 3);
  }
  return 1;
}



void bitwise_op_6(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  undefined4 *puVar3;
  
  puVar3 = (undefined4 *)(param_1 + (param_2 / 0x20) * 4);
  iVar1 = bitwise_op_15(*puVar3,1 << (0x1fU - (char)(param_2 % 0x20) & 0x1f),puVar3);
  iVar2 = param_2 / 0x20 + -1;
  if (-1 < iVar2) {
    puVar3 = (undefined4 *)(param_1 + iVar2 * 4);
    do {
      if (iVar1 == 0) {
        return;
      }
      iVar1 = bitwise_op_15(*puVar3,1,puVar3);
      iVar2 = iVar2 + -1;
      puVar3 = puVar3 + -1;
    } while (-1 < iVar2);
  }
  return;
}



undefined4 bitwise_op_7(int param_1,int param_2)

{
  uint *puVar1;
  int iVar2;
  byte bVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 local_8;
  
  local_8 = 0;
  puVar1 = (uint *)(param_1 + (param_2 / 0x20) * 4);
  bVar3 = 0x1f - (char)(param_2 % 0x20);
  if (((*puVar1 & 1 << (bVar3 & 0x1f)) != 0) &&
     (iVar2 = bitwise_op_5(param_1,param_2 + 1), iVar2 == 0)) {
    local_8 = bitwise_op_6(param_1,param_2 + -1);
  }
  *puVar1 = *puVar1 & -1 << (bVar3 & 0x1f);
  iVar2 = param_2 / 0x20 + 1;
  if (iVar2 < 3) {
    puVar5 = (undefined4 *)(param_1 + iVar2 * 4);
    for (iVar4 = 3 - iVar2; iVar4 != 0; iVar4 = iVar4 + -1) {
      *puVar5 = 0;
      puVar5 = puVar5 + 1;
    }
  }
  return local_8;
}



void memcpy_internal_13(int param_1,undefined4 *param_2)

{
  int iVar1;
  
  param_1 = param_1 - (int)param_2;
  iVar1 = 3;
  do {
    *(undefined4 *)(param_1 + (int)param_2) = *param_2;
    param_2 = param_2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



void memset_internal_2(undefined4 *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  return;
}



undefined4 memcmp_internal(int *param_1)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    if (*param_1 != 0) {
      return 0;
    }
    iVar1 = iVar1 + 1;
    param_1 = param_1 + 1;
  } while (iVar1 < 3);
  return 1;
}



void memcpy_internal_14(uint *param_1,uint param_2)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  int iVar4;
  int iVar5;
  uint *puVar6;
  int local_8;
  
  local_8 = 3;
  iVar2 = (int)param_2 / 0x20;
  iVar5 = (int)param_2 % 0x20;
  param_2 = 0;
  bVar3 = (byte)iVar5;
  puVar6 = param_1;
  do {
    uVar1 = *puVar6;
    *puVar6 = uVar1 >> (bVar3 & 0x1f) | param_2;
    puVar6 = puVar6 + 1;
    param_2 = (uVar1 & ~(-1 << (bVar3 & 0x1f))) << (0x20 - bVar3 & 0x1f);
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  iVar5 = 2;
  iVar4 = 8;
  do {
    if (iVar5 < iVar2) {
      *(undefined4 *)(iVar4 + (int)param_1) = 0;
    }
    else {
      *(undefined4 *)(iVar4 + (int)param_1) = *(undefined4 *)(iVar4 + iVar2 * -4 + (int)param_1);
    }
    iVar5 = iVar5 + -1;
    iVar4 = iVar4 + -4;
  } while (-1 < iVar4);
  return;
}



undefined4 float_conversion(ushort *param_1,uint *param_2,int *param_3)

{
  ushort uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  undefined4 uVar5;
  undefined1 local_1c [12];
  uint local_10;
  uint local_c;
  int local_8;
  
  uVar1 = param_1[5];
  local_10 = *(uint *)(param_1 + 3);
  local_c = *(uint *)(param_1 + 1);
  uVar3 = uVar1 & 0x7fff;
  iVar4 = uVar3 - 0x3fff;
  local_8 = (uint)*param_1 << 0x10;
  if (iVar4 == -0x3fff) {
    iVar4 = 0;
    iVar2 = memcmp_internal(&local_10);
    if (iVar2 != 0) {
LAB_1002185e:
      uVar5 = 0;
      goto LAB_10021860;
    }
    memset_internal_2(&local_10);
  }
  else {
    memcpy_internal_13(local_1c,&local_10);
    iVar2 = bitwise_op_7(&local_10,param_3[2]);
    if (iVar2 != 0) {
      iVar4 = uVar3 - 0x3ffe;
    }
    iVar2 = param_3[1];
    if (iVar4 < iVar2 - param_3[2]) {
      memset_internal_2(&local_10);
    }
    else {
      if (iVar2 < iVar4) {
        if (*param_3 <= iVar4) {
          memset_internal_2(&local_10);
          local_10 = local_10 | 0x80000000;
          memcpy_internal_14(&local_10,param_3[3]);
          iVar4 = param_3[5] + *param_3;
          uVar5 = 1;
          goto LAB_10021860;
        }
        local_10 = local_10 & 0x7fffffff;
        iVar4 = param_3[5] + iVar4;
        memcpy_internal_14(&local_10,param_3[3]);
        goto LAB_1002185e;
      }
      memcpy_internal_13(&local_10,local_1c);
      memcpy_internal_14(&local_10,iVar2 - iVar4);
      bitwise_op_7(&local_10,param_3[2]);
      memcpy_internal_14(&local_10,param_3[3] + 1);
    }
  }
  iVar4 = 0;
  uVar5 = 2;
LAB_10021860:
  local_10 = iVar4 << (0x1fU - (char)param_3[3] & 0x1f) |
             -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 | local_10;
  if (param_3[4] == 0x40) {
    param_2[1] = local_10;
    *param_2 = local_c;
  }
  else if (param_3[4] == 0x20) {
    *param_2 = local_10;
  }
  return uVar5;
}



void float_conversion_2(undefined4 param_1,undefined4 param_2)

{
  float_conversion(param_1,param_2,&DAT_10034130);
  return;
}



void float_conversion_3(undefined4 param_1,undefined4 param_2)

{
  float_conversion(param_1,param_2,&DAT_10034148);
  return;
}



void float_conversion_4(undefined4 param_1,undefined4 param_2)

{
  undefined1 local_10 [12];
  
  str_to_float_5(local_10,&param_2,param_2,0,0,0,0);
  float_conversion_2(local_10,param_1);
  return;
}



void float_conversion_5(undefined4 param_1,undefined4 param_2)

{
  undefined1 local_10 [12];
  
  str_to_float_5(local_10,&param_2,param_2,0,0,0,0);
  float_conversion_3(local_10,param_1);
  return;
}



void string_format(char *param_1,int param_2,int param_3)

{
  char *str;
  char *pcVar1;
  char *pcVar2;
  size_t sVar3;
  char *pcVar4;
  char cVar5;
  
  pcVar1 = param_1;
  pcVar4 = *(char **)(param_3 + 0xc);
  str = param_1 + 1;
  *param_1 = '0';
  pcVar2 = str;
  if (0 < param_2) {
    param_1 = (char *)param_2;
    param_2 = 0;
    do {
      cVar5 = *pcVar4;
      if (cVar5 == '\0') {
        cVar5 = '0';
      }
      else {
        pcVar4 = pcVar4 + 1;
      }
      *pcVar2 = cVar5;
      pcVar2 = pcVar2 + 1;
      param_1 = (char *)((int)param_1 + -1);
    } while (param_1 != (char *)0x0);
  }
  *pcVar2 = '\0';
  if ((-1 < param_2) && ('4' < *pcVar4)) {
    while (pcVar2 = pcVar2 + -1, *pcVar2 == '9') {
      *pcVar2 = '0';
    }
    *pcVar2 = *pcVar2 + '\x01';
  }
  if (*pcVar1 == '1') {
    *(int *)(param_3 + 4) = *(int *)(param_3 + 4) + 1;
  }
  else {
    sVar3 = _strlen(str);
    memcpy_internal(pcVar1,str,sVar3 + 1);
  }
  return;
}



int * string_format_2(undefined4 param_1,undefined4 param_2,int *param_3,int param_4)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  short local_2c;
  char local_2a;
  undefined1 local_28 [24];
  undefined4 local_10;
  undefined4 uStack_c;
  undefined2 uStack_8;
  
  float_conversion_6(&local_10,&param_1);
  iVar3 = float_conversion_13(local_10,uStack_c,uStack_8,0x11,0,&local_2c);
  iVar2 = param_4;
  piVar1 = param_3;
  param_3[2] = iVar3;
  *param_3 = (int)local_2a;
  param_3[1] = (int)local_2c;
  strcpy_internal_2(param_4,local_28);
  piVar1[3] = iVar2;
  return piVar1;
}



void float_conversion_6(uint *param_1,uint *param_2)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint local_8;
  
  uVar1 = *(ushort *)((int)param_2 + 6);
  uVar3 = (uVar1 & 0x7ff0) >> 4;
  uVar2 = *param_2;
  local_8 = 0x80000000;
  if (uVar3 == 0) {
    if (((param_2[1] & 0xfffff) == 0) && (uVar2 == 0)) {
      param_1[1] = 0;
      *param_1 = 0;
      *(undefined2 *)(param_1 + 2) = 0;
      return;
    }
    iVar4 = 0x3c01;
    local_8 = 0;
  }
  else if (uVar3 == 0x7ff) {
    iVar4 = 0x7fff;
  }
  else {
    iVar4 = uVar3 + 0x3c00;
  }
  local_8 = uVar2 >> 0x15 | (param_2[1] & 0xfffff) << 0xb | local_8;
  param_1[1] = local_8;
  *param_1 = uVar2 << 0xb;
  while ((local_8 & 0x80000000) == 0) {
    local_8 = *param_1 >> 0x1f | local_8 * 2;
    *param_1 = *param_1 * 2;
    param_1[1] = local_8;
    iVar4 = iVar4 + 0xffff;
  }
  *(ushort *)(param_1 + 2) = uVar1 & 0x8000 | (ushort)iVar4;
  return;
}



// Library Function - Single Match
//  __fptrap
// 
// Library: Visual Studio 2003 Release

void __cdecl __fptrap(void)

{
  __amsg_exit(2);
  return;
}



// Library Function - Single Match
//  _strcmp
// 
// Libraries: Visual Studio 1998 Debug, Visual Studio 1998 Release

int __cdecl _strcmp(char *_Str1,char *_Str2)

{
  undefined2 uVar1;
  undefined4 uVar2;
  byte bVar3;
  byte bVar4;
  bool bVar5;
  
  if (((uint)_Str1 & 3) != 0) {
    if (((uint)_Str1 & 1) != 0) {
      bVar4 = *_Str1;
      _Str1 = _Str1 + 1;
      bVar5 = bVar4 < (byte)*_Str2;
      if (bVar4 != *_Str2) goto LAB_10021b04;
      _Str2 = _Str2 + 1;
      if (bVar4 == 0) {
        return 0;
      }
      if (((uint)_Str1 & 2) == 0) goto LAB_10021ad0;
    }
    uVar1 = *(undefined2 *)_Str1;
    _Str1 = _Str1 + 2;
    bVar4 = (byte)uVar1;
    bVar5 = bVar4 < (byte)*_Str2;
    if (bVar4 != *_Str2) goto LAB_10021b04;
    if (bVar4 == 0) {
      return 0;
    }
    bVar4 = (byte)((ushort)uVar1 >> 8);
    bVar5 = bVar4 < ((byte *)_Str2)[1];
    if (bVar4 != ((byte *)_Str2)[1]) goto LAB_10021b04;
    if (bVar4 == 0) {
      return 0;
    }
    _Str2 = (char *)((byte *)_Str2 + 2);
  }
LAB_10021ad0:
  while( true ) {
    uVar2 = *(undefined4 *)_Str1;
    bVar4 = (byte)uVar2;
    bVar5 = bVar4 < (byte)*_Str2;
    if (bVar4 != *_Str2) break;
    if (bVar4 == 0) {
      return 0;
    }
    bVar4 = (byte)((uint)uVar2 >> 8);
    bVar5 = bVar4 < ((byte *)_Str2)[1];
    if (bVar4 != ((byte *)_Str2)[1]) break;
    if (bVar4 == 0) {
      return 0;
    }
    bVar4 = (byte)((uint)uVar2 >> 0x10);
    bVar5 = bVar4 < ((byte *)_Str2)[2];
    if (bVar4 != ((byte *)_Str2)[2]) break;
    bVar3 = (byte)((uint)uVar2 >> 0x18);
    if (bVar4 == 0) {
      return 0;
    }
    bVar5 = bVar3 < ((byte *)_Str2)[3];
    if (bVar3 != ((byte *)_Str2)[3]) break;
    _Str2 = (char *)((byte *)_Str2 + 4);
    _Str1 = _Str1 + 4;
    if (bVar3 == 0) {
      return 0;
    }
  }
LAB_10021b04:
  return (uint)bVar5 * -2 + 1;
}



// Setting prototype: byte *str_tokenize(byte *str, byte *delimiters)

int str_tokenize(byte *param_1,byte *param_2)

{
  byte bVar1;
  int iVar2;
  byte abStack_28 [32];
  
  abStack_28[0x1c] = 0;
  abStack_28[0x1d] = 0;
  abStack_28[0x1e] = 0;
  abStack_28[0x1f] = 0;
  abStack_28[0x18] = 0;
  abStack_28[0x19] = 0;
  abStack_28[0x1a] = 0;
  abStack_28[0x1b] = 0;
  abStack_28[0x14] = 0;
  abStack_28[0x15] = 0;
  abStack_28[0x16] = 0;
  abStack_28[0x17] = 0;
  abStack_28[0x10] = 0;
  abStack_28[0x11] = 0;
  abStack_28[0x12] = 0;
  abStack_28[0x13] = 0;
  abStack_28[0xc] = 0;
  abStack_28[0xd] = 0;
  abStack_28[0xe] = 0;
  abStack_28[0xf] = 0;
  abStack_28[8] = 0;
  abStack_28[9] = 0;
  abStack_28[10] = 0;
  abStack_28[0xb] = 0;
  abStack_28[4] = 0;
  abStack_28[5] = 0;
  abStack_28[6] = 0;
  abStack_28[7] = 0;
  abStack_28[0] = 0;
  abStack_28[1] = 0;
  abStack_28[2] = 0;
  abStack_28[3] = 0;
  while( true ) {
    bVar1 = *param_2;
    if (bVar1 == 0) break;
    param_2 = param_2 + 1;
    abStack_28[(int)(uint)bVar1 >> 3] = abStack_28[(int)(uint)bVar1 >> 3] | '\x01' << (bVar1 & 7);
  }
  iVar2 = -1;
  do {
    iVar2 = iVar2 + 1;
    bVar1 = *param_1;
    if (bVar1 == 0) {
      return iVar2;
    }
    param_1 = param_1 + 1;
  } while ((abStack_28[(int)(uint)bVar1 >> 3] >> (bVar1 & 7) & 1) == 0);
  return iVar2;
}



// Setting prototype: byte *str_tokenize_2(byte *str, byte *delimiters)

byte * str_tokenize_2(byte *param_1,byte *param_2)

{
  byte bVar1;
  byte *pbVar2;
  byte abStack_28 [32];
  
  abStack_28[0x1c] = 0;
  abStack_28[0x1d] = 0;
  abStack_28[0x1e] = 0;
  abStack_28[0x1f] = 0;
  abStack_28[0x18] = 0;
  abStack_28[0x19] = 0;
  abStack_28[0x1a] = 0;
  abStack_28[0x1b] = 0;
  abStack_28[0x14] = 0;
  abStack_28[0x15] = 0;
  abStack_28[0x16] = 0;
  abStack_28[0x17] = 0;
  abStack_28[0x10] = 0;
  abStack_28[0x11] = 0;
  abStack_28[0x12] = 0;
  abStack_28[0x13] = 0;
  abStack_28[0xc] = 0;
  abStack_28[0xd] = 0;
  abStack_28[0xe] = 0;
  abStack_28[0xf] = 0;
  abStack_28[8] = 0;
  abStack_28[9] = 0;
  abStack_28[10] = 0;
  abStack_28[0xb] = 0;
  abStack_28[4] = 0;
  abStack_28[5] = 0;
  abStack_28[6] = 0;
  abStack_28[7] = 0;
  abStack_28[0] = 0;
  abStack_28[1] = 0;
  abStack_28[2] = 0;
  abStack_28[3] = 0;
  while( true ) {
    bVar1 = *param_2;
    if (bVar1 == 0) break;
    param_2 = param_2 + 1;
    abStack_28[(int)(uint)bVar1 >> 3] = abStack_28[(int)(uint)bVar1 >> 3] | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar2 = param_1;
    bVar1 = *pbVar2;
    if (bVar1 == 0) {
      return (byte *)(uint)bVar1;
    }
    param_1 = pbVar2 + 1;
  } while ((abStack_28[(int)(uint)bVar1 >> 3] >> (bVar1 & 7) & 1) == 0);
  return pbVar2;
}



// Setting prototype: BOOL get_string_type(DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD
// lpCharType)

BOOL __cdecl get_string_type(DWORD dwInfoType,LPCSTR lpSrcStr,int cchSrc,LPWORD lpCharType)

{
  BOOL BVar1;
  int iVar2;
  UINT in_stack_00000014;
  LCID in_stack_00000018;
  int in_stack_0000001c;
  WORD mb_len [2];
  undefined1 *buffer;
  void *exception_list;
  undefined1 *stack_ptr_1;
  undefined *stack_ptr_2;
  undefined4 exception_code;
  undefined1 *tls;
  
  exception_code = 0xffffffff;
  stack_ptr_2 = &DAT_10026460;
  stack_ptr_1 = &LAB_1001e7dc;
  exception_list = ExceptionList;
  buffer = &stack0xffffffc8;
  iVar2 = DAT_10035830;
  ExceptionList = &exception_list;
  tls = &stack0xffffffc8;
  if (DAT_10035830 == 0) {
    ExceptionList = &exception_list;
    BVar1 = GetStringTypeW(1,L"",1,mb_len);
    iVar2 = 1;
    tls = buffer;
    if (BVar1 == 0) {
      BVar1 = GetStringTypeA(0,1,"",1,mb_len);
      if (BVar1 == 0) {
        ExceptionList = exception_list;
        return 0;
      }
      iVar2 = 2;
      tls = buffer;
    }
  }
  buffer = tls;
  DAT_10035830 = iVar2;
  if (DAT_10035830 != 2) {
    if (DAT_10035830 == 1) {
      if (in_stack_00000014 == 0) {
        in_stack_00000014 = DAT_100355cc;
      }
      iVar2 = MultiByteToWideChar(in_stack_00000014,(-(uint)(in_stack_0000001c != 0) & 8) + 1,
                                  lpSrcStr,cchSrc,(LPWSTR)0x0,0);
      if (iVar2 != 0) {
        exception_code = 0;
        memory_management_3();
        buffer = &stack0xffffffc8;
        _memset(&stack0xffffffc8,0,iVar2 * 2);
        exception_code = 0xffffffff;
        if ((&stack0x00000000 != (undefined1 *)0x38) &&
           (iVar2 = MultiByteToWideChar(in_stack_00000014,1,lpSrcStr,cchSrc,(LPWSTR)&stack0xffffffc8
                                        ,iVar2), iVar2 != 0)) {
          BVar1 = GetStringTypeW(dwInfoType,(LPCWSTR)&stack0xffffffc8,iVar2,lpCharType);
          ExceptionList = exception_list;
          return BVar1;
        }
      }
    }
    ExceptionList = exception_list;
    return 0;
  }
  if (in_stack_00000018 == 0) {
    in_stack_00000018 = DAT_100355bc;
  }
  BVar1 = GetStringTypeA(in_stack_00000018,dwInfoType,lpSrcStr,cchSrc,lpCharType);
  ExceptionList = exception_list;
  return BVar1;
}



// Setting prototype: undefined4 set_locale_info(int category)

undefined4 __cdecl set_locale_info(int category)

{
  byte bVar1;
  UINT codepage;
  UINT *pUVar2;
  BOOL BVar3;
  uint uVar4;
  uint uVar5;
  BYTE *pBVar6;
  int iVar7;
  byte *pbVar8;
  int k;
  byte *pbVar9;
  undefined4 uVar10;
  undefined4 *puVar11;
  _cpinfo cp_info;
  uint flags;
  byte char_val;
  BYTE *lead_byte;
  
  lock_resource(0x19);
  codepage = get_code_page(category);
  if (codepage != DAT_11766208) {
    if (codepage != 0) {
      k = 0;
      pUVar2 = &DAT_10034168;
LAB_10021d50:
      if (*pUVar2 != codepage) goto code_r0x10021d54;
      flags = 0;
      puVar11 = (undefined4 *)&DAT_11766320;
      for (iVar7 = 0x40; iVar7 != 0; iVar7 = iVar7 + -1) {
        *puVar11 = 0;
        puVar11 = puVar11 + 1;
      }
      *(undefined1 *)puVar11 = 0;
      pbVar9 = &DAT_10034178 + k * 0x30;
      do {
        bVar1 = *pbVar9;
        pbVar8 = pbVar9;
        while ((bVar1 != 0 && (bVar1 = pbVar8[1], bVar1 != 0))) {
          uVar5 = (uint)*pbVar8;
          if (uVar5 <= bVar1) {
            char_val = (&DAT_10034160)[flags];
            do {
              (&DAT_11766321)[uVar5] = (&DAT_11766321)[uVar5] | char_val;
              uVar5 = uVar5 + 1;
            } while (uVar5 <= bVar1);
          }
          pbVar8 = pbVar8 + 2;
          bVar1 = *pbVar8;
        }
        flags = flags + 1;
        pbVar9 = pbVar9 + 8;
      } while (flags < 4);
      DAT_1176621c = 1;
      DAT_11766208 = codepage;
      DAT_11766424 = get_lang_id(codepage);
      DAT_11766210 = (&DAT_1003416c)[k * 0xc];
      DAT_11766214 = (&DAT_10034170)[k * 0xc];
      DAT_11766218 = (&DAT_10034174)[k * 0xc];
      goto LAB_10021ea4;
    }
    goto LAB_10021e9f;
  }
  goto LAB_10021d3a;
code_r0x10021d54:
  pUVar2 = pUVar2 + 0xc;
  k = k + 1;
  if (0x10034257 < (int)pUVar2) goto code_r0x10021d5f;
  goto LAB_10021d50;
code_r0x10021d5f:
  BVar3 = GetCPInfo(codepage,&cp_info);
  uVar5 = 1;
  if (BVar3 == 1) {
    DAT_11766424 = 0;
    puVar11 = (undefined4 *)&DAT_11766320;
    for (k = 0x40; k != 0; k = k + -1) {
      *puVar11 = 0;
      puVar11 = puVar11 + 1;
    }
    *(undefined1 *)puVar11 = 0;
    if (cp_info.MaxCharSize < 2) {
      DAT_1176621c = 0;
      DAT_11766208 = codepage;
    }
    else {
      DAT_11766208 = codepage;
      if (cp_info.LeadByte[0] != '\0') {
        pBVar6 = cp_info.LeadByte + 1;
        do {
          bVar1 = *pBVar6;
          if (bVar1 == 0) break;
          for (uVar4 = (uint)pBVar6[-1]; uVar4 <= bVar1; uVar4 = uVar4 + 1) {
            (&DAT_11766321)[uVar4] = (&DAT_11766321)[uVar4] | 4;
          }
          lead_byte = pBVar6 + 1;
          pBVar6 = pBVar6 + 2;
        } while (*lead_byte != 0);
      }
      do {
        (&DAT_11766321)[uVar5] = (&DAT_11766321)[uVar5] | 8;
        uVar5 = uVar5 + 1;
      } while (uVar5 < 0xff);
      DAT_11766424 = get_lang_id(codepage);
      DAT_1176621c = 1;
    }
    DAT_11766210 = 0;
    DAT_11766214 = 0;
    DAT_11766218 = 0;
  }
  else {
    if (DAT_10035834 == 0) {
      uVar10 = 0xffffffff;
      goto LAB_10021eb1;
    }
LAB_10021e9f:
    reset_locale_info();
  }
LAB_10021ea4:
  init_ctype();
LAB_10021d3a:
  uVar10 = 0;
LAB_10021eb1:
  unlock_resource(0x19);
  return uVar10;
}



// Setting prototype: int get_code_page(int category)

int __cdecl get_code_page(int category)

{
  int codepage;
  bool bVar1;
  
  if (category == -2) {
    DAT_10035834 = 1;
                    // WARNING: Could not recover jumptable at 0x10021eda. Too many branches
                    // WARNING: Treating indirect jump as call
    codepage = GetOEMCP();
    return codepage;
  }
  if (category == -3) {
    DAT_10035834 = 1;
                    // WARNING: Could not recover jumptable at 0x10021eef. Too many branches
                    // WARNING: Treating indirect jump as call
    codepage = GetACP();
    return codepage;
  }
  bVar1 = category == -4;
  if (bVar1) {
    category = DAT_100355cc;
  }
  DAT_10035834 = (uint)bVar1;
  return category;
}



// Setting prototype: undefined4 get_lang_id(int codepage)

undefined4 __cdecl get_lang_id(int codepage)

{
  if (codepage == 0x3a4) {
    return 0x411;
  }
  if (codepage == 0x3a8) {
    return 0x804;
  }
  if (codepage == 0x3b5) {
    return 0x412;
  }
  if (codepage != 0x3b6) {
    return 0;
  }
  return 0x404;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void reset_locale_info(void)

void reset_locale_info(void)

{
  int iVar1;
  undefined4 *puVar2;
  
  puVar2 = (undefined4 *)&DAT_11766320;
  for (iVar1 = 0x40; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = 0;
    puVar2 = puVar2 + 1;
  }
  *(undefined1 *)puVar2 = 0;
  DAT_11766208 = 0;
  DAT_1176621c = 0;
  DAT_11766424 = 0;
  DAT_11766210 = 0;
  DAT_11766214 = 0;
  DAT_11766218 = 0;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// Setting prototype: void init_ctype(void)

void init_ctype(void)

{
  BOOL result;
  uint uVar1;
  char cVar2;
  uint uVar3;
  uint j;
  ushort *puVar4;
  undefined1 k;
  BYTE *pBVar5;
  CHAR *pCVar6;
  WORD ctype_info [256];
  undefined1 upper_map [256];
  undefined1 lower_map [256];
  CHAR char_buffer [256];
  _cpinfo cp_info;
  
  result = GetCPInfo(DAT_11766208,&cp_info);
  if (result == 1) {
    uVar1 = 0;
    do {
      char_buffer[uVar1] = (CHAR)uVar1;
      uVar1 = uVar1 + 1;
    } while (uVar1 < 0x100);
    char_buffer[0] = ' ';
    if (cp_info.LeadByte[0] != 0) {
      pBVar5 = cp_info.LeadByte + 1;
      do {
        uVar1 = (uint)cp_info.LeadByte[0];
        if (uVar1 <= *pBVar5) {
          uVar3 = (*pBVar5 - uVar1) + 1;
          j = uVar3 >> 2;
          pCVar6 = char_buffer + uVar1;
          while (j != 0) {
            j = j - 1;
            builtin_memcpy(pCVar6,"    ",4);
            pCVar6 = pCVar6 + 4;
          }
          for (uVar3 = uVar3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
            *pCVar6 = ' ';
            pCVar6 = pCVar6 + 1;
          }
        }
        cp_info.LeadByte[0] = pBVar5[1];
        pBVar5 = pBVar5 + 2;
      } while (cp_info.LeadByte[0] != 0);
    }
    get_string_type(1,char_buffer,0x100,ctype_info);
    string_map(DAT_11766424,0x100,char_buffer,0x100,lower_map,0x100,DAT_11766208,0);
    string_map(DAT_11766424,0x200,char_buffer,0x100,upper_map,0x100,DAT_11766208,0);
    uVar1 = 0;
    puVar4 = ctype_info;
    do {
      if ((*puVar4 & 1) == 0) {
        if ((*puVar4 & 2) != 0) {
          (&DAT_11766321)[uVar1] = (&DAT_11766321)[uVar1] | 0x20;
          k = upper_map[uVar1];
          goto LAB_10022072;
        }
        (&DAT_11766220)[uVar1] = 0;
      }
      else {
        (&DAT_11766321)[uVar1] = (&DAT_11766321)[uVar1] | 0x10;
        k = lower_map[uVar1];
LAB_10022072:
        (&DAT_11766220)[uVar1] = k;
      }
      uVar1 = uVar1 + 1;
      puVar4 = puVar4 + 1;
    } while (uVar1 < 0x100);
  }
  else {
    uVar1 = 0;
    do {
      if ((uVar1 < 0x41) || (0x5a < uVar1)) {
        if ((0x60 < uVar1) && (uVar1 < 0x7b)) {
          (&DAT_11766321)[uVar1] = (&DAT_11766321)[uVar1] | 0x20;
          cVar2 = (char)uVar1 + -0x20;
          goto LAB_100220bc;
        }
        (&DAT_11766220)[uVar1] = 0;
      }
      else {
        (&DAT_11766321)[uVar1] = (&DAT_11766321)[uVar1] | 0x10;
        cVar2 = (char)uVar1 + ' ';
LAB_100220bc:
        (&DAT_11766220)[uVar1] = cVar2;
      }
      uVar1 = uVar1 + 1;
    } while (uVar1 < 0x100);
  }
  return;
}



void crt_startup_25(void)

{
  if (DAT_11767590 == 0) {
    set_locale_info(-3);
    DAT_11767590 = 1;
  }
  return;
}



int show_message_box(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  HMODULE hModule;
  int iVar1;
  
  iVar1 = 0;
  if (DAT_10035838 == (FARPROC)0x0) {
    hModule = LoadLibraryA("user32.dll");
    if (hModule != (HMODULE)0x0) {
      DAT_10035838 = GetProcAddress(hModule,"MessageBoxA");
      if (DAT_10035838 != (FARPROC)0x0) {
        DAT_1003583c = GetProcAddress(hModule,"GetActiveWindow");
        DAT_10035840 = GetProcAddress(hModule,"GetLastActivePopup");
        goto LAB_10022156;
      }
    }
    iVar1 = 0;
  }
  else {
LAB_10022156:
    if (DAT_1003583c != (FARPROC)0x0) {
      iVar1 = (*DAT_1003583c)();
      if ((iVar1 != 0) && (DAT_10035840 != (FARPROC)0x0)) {
        iVar1 = (*DAT_10035840)(iVar1);
      }
    }
    iVar1 = (*DAT_10035838)(iVar1,param_1,param_2,param_3);
  }
  return iVar1;
}



int file_io_48(uint32_t param_1,int param_2)

{
  uint32_t offset;
  uint32_t uVar1;
  uint32_t count;
  int iVar2;
  int *piVar3;
  undefined4 *puVar4;
  HANDLE hFile;
  BOOL BVar5;
  DWORD DVar6;
  DWORD *pDVar7;
  int iVar8;
  undefined1 local_1008 [4064];
  undefined4 uStackY_28;
  uint32_t uStackY_24;
  uint32_t uStackY_20;
  
  memory_management_3();
  iVar8 = 0;
  offset = file_io_6(param_1,0,1);
  if ((offset == 0xffffffff) || (uVar1 = file_io_6(param_1,0,2), uVar1 == 0xffffffff)) {
    iVar8 = -1;
  }
  else {
    uVar1 = param_2 - uVar1;
    if ((int)uVar1 < 1) {
      if ((int)uVar1 < 0) {
        uStackY_20 = 0x10022261;
        file_io_6(param_1,param_2,0);
        uStackY_20 = param_1;
        uStackY_24 = 0x10022269;
        hFile = (HANDLE)file_management_12();
        BVar5 = SetEndOfFile(hFile);
        iVar8 = (BVar5 != 0) - 1;
        if (iVar8 == -1) {
          puVar4 = (undefined4 *)get_last_error();
          *puVar4 = 0xd;
          DVar6 = GetLastError();
          pDVar7 = (DWORD *)get_last_error_2();
          *pDVar7 = DVar6;
        }
      }
    }
    else {
      uStackY_20 = 0x100221f0;
      _memset(local_1008,0,0x1000);
      uStackY_20 = 0x8000;
      uStackY_24 = param_1;
      uStackY_28 = 0x100221fd;
      crt_startup_26();
      do {
        count = 0x1000;
        if ((int)uVar1 < 0x1000) {
          count = uVar1;
        }
        uStackY_20 = 0x1002221b;
        iVar2 = file_write_12(param_1,local_1008,count);
        if (iVar2 == -1) {
          piVar3 = (int *)get_last_error_2();
          if (*piVar3 == 5) {
            puVar4 = (undefined4 *)get_last_error();
            *puVar4 = 0xd;
          }
          iVar8 = -1;
          break;
        }
        uVar1 = uVar1 - iVar2;
      } while (0 < (int)uVar1);
      crt_startup_26();
    }
    uStackY_20 = 0x100222a7;
    file_io_6(param_1,offset,0);
  }
  return iVar8;
}



int __thiscall str_to_int_7(undefined *param_1,byte *param_2)

{
  uint32_t uVar1;
  int iVar2;
  uint uVar3;
  uint char_val;
  uint32_t unaff_EDI;
  byte *pbVar4;
  undefined *puVar5;
  
  while( true ) {
    if (DAT_10033ee0 < 2) {
      uVar1 = (byte)PTR_DAT_10033cd4[(uint)*param_2 * 2] & 8;
      param_1 = PTR_DAT_10033cd4;
    }
    else {
      puVar5 = (undefined *)0x8;
      uVar1 = get_char_property(param_1,(uint)*param_2,8,unaff_EDI);
      param_1 = puVar5;
    }
    if (uVar1 == 0) break;
    param_2 = param_2 + 1;
  }
  uVar3 = (uint)*param_2;
  pbVar4 = param_2 + 1;
  if ((uVar3 == 0x2d) || (char_val = uVar3, uVar3 == 0x2b)) {
    char_val = (uint)*pbVar4;
    pbVar4 = param_2 + 2;
  }
  iVar2 = 0;
  while( true ) {
    if (DAT_10033ee0 < 2) {
      uVar1 = (byte)PTR_DAT_10033cd4[char_val * 2] & 4;
    }
    else {
      puVar5 = (undefined *)0x4;
      uVar1 = get_char_property(param_1,char_val,4,unaff_EDI);
      param_1 = puVar5;
    }
    if (uVar1 == 0) break;
    iVar2 = (char_val - 0x30) + iVar2 * 10;
    char_val = (uint)*pbVar4;
    pbVar4 = pbVar4 + 1;
  }
  if (uVar3 == 0x2d) {
    iVar2 = -iVar2;
  }
  return iVar2;
}



int env_var_management_13(uchar *param_1)

{
  int iVar1;
  size_t _MaxCount;
  size_t sVar2;
  int *piVar3;
  
  if (((DAT_1176758c != 0) &&
      ((DAT_100354d0 != (int *)0x0 ||
       (((DAT_100354d8 != 0 && (iVar1 = env_var_management_14(), iVar1 == 0)) &&
        (DAT_100354d0 != (int *)0x0)))))) && (piVar3 = DAT_100354d0, param_1 != (uchar *)0x0)) {
    _MaxCount = _strlen((char *)param_1);
    for (; (char *)*piVar3 != (char *)0x0; piVar3 = piVar3 + 1) {
      sVar2 = _strlen((char *)*piVar3);
      if (((_MaxCount < sVar2) && (((uchar *)*piVar3)[_MaxCount] == '=')) &&
         (iVar1 = __mbsnbicoll((uchar *)*piVar3,param_1,_MaxCount), iVar1 == 0)) {
        return *piVar3 + 1 + _MaxCount;
      }
    }
  }
  return 0;
}



undefined4 bitwise_op_15(uint param_1,uint param_2,uint *param_3)

{
  uint uVar1;
  undefined4 uVar2;
  
  uVar2 = 0;
  uVar1 = param_1 + param_2;
  if ((uVar1 < param_1) || (uVar1 < param_2)) {
    uVar2 = 1;
  }
  *param_3 = uVar1;
  return uVar2;
}



// Library Function - Single Match
//  ___add_12
// 
// Library: Visual Studio 2003 Release

void ___add_12(undefined4 *param_1,undefined4 *param_2)

{
  int iVar1;
  
  iVar1 = bitwise_op_15(*param_1,*param_2,param_1);
  if (iVar1 != 0) {
    iVar1 = bitwise_op_15(param_1[1],1,param_1 + 1);
    if (iVar1 != 0) {
      param_1[2] = param_1[2] + 1;
    }
  }
  iVar1 = bitwise_op_15(param_1[1],param_2[1],param_1 + 1);
  if (iVar1 != 0) {
    param_1[2] = param_1[2] + 1;
  }
  bitwise_op_15(param_1[2],param_2[2],param_1 + 2);
  return;
}



void bitwise_op_16(uint *param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = *param_1;
  uVar2 = param_1[1];
  *param_1 = uVar1 * 2;
  param_1[1] = uVar2 * 2 | uVar1 >> 0x1f;
  param_1[2] = param_1[2] << 1 | uVar2 >> 0x1f;
  return;
}



void bitwise_op_17(uint *param_1)

{
  uint uVar1;
  
  uVar1 = param_1[1];
  param_1[1] = uVar1 >> 1 | param_1[2] << 0x1f;
  param_1[2] = param_1[2] >> 1;
  *param_1 = *param_1 >> 1 | uVar1 << 0x1f;
  return;
}



void hash_function(char *param_1,int param_2,uint *param_3)

{
  uint *puVar1;
  uint local_14;
  uint local_10;
  uint local_c;
  int local_8;
  
  puVar1 = param_3;
  local_8 = 0x404e;
  *param_3 = 0;
  param_3[1] = 0;
  param_3[2] = 0;
  if (param_2 != 0) {
    param_3 = (uint *)param_2;
    do {
      local_14 = *puVar1;
      local_10 = puVar1[1];
      local_c = puVar1[2];
      bitwise_op_16(puVar1);
      bitwise_op_16(puVar1);
      ___add_12(puVar1,&local_14);
      bitwise_op_16(puVar1);
      local_10 = 0;
      local_c = 0;
      local_14 = (uint)*param_1;
      ___add_12(puVar1,&local_14);
      param_1 = param_1 + 1;
      param_3 = (uint *)((int)param_3 + -1);
    } while (param_3 != (uint *)0x0);
  }
  while (puVar1[2] == 0) {
    puVar1[2] = puVar1[1] >> 0x10;
    local_8 = local_8 + 0xfff0;
    puVar1[1] = *puVar1 >> 0x10 | puVar1[1] << 0x10;
    *puVar1 = *puVar1 << 0x10;
  }
  while ((puVar1[2] & 0x8000) == 0) {
    bitwise_op_16(puVar1);
    local_8 = local_8 + 0xffff;
  }
  *(undefined2 *)((int)puVar1 + 10) = (undefined2)local_8;
  return;
}



undefined4 __thiscall
str_to_float_5(byte *param_1,ushort *param_2,int *param_3,byte *param_4,undefined4 param_5,
              int param_6,int param_7,int param_8)

{
  int iVar1;
  int iVar2;
  uint32_t uVar3;
  char *pcVar4;
  int iVar5;
  byte bVar6;
  byte *pbVar7;
  uint32_t unaff_EDI;
  byte *pbVar8;
  int iVar9;
  byte *pbVar10;
  char local_60 [23];
  char local_49;
  ushort local_44;
  undefined2 uStack_42;
  undefined2 uStack_40;
  byte *local_3e;
  ushort local_3a;
  int local_34;
  int local_30;
  undefined4 local_2c;
  int local_28;
  int local_24;
  byte *local_20;
  int local_1c;
  undefined4 local_18;
  int local_14;
  char *local_10;
  int local_c;
  uint local_8;
  
  local_10 = local_60;
  local_2c = 0;
  local_1c = 1;
  local_8 = 0;
  local_14 = 0;
  local_28 = 0;
  local_24 = 0;
  local_30 = 0;
  local_34 = 0;
  local_20 = (byte *)0x0;
  local_c = 0;
  local_18 = 0;
  pbVar8 = param_4;
  while( true ) {
    bVar6 = *pbVar8;
    param_1 = (byte *)CONCAT31((int3)((uint)param_1 >> 8),bVar6);
    if ((((bVar6 != 0x20) && (bVar6 != 9)) && (bVar6 != 10)) && (bVar6 != 0xd)) break;
    pbVar8 = pbVar8 + 1;
  }
  iVar1 = 4;
  iVar9 = 0;
  iVar5 = local_14;
LAB_100225b5:
  local_14 = iVar5;
  pbVar7 = pbVar8;
  iVar5 = 1;
  bVar6 = *pbVar7;
  pbVar8 = pbVar7 + 1;
  iVar2 = local_14;
  switch(iVar9) {
  case 0:
    if (('0' < (char)bVar6) && ((char)bVar6 < ':')) {
LAB_100225d2:
      local_14 = iVar2;
      iVar9 = 3;
      goto LAB_100227f7;
    }
    if (bVar6 == DAT_10033ee4) goto LAB_100225e1;
    if (bVar6 == 0x2b) {
      local_2c = 0;
      iVar9 = 2;
      iVar5 = local_14;
    }
    else if (bVar6 == 0x2d) {
      local_2c = 0x8000;
      iVar9 = 2;
      iVar5 = local_14;
    }
    else {
      iVar9 = iVar5;
      iVar5 = local_14;
      if (bVar6 != 0x30) goto LAB_100228d1;
    }
    goto LAB_100225b5;
  case 1:
    local_14 = 1;
    if (('0' < (char)bVar6) && (iVar2 = iVar5, (char)bVar6 < ':')) goto LAB_100225d2;
    iVar9 = iVar1;
    if (bVar6 != DAT_10033ee4) {
      iVar9 = iVar5;
      if ((bVar6 == 0x2b) || (iVar9 = local_14, bVar6 == 0x2d)) goto LAB_10022666;
      iVar9 = iVar5;
      local_14 = iVar5;
      if (bVar6 != 0x30) goto LAB_1002263f;
    }
    goto LAB_100225b5;
  case 2:
    if (('0' < (char)bVar6) && ((char)bVar6 < ':')) goto LAB_100225d2;
    if (bVar6 == DAT_10033ee4) {
LAB_100225e1:
      iVar9 = 5;
      iVar5 = local_14;
    }
    else {
      iVar9 = iVar5;
      pbVar7 = param_4;
      iVar5 = local_14;
      if (bVar6 != 0x30) goto LAB_100228d6;
    }
    goto LAB_100225b5;
  case 3:
    local_14 = iVar5;
    while( true ) {
      if (DAT_10033ee0 < 2) {
        uVar3 = (byte)PTR_DAT_10033cd4[(uint)bVar6 * 2] & 4;
        param_1 = PTR_DAT_10033cd4;
      }
      else {
        pbVar7 = (byte *)0x4;
        uVar3 = get_char_property(param_1,(uint)bVar6,4,unaff_EDI);
        param_1 = pbVar7;
      }
      if (uVar3 == 0) break;
      if (local_8 < 0x19) {
        local_8 = local_8 + 1;
        pcVar4 = local_10 + 1;
        *local_10 = bVar6 - 0x30;
        local_10 = pcVar4;
      }
      else {
        local_c = local_c + 1;
      }
      bVar6 = *pbVar8;
      pbVar8 = pbVar8 + 1;
    }
    iVar9 = iVar1;
    iVar5 = local_14;
    if (bVar6 != DAT_10033ee4) goto LAB_10022753;
    goto LAB_100225b5;
  case 4:
    local_14 = 1;
    local_28 = 1;
    iVar9 = iVar5;
    if (local_8 == 0) {
      while (iVar5 = local_28, iVar9 = local_14, bVar6 == 0x30) {
        local_c = local_c + -1;
        bVar6 = *pbVar8;
        pbVar8 = pbVar8 + 1;
      }
    }
    while( true ) {
      local_14 = iVar9;
      local_28 = iVar5;
      if (DAT_10033ee0 < 2) {
        uVar3 = (byte)PTR_DAT_10033cd4[(uint)bVar6 * 2] & 4;
        param_1 = PTR_DAT_10033cd4;
      }
      else {
        pbVar7 = (byte *)0x4;
        uVar3 = get_char_property(param_1,(uint)bVar6,4,unaff_EDI);
        param_1 = pbVar7;
      }
      if (uVar3 == 0) break;
      if (local_8 < 0x19) {
        local_8 = local_8 + 1;
        local_c = local_c + -1;
        pcVar4 = local_10 + 1;
        *local_10 = bVar6 - 0x30;
        local_10 = pcVar4;
      }
      bVar6 = *pbVar8;
      pbVar8 = pbVar8 + 1;
      iVar5 = local_28;
      iVar9 = local_14;
    }
LAB_10022753:
    iVar9 = local_14;
    if ((bVar6 == 0x2b) || (bVar6 == 0x2d)) {
LAB_10022666:
      local_14 = iVar9;
      iVar9 = 0xb;
      pbVar8 = pbVar8 + -1;
      iVar5 = local_14;
    }
    else {
LAB_1002263f:
      if (((char)bVar6 < 'D') ||
         (('E' < (char)bVar6 && (((char)bVar6 < 'd' || ('e' < (char)bVar6)))))) goto LAB_100228d1;
      iVar9 = 6;
      iVar5 = local_14;
    }
    goto LAB_100225b5;
  case 5:
    local_28 = iVar5;
    if (DAT_10033ee0 < 2) {
      uVar3 = (byte)PTR_DAT_10033cd4[(uint)bVar6 * 2] & 4;
      param_1 = PTR_DAT_10033cd4;
    }
    else {
      pbVar7 = (byte *)0x4;
      uVar3 = get_char_property(param_1,(uint)bVar6,4,unaff_EDI);
      param_1 = pbVar7;
    }
    iVar9 = iVar1;
    pbVar7 = param_4;
    if (uVar3 != 0) goto LAB_100227f7;
    goto LAB_100228d6;
  case 6:
    pbVar7 = pbVar7 + -1;
    param_1 = pbVar7;
    param_4 = pbVar7;
    if (((char)bVar6 < '1') || ('9' < (char)bVar6)) {
      if (bVar6 == 0x2b) goto LAB_1002282c;
      if (bVar6 == 0x2d) goto LAB_10022820;
      if (bVar6 != 0x30) goto LAB_100228d6;
LAB_100227c5:
      iVar9 = 8;
      iVar5 = local_14;
      goto LAB_100225b5;
    }
    break;
  case 7:
    if (((char)bVar6 < '1') || ('9' < (char)bVar6)) {
      pbVar7 = param_4;
      if (bVar6 == 0x30) goto LAB_100227c5;
      goto LAB_100228d6;
    }
    break;
  case 8:
    local_24 = 1;
    while (bVar6 == 0x30) {
      bVar6 = *pbVar8;
      pbVar8 = pbVar8 + 1;
    }
    if (((char)bVar6 < '1') || ('9' < (char)bVar6)) goto LAB_100228d1;
    break;
  case 9:
    local_24 = 1;
    pbVar7 = (byte *)0x0;
    goto LAB_10022857;
  default:
    goto switchD_100225c1_caseD_a;
  case 0xb:
    if (param_8 != 0) {
      if (bVar6 == 0x2b) {
LAB_1002282c:
        iVar9 = 7;
        param_1 = pbVar7;
        param_4 = pbVar7;
        iVar5 = local_14;
      }
      else {
        param_4 = pbVar7;
        if (bVar6 != 0x2d) goto LAB_100228d6;
LAB_10022820:
        local_1c = -1;
        iVar9 = 7;
        param_1 = pbVar7;
        param_4 = pbVar7;
        iVar5 = local_14;
      }
      goto LAB_100225b5;
    }
    iVar9 = 10;
    pbVar8 = pbVar7;
switchD_100225c1_caseD_a:
    pbVar7 = pbVar8;
    iVar5 = local_14;
    if (iVar9 != 10) goto LAB_100225b5;
    goto LAB_100228d6;
  }
  iVar9 = 9;
LAB_100227f7:
  pbVar8 = pbVar8 + -1;
  iVar5 = local_14;
  goto LAB_100225b5;
LAB_10022857:
  if (DAT_10033ee0 < 2) {
    uVar3 = (byte)PTR_DAT_10033cd4[(uint)bVar6 * 2] & 4;
    param_1 = PTR_DAT_10033cd4;
  }
  else {
    pbVar10 = (byte *)0x4;
    uVar3 = get_char_property(param_1,(uint)bVar6,4,unaff_EDI);
    param_1 = pbVar10;
  }
  if (uVar3 == 0) goto LAB_100228a1;
  param_1 = (byte *)(int)(char)bVar6;
  pbVar7 = param_1 + (int)pbVar7 * 10 + -0x30;
  if (0x1450 < (int)pbVar7) goto LAB_10022899;
  bVar6 = *pbVar8;
  pbVar8 = pbVar8 + 1;
  goto LAB_10022857;
LAB_10022899:
  pbVar7 = (byte *)0x1451;
LAB_100228a1:
  while( true ) {
    local_20 = pbVar7;
    if (DAT_10033ee0 < 2) {
      uVar3 = (byte)PTR_DAT_10033cd4[(uint)bVar6 * 2] & 4;
      param_1 = PTR_DAT_10033cd4;
    }
    else {
      pbVar7 = (byte *)0x4;
      uVar3 = get_char_property(param_1,(uint)bVar6,4,unaff_EDI);
      param_1 = pbVar7;
    }
    if (uVar3 == 0) break;
    bVar6 = *pbVar8;
    pbVar8 = pbVar8 + 1;
    pbVar7 = local_20;
  }
LAB_100228d1:
  pbVar7 = pbVar8 + -1;
LAB_100228d6:
  *param_3 = (int)pbVar7;
  if (local_14 == 0) {
    local_44 = 0;
    local_3a = 0;
    local_3e = (byte *)0x0;
    param_4 = (byte *)0x0;
    local_18 = 4;
    goto LAB_100229e4;
  }
  pcVar4 = local_10;
  if (0x18 < local_8) {
    if ('\x04' < local_49) {
      local_49 = local_49 + '\x01';
    }
    local_8 = 0x18;
    local_c = local_c + 1;
    pcVar4 = local_10 + -1;
  }
  if (local_8 == 0) {
    local_44 = 0;
    local_3a = 0;
    local_3e = (byte *)0x0;
    param_4 = (byte *)0x0;
  }
  else {
    while (pcVar4 = pcVar4 + -1, *pcVar4 == '\0') {
      local_8 = local_8 - 1;
      local_c = local_c + 1;
    }
    hash_function(local_60,local_8,&local_44);
    pbVar8 = local_20;
    if (local_1c < 0) {
      pbVar8 = (byte *)-(int)local_20;
    }
    pbVar8 = pbVar8 + local_c;
    if (local_24 == 0) {
      pbVar8 = pbVar8 + param_6;
    }
    if (local_28 == 0) {
      pbVar8 = pbVar8 + -param_7;
    }
    if ((int)pbVar8 < 0x1451) {
      if (-0x1451 < (int)pbVar8) {
        float_conversion_15(&local_44,pbVar8,param_5);
        param_4 = (byte *)CONCAT22(uStack_40,uStack_42);
        goto LAB_10022969;
      }
      local_34 = 1;
    }
    else {
      local_30 = 1;
    }
    local_3a = (ushort)param_4;
    local_3e = param_4;
    local_44 = local_3a;
  }
LAB_10022969:
  if (local_30 == 0) {
    if (local_34 != 0) {
      local_44 = 0;
      local_3a = 0;
      local_3e = (byte *)0x0;
      param_4 = (byte *)0x0;
      local_18 = 1;
    }
  }
  else {
    param_4 = (byte *)0x0;
    local_3a = 0x7fff;
    local_3e = (byte *)0x80000000;
    local_44 = 0;
    local_18 = 2;
  }
LAB_100229e4:
  *(byte **)(param_2 + 3) = local_3e;
  *(byte **)(param_2 + 1) = param_4;
  param_2[5] = local_3a | (ushort)local_2c;
  *param_2 = local_44;
  return local_18;
}



undefined4
float_conversion_13(int param_1,uint param_2,uint param_3,int param_4,byte param_5,short *param_6)

{
  short *psVar1;
  short *psVar2;
  char cVar3;
  uint uVar4;
  short *psVar5;
  short *psVar6;
  short sVar7;
  int iVar8;
  int iVar9;
  char *pcVar10;
  undefined1 local_20;
  undefined1 local_1f;
  undefined1 local_1e;
  undefined1 local_1d;
  undefined1 local_1c;
  undefined1 local_1b;
  undefined1 local_1a;
  undefined1 local_19;
  undefined1 local_18;
  undefined1 local_17;
  undefined1 local_16;
  undefined1 local_15;
  undefined2 local_14;
  undefined2 local_12;
  undefined2 uStack_10;
  undefined2 local_e;
  undefined2 uStack_c;
  undefined1 local_a;
  char cStack_9;
  undefined4 local_8;
  
  psVar2 = param_6;
  uVar4 = param_3 & 0x7fff;
  local_20 = 0xcc;
  local_1f = 0xcc;
  local_1e = 0xcc;
  local_1d = 0xcc;
  local_1c = 0xcc;
  local_1b = 0xcc;
  local_1a = 0xcc;
  local_19 = 0xcc;
  local_18 = 0xcc;
  local_17 = 0xcc;
  local_16 = 0xfb;
  local_15 = 0x3f;
  local_8 = 1;
  if ((param_3 & 0x8000) == 0) {
    *(undefined1 *)(param_6 + 1) = 0x20;
  }
  else {
    *(undefined1 *)(param_6 + 1) = 0x2d;
  }
  if ((((short)uVar4 != 0) || (param_2 != 0)) || (param_1 != 0)) {
    if ((short)uVar4 == 0x7fff) {
      *param_6 = 1;
      if (((param_2 == 0x80000000) && (param_1 == 0)) || ((param_2 & 0x40000000) != 0)) {
        if (((param_3 & 0x8000) == 0) || (param_2 != 0xc0000000)) {
          if ((param_2 != 0x80000000) || (param_1 != 0)) goto LAB_10022b24;
          pcVar10 = "1#INF";
        }
        else {
          if (param_1 != 0) {
LAB_10022b24:
            pcVar10 = "1#QNAN";
            goto LAB_10022b29;
          }
          pcVar10 = "1#IND";
        }
        strcpy_internal_2(param_6 + 2,pcVar10);
        *(undefined1 *)((int)psVar2 + 3) = 5;
      }
      else {
        pcVar10 = "1#SNAN";
LAB_10022b29:
        strcpy_internal_2(param_6 + 2,pcVar10);
        *(undefined1 *)((int)psVar2 + 3) = 6;
      }
      return 0;
    }
    local_14 = 0;
    local_a = (undefined1)uVar4;
    cStack_9 = (char)(uVar4 >> 8);
    local_e = (undefined2)param_2;
    uStack_c = (undefined2)(param_2 >> 0x10);
    local_12 = (undefined2)param_1;
    uStack_10 = (undefined2)((uint)param_1 >> 0x10);
    sVar7 = (short)(((uVar4 >> 8) + (param_2 >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar4 * 0x4d10 >>
                   0x10);
    float_conversion_15(&local_14,-(int)sVar7,1);
    if (0x3ffe < CONCAT11(cStack_9,local_a)) {
      sVar7 = sVar7 + 1;
      float_conversion_14(&local_14,&local_20);
    }
    *psVar2 = sVar7;
    iVar9 = param_4;
    if (((param_5 & 1) == 0) || (iVar9 = param_4 + sVar7, 0 < param_4 + sVar7)) {
      if (0x15 < iVar9) {
        iVar9 = 0x15;
      }
      iVar8 = CONCAT11(cStack_9,local_a) - 0x3ffe;
      local_a = 0;
      cStack_9 = '\0';
      param_6 = (short *)0x8;
      do {
        bitwise_op_16(&local_14);
        param_6 = (short *)((int)param_6 + -1);
      } while (param_6 != (short *)0x0);
      if (iVar8 < 0) {
        param_6 = (short *)0x0;
        for (uVar4 = -iVar8 & 0xff; uVar4 != 0; uVar4 = uVar4 - 1) {
          bitwise_op_17(&local_14);
        }
      }
      param_4 = iVar9 + 1;
      psVar5 = psVar2 + 2;
      param_6 = psVar5;
      if (0 < param_4) {
        do {
          param_1 = CONCAT22(local_12,local_14);
          param_2 = CONCAT22(local_e,uStack_10);
          param_3 = CONCAT13(cStack_9,CONCAT12(local_a,uStack_c));
          bitwise_op_16(&local_14);
          bitwise_op_16(&local_14);
          ___add_12(&local_14,&param_1);
          bitwise_op_16(&local_14);
          cVar3 = cStack_9;
          cStack_9 = '\0';
          psVar5 = (short *)((int)param_6 + 1);
          param_4 = param_4 + -1;
          *(char *)param_6 = cVar3 + '0';
          param_6 = psVar5;
        } while (param_4 != 0);
      }
      psVar6 = psVar5 + -1;
      psVar1 = psVar2 + 2;
      if ('4' < *(char *)((int)psVar5 + -1)) {
        for (; psVar1 <= psVar6; psVar6 = (short *)((int)psVar6 + -1)) {
          if ((char)*psVar6 != '9') {
            if (psVar1 <= psVar6) goto LAB_10022c81;
            break;
          }
          *(char *)psVar6 = '0';
        }
        psVar6 = (short *)((int)psVar6 + 1);
        *psVar2 = *psVar2 + 1;
LAB_10022c81:
        *(char *)psVar6 = (char)*psVar6 + '\x01';
LAB_10022c83:
        cVar3 = ((char)psVar6 - (char)psVar2) + -3;
        *(char *)((int)psVar2 + 3) = cVar3;
        *(undefined1 *)(cVar3 + 4 + (int)psVar2) = 0;
        return local_8;
      }
      for (; psVar1 <= psVar6; psVar6 = (short *)((int)psVar6 + -1)) {
        if ((char)*psVar6 != '0') {
          if (psVar1 <= psVar6) goto LAB_10022c83;
          break;
        }
      }
      *psVar2 = 0;
      *(undefined1 *)(psVar2 + 1) = 0x20;
      *(undefined1 *)((int)psVar2 + 3) = 1;
      *(char *)psVar1 = '0';
      goto LAB_10022cb9;
    }
  }
  *psVar2 = 0;
  *(undefined1 *)(psVar2 + 1) = 0x20;
  *(undefined1 *)((int)psVar2 + 3) = 1;
  *(undefined1 *)(psVar2 + 2) = 0x30;
LAB_10022cb9:
  *(undefined1 *)((int)psVar2 + 5) = 0;
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

byte strcmp_internal(byte *param_1,byte *param_2)

{
  bool bVar1;
  int iVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  uint uVar6;
  
  iVar2 = _DAT_1176642c;
  if (DAT_100355bc == 0) {
    bVar5 = 0xff;
    do {
      do {
        if (bVar5 == 0) {
          return 0;
        }
        bVar5 = *param_2;
        param_2 = param_2 + 1;
        bVar4 = *param_1;
        param_1 = param_1 + 1;
      } while (bVar4 == bVar5);
      bVar3 = bVar5 + 0xbf + (-((byte)(bVar5 + 0xbf) < 0x1a) & 0x20U) + 0x41;
      bVar4 = bVar4 + 0xbf;
      bVar5 = bVar4 + (-(bVar4 < 0x1a) & 0x20U) + 0x41;
    } while (bVar5 == bVar3);
    bVar5 = (bVar5 < bVar3) * -2 + 1;
  }
  else {
    LOCK();
    _DAT_1176642c = _DAT_1176642c + 1;
    UNLOCK();
    bVar1 = 0 < DAT_11766428;
    if (bVar1) {
      LOCK();
      UNLOCK();
      _DAT_1176642c = iVar2;
      lock_resource(0x13);
    }
    uVar6 = (uint)bVar1;
    bVar5 = 0xff;
    do {
      do {
        if (bVar5 == 0) goto LAB_10022d7f;
        bVar5 = *param_2;
        param_2 = param_2 + 1;
        bVar4 = *param_1;
        param_1 = param_1 + 1;
      } while (bVar5 == bVar4);
      bVar4 = char_to_upper_20(bVar4,bVar5);
      bVar5 = char_to_upper_20();
    } while (bVar4 == bVar5);
    bVar5 = (bVar4 < bVar5) * -2 + 1;
LAB_10022d7f:
    if (uVar6 == 0) {
      LOCK();
      _DAT_1176642c = _DAT_1176642c + -1;
      UNLOCK();
    }
    else {
      unlock_resource(0x13);
    }
  }
  return bVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int strcmp_internal_2(byte *param_1,char *param_2,int param_3)

{
  char cVar1;
  int iVar2;
  byte bVar3;
  ushort uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  uint uVar8;
  
  iVar2 = _DAT_1176642c;
  if (param_3 != 0) {
    if (DAT_100355bc == 0) {
      do {
        bVar3 = *param_1;
        cVar1 = *param_2;
        uVar4 = CONCAT11(bVar3,cVar1);
        if (bVar3 == 0) break;
        uVar4 = CONCAT11(bVar3,cVar1);
        uVar6 = (uint)uVar4;
        if (cVar1 == '\0') break;
        param_1 = param_1 + 1;
        param_2 = param_2 + 1;
        if ((0x40 < bVar3) && (bVar3 < 0x5b)) {
          uVar6 = (uint)CONCAT11(bVar3 + 0x20,cVar1);
        }
        uVar4 = (ushort)uVar6;
        bVar3 = (byte)uVar6;
        if ((0x40 < bVar3) && (bVar3 < 0x5b)) {
          uVar4 = (ushort)CONCAT31((int3)(uVar6 >> 8),bVar3 + 0x20);
        }
        bVar3 = (byte)(uVar4 >> 8);
        bVar7 = bVar3 < (byte)uVar4;
        if (bVar3 != (byte)uVar4) goto LAB_10022dff;
        param_3 = param_3 + -1;
      } while (param_3 != 0);
      param_3 = 0;
      bVar3 = (byte)(uVar4 >> 8);
      bVar7 = bVar3 < (byte)uVar4;
      if (bVar3 != (byte)uVar4) {
LAB_10022dff:
        param_3 = -1;
        if (!bVar7) {
          param_3 = 1;
        }
      }
    }
    else {
      LOCK();
      _DAT_1176642c = _DAT_1176642c + 1;
      UNLOCK();
      bVar7 = 0 < DAT_11766428;
      if (bVar7) {
        LOCK();
        UNLOCK();
        _DAT_1176642c = iVar2;
        lock_resource(0x13);
      }
      uVar8 = (uint)bVar7;
      uVar5 = 0;
      uVar6 = 0;
      do {
        uVar5 = CONCAT31((int3)(uVar5 >> 8),*param_1);
        uVar6 = CONCAT31((int3)(uVar6 >> 8),*param_2);
        if ((uVar5 == 0) || (uVar6 == 0)) break;
        param_1 = param_1 + 1;
        param_2 = param_2 + 1;
        uVar6 = char_to_upper_20(uVar6,uVar5);
        uVar5 = char_to_upper_20();
        bVar7 = uVar5 < uVar6;
        if (uVar5 != uVar6) goto LAB_10022e75;
        param_3 = param_3 + -1;
      } while (param_3 != 0);
      param_3 = 0;
      bVar7 = uVar5 < uVar6;
      if (uVar5 != uVar6) {
LAB_10022e75:
        param_3 = -1;
        if (!bVar7) {
          param_3 = 1;
        }
      }
      if (uVar8 == 0) {
        LOCK();
        _DAT_1176642c = _DAT_1176642c + -1;
        UNLOCK();
      }
      else {
        unlock_resource(0x13);
      }
    }
  }
  return param_3;
}



int crt_startup_26(uint param_1,int param_2)

{
  byte bVar1;
  undefined4 *puVar2;
  byte bVar3;
  
  bVar1 = *(byte *)((&DAT_11766460)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x24);
  if (param_2 == 0x8000) {
    bVar3 = bVar1 & 0x7f;
  }
  else {
    if (param_2 != 0x4000) {
      puVar2 = (undefined4 *)get_last_error();
      *puVar2 = 0x16;
      return -1;
    }
    bVar3 = bVar1 | 0x80;
  }
  *(byte *)((&DAT_11766460)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x24) = bVar3;
  return (-(uint)((bVar1 & 0x80) != 0) & 0xffffc000) + 0x8000;
}



// Library Function - Single Match
//  __mbsnbicoll
// 
// Library: Visual Studio 2003 Release

int __cdecl __mbsnbicoll(uchar *_Str1,uchar *_Str2,size_t _MaxCount)

{
  int iVar1;
  
  if (_MaxCount == 0) {
    return 0;
  }
  iVar1 = float_conversion_16(DAT_11766424,1,_Str1,_MaxCount,_Str2,_MaxCount,DAT_11766208);
  if (iVar1 == 0) {
    return 0x7fffffff;
  }
  return iVar1 + -2;
}



undefined4 env_var_management_14(void)

{
  LPCWSTR lpWideCharStr;
  size_t size;
  LPSTR lpMultiByteStr;
  int iVar1;
  undefined4 *puVar2;
  
  lpWideCharStr = (LPCWSTR)*DAT_100354d8;
  puVar2 = DAT_100354d8;
  while( true ) {
    if (lpWideCharStr == (LPCWSTR)0x0) {
      return 0;
    }
    size = WideCharToMultiByte(1,0,lpWideCharStr,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
    if (((size == 0) || (lpMultiByteStr = (LPSTR)_malloc(size), lpMultiByteStr == (LPSTR)0x0)) ||
       (iVar1 = WideCharToMultiByte(1,0,(LPCWSTR)*puVar2,-1,lpMultiByteStr,size,(LPCSTR)0x0,
                                    (LPBOOL)0x0), iVar1 == 0)) break;
    str_to_int_9(lpMultiByteStr,0);
    lpWideCharStr = (LPCWSTR)puVar2[1];
    puVar2 = puVar2 + 1;
  }
  return 0xffffffff;
}



void float_conversion_14(int *param_1,int *param_2)

{
  short sVar1;
  int iVar2;
  ushort uVar3;
  int *piVar4;
  int *piVar5;
  ushort uVar6;
  int iVar7;
  ushort uVar8;
  ushort uVar9;
  byte local_28;
  undefined1 uStack_27;
  undefined2 uStack_26;
  short local_24;
  undefined2 uStack_22;
  undefined2 local_20;
  undefined1 uStack_1e;
  byte bStack_1d;
  int local_1c;
  int local_18;
  int local_14;
  ushort *local_10;
  ushort *local_c;
  short *local_8;
  
  piVar5 = param_2;
  piVar4 = param_1;
  local_18 = 0;
  local_28 = 0;
  uStack_27 = 0;
  uStack_26 = 0;
  local_24 = 0;
  uStack_22 = 0;
  local_20 = 0;
  uStack_1e = 0;
  bStack_1d = 0;
  uVar6 = *(ushort *)((int)param_1 + 10) & 0x7fff;
  uVar8 = *(ushort *)((int)param_2 + 10) & 0x7fff;
  uVar9 = (*(ushort *)((int)param_2 + 10) ^ *(ushort *)((int)param_1 + 10)) & 0x8000;
  uVar3 = uVar8 + uVar6;
  if (((uVar6 < 0x7fff) && (uVar8 < 0x7fff)) && (uVar3 < 0xbffe)) {
    if (uVar3 < 0x3fc0) {
LAB_10023094:
      param_1[2] = 0;
      param_1[1] = 0;
      *param_1 = 0;
      return;
    }
    if (((uVar6 != 0) || (uVar3 = uVar3 + 1, (param_1[2] & 0x7fffffffU) != 0)) ||
       ((uVar6 = 0, param_1[1] != 0 || (*param_1 != 0)))) {
      if (((uVar8 == 0) && (uVar3 = uVar3 + 1, (param_2[2] & 0x7fffffffU) == 0)) &&
         ((param_2[1] == 0 && (*param_2 == 0)))) goto LAB_10023094;
      local_14 = 0;
      local_8 = &local_24;
      param_2 = (int *)0x5;
      do {
        if (0 < (int)param_2) {
          local_c = (ushort *)(local_14 * 2 + (int)param_1);
          local_10 = (ushort *)(piVar5 + 2);
          local_1c = (int)param_2;
          do {
            iVar7 = bitwise_op_15(*(undefined4 *)(local_8 + -2),(uint)*local_c * (uint)*local_10,
                                  local_8 + -2);
            if (iVar7 != 0) {
              *local_8 = *local_8 + 1;
            }
            local_c = local_c + 1;
            local_10 = local_10 + -1;
            local_1c = local_1c + -1;
          } while (local_1c != 0);
        }
        local_8 = local_8 + 1;
        local_14 = local_14 + 1;
        param_2 = (int *)((int)param_2 + -1);
      } while (0 < (int)param_2);
      param_1._0_2_ = uVar3 + 0xc002;
      if ((short)(ushort)param_1 < 1) {
LAB_10023148:
        param_1._0_2_ = (ushort)param_1 - 1;
        if ((short)(ushort)param_1 < 0) {
          iVar7 = -(int)(short)(ushort)param_1;
          param_1._0_2_ = (ushort)param_1 + (short)iVar7;
          do {
            if ((local_28 & 1) != 0) {
              local_18 = local_18 + 1;
            }
            bitwise_op_17(&local_28);
            iVar7 = iVar7 + -1;
          } while (iVar7 != 0);
          if (local_18 != 0) {
            local_28 = local_28 | 1;
          }
        }
      }
      else {
        do {
          if ((bStack_1d & 0x80) != 0) break;
          bitwise_op_16(&local_28);
          param_1._0_2_ = (ushort)param_1 - 1;
        } while (0 < (short)(ushort)param_1);
        if ((short)(ushort)param_1 < 1) goto LAB_10023148;
      }
      if ((0x8000 < CONCAT11(uStack_27,local_28)) ||
         (sVar1 = CONCAT11(bStack_1d,uStack_1e), iVar2 = CONCAT22(local_20,uStack_22),
         iVar7 = CONCAT22(local_24,uStack_26),
         (CONCAT22(uStack_26,CONCAT11(uStack_27,local_28)) & 0x1ffff) == 0x18000)) {
        if (CONCAT22(local_24,uStack_26) == -1) {
          iVar7 = 0;
          if (CONCAT22(local_20,uStack_22) == -1) {
            if (CONCAT11(bStack_1d,uStack_1e) == -1) {
              param_1._0_2_ = (ushort)param_1 + 1;
              sVar1 = -0x8000;
              iVar2 = 0;
              iVar7 = 0;
            }
            else {
              sVar1 = CONCAT11(bStack_1d,uStack_1e) + 1;
              iVar2 = 0;
              iVar7 = 0;
            }
          }
          else {
            sVar1 = CONCAT11(bStack_1d,uStack_1e);
            iVar2 = CONCAT22(local_20,uStack_22) + 1;
          }
        }
        else {
          iVar7 = CONCAT22(local_24,uStack_26) + 1;
          sVar1 = CONCAT11(bStack_1d,uStack_1e);
          iVar2 = CONCAT22(local_20,uStack_22);
        }
      }
      local_24 = (short)((uint)iVar7 >> 0x10);
      uStack_26 = (undefined2)iVar7;
      local_20 = (undefined2)((uint)iVar2 >> 0x10);
      uStack_22 = (undefined2)iVar2;
      bStack_1d = (byte)((ushort)sVar1 >> 8);
      uStack_1e = (undefined1)sVar1;
      if (0x7ffe < (ushort)param_1) goto LAB_100231f1;
      uVar6 = (ushort)param_1 | uVar9;
      *(undefined2 *)piVar4 = uStack_26;
      *(uint *)((int)piVar4 + 2) = CONCAT22(uStack_22,local_24);
      *(uint *)((int)piVar4 + 6) = CONCAT13(bStack_1d,CONCAT12(uStack_1e,local_20));
    }
    *(ushort *)((int)piVar4 + 10) = uVar6;
  }
  else {
LAB_100231f1:
    piVar4[1] = 0;
    *piVar4 = 0;
    piVar4[2] = (-(uint)(uVar9 != 0) & 0x80000000) + 0x7fff8000;
  }
  return;
}



void float_conversion_15(undefined2 *param_1,uint param_2,int param_3)

{
  uint uVar1;
  uint uVar2;
  undefined **ppuVar3;
  undefined **ppuVar4;
  undefined2 local_10;
  undefined4 local_e;
  undefined2 uStack_a;
  undefined *puStack_8;
  
  ppuVar3 = &PTR_s_November_100342f0;
  if (param_2 != 0) {
    if ((int)param_2 < 0) {
      param_2 = -param_2;
      ppuVar3 = (undefined **)0x10034450;
    }
    if (param_3 == 0) {
      *param_1 = 0;
    }
    while (param_2 != 0) {
      ppuVar3 = ppuVar3 + 0x15;
      uVar1 = (int)param_2 >> 3;
      uVar2 = param_2 & 7;
      param_2 = uVar1;
      if (uVar2 != 0) {
        ppuVar4 = ppuVar3 + uVar2 * 3;
        if (0x7fff < *(ushort *)(ppuVar3 + uVar2 * 3)) {
          local_10 = SUB42(*ppuVar4,0);
          local_e._0_2_ = (undefined2)((uint)*ppuVar4 >> 0x10);
          local_e._2_2_ = SUB42(ppuVar4[1],0);
          uStack_a = (undefined2)((uint)ppuVar4[1] >> 0x10);
          puStack_8 = ppuVar4[2];
          local_e = CONCAT22(local_e._2_2_,(undefined2)local_e) + -1;
          ppuVar4 = (undefined **)&local_10;
        }
        float_conversion_14(param_1,ppuVar4);
      }
    }
  }
  return;
}



int float_conversion_16(LCID param_1,DWORD param_2,byte *param_3,int param_4,byte *param_5,
                       int param_6,UINT param_7)

{
  undefined1 *puVar1;
  int iVar2;
  BOOL BVar3;
  BYTE *pBVar4;
  int iVar5;
  _cpinfo local_40;
  undefined1 *local_2c;
  PCNZWCH local_28;
  int local_24;
  int local_20;
  undefined1 *local_1c;
  void *local_14;
  undefined1 *puStack_10;
  undefined *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &DAT_100265f0;
  puStack_10 = &LAB_1001e7dc;
  local_14 = ExceptionList;
  local_1c = &stack0xffffffb0;
  ExceptionList = &local_14;
  puVar1 = &stack0xffffffb0;
  if (DAT_10035874 == 0) {
    ExceptionList = &local_14;
    iVar2 = CompareStringW(0,0,L"",1,L"",1);
    if (iVar2 == 0) {
      iVar2 = CompareStringA(0,0,"",1,"",1);
      if (iVar2 == 0) {
        ExceptionList = local_14;
        return 0;
      }
      DAT_10035874 = 2;
      puVar1 = local_1c;
    }
    else {
      DAT_10035874 = 1;
      puVar1 = local_1c;
    }
  }
  local_1c = puVar1;
  if (0 < param_4) {
    param_4 = str_to_int_8(param_3,param_4);
  }
  if (0 < param_6) {
    param_6 = str_to_int_8(param_5,param_6);
  }
  if (DAT_10035874 == 2) {
    iVar2 = CompareStringA(param_1,param_2,(PCNZCH)param_3,param_4,(PCNZCH)param_5,param_6);
    ExceptionList = local_14;
    return iVar2;
  }
  if (DAT_10035874 == 1) {
    if (param_7 == 0) {
      param_7 = DAT_100355cc;
    }
    if ((param_4 == 0) || (param_6 == 0)) {
      if (param_4 == param_6) {
        ExceptionList = local_14;
        return 2;
      }
      if (1 < param_6) {
        ExceptionList = local_14;
        return 1;
      }
      if (1 < param_4) {
        ExceptionList = local_14;
        return 3;
      }
      BVar3 = GetCPInfo(param_7,&local_40);
      if (BVar3 == 0) {
        ExceptionList = local_14;
        return 0;
      }
      if (0 < param_4) {
        if (local_40.MaxCharSize < 2) {
          ExceptionList = local_14;
          return 3;
        }
        pBVar4 = local_40.LeadByte;
        while( true ) {
          if (local_40.LeadByte[0] == 0) {
            ExceptionList = local_14;
            return 3;
          }
          if (pBVar4[1] == 0) break;
          if ((*pBVar4 <= *param_3) && (*param_3 <= pBVar4[1])) {
            ExceptionList = local_14;
            return 2;
          }
          pBVar4 = pBVar4 + 2;
          local_40.LeadByte[0] = *pBVar4;
        }
        ExceptionList = local_14;
        return 3;
      }
      if (0 < param_6) {
        if (local_40.MaxCharSize < 2) {
          ExceptionList = local_14;
          return 1;
        }
        pBVar4 = local_40.LeadByte;
        while( true ) {
          if (local_40.LeadByte[0] == 0) {
            ExceptionList = local_14;
            return 1;
          }
          if (pBVar4[1] == 0) break;
          if ((*pBVar4 <= *param_5) && (*param_5 <= pBVar4[1])) {
            ExceptionList = local_14;
            return 2;
          }
          pBVar4 = pBVar4 + 2;
          local_40.LeadByte[0] = *pBVar4;
        }
        ExceptionList = local_14;
        return 1;
      }
    }
    local_20 = MultiByteToWideChar(param_7,9,(LPCSTR)param_3,param_4,(LPWSTR)0x0,0);
    if (local_20 != 0) {
      local_8 = 0;
      memory_management_3();
      local_8 = 0xffffffff;
      if ((&stack0x00000000 != (undefined1 *)0x50) &&
         (local_28 = (PCNZWCH)&stack0xffffffb0, local_1c = &stack0xffffffb0,
         iVar2 = MultiByteToWideChar(param_7,1,(LPCSTR)param_3,param_4,(LPWSTR)&stack0xffffffb0,
                                     local_20), iVar2 != 0)) {
        iVar2 = MultiByteToWideChar(param_7,9,(LPCSTR)param_5,param_6,(LPWSTR)0x0,0);
        if (iVar2 != 0) {
          local_8 = 1;
          local_24 = iVar2;
          memory_management_3();
          local_8 = 0xffffffff;
          if ((&stack0x00000000 != (undefined1 *)0x50) &&
             (local_2c = &stack0xffffffb0, local_1c = &stack0xffffffb0,
             iVar5 = MultiByteToWideChar(param_7,1,(LPCSTR)param_5,param_6,(LPWSTR)&stack0xffffffb0,
                                         iVar2), iVar5 != 0)) {
            iVar2 = CompareStringW(param_1,param_2,local_28,local_20,(PCNZWCH)&stack0xffffffb0,iVar2
                                  );
            ExceptionList = local_14;
            return iVar2;
          }
        }
      }
    }
  }
  ExceptionList = local_14;
  return 0;
}



int str_to_int_8(char *param_1,int param_2)

{
  char *pcVar1;
  int iVar2;
  
  pcVar1 = param_1;
  iVar2 = param_2;
  if (param_2 != 0) {
    do {
      iVar2 = iVar2 + -1;
      if (*pcVar1 == '\0') break;
      pcVar1 = pcVar1 + 1;
    } while (iVar2 != 0);
  }
  if (*pcVar1 == '\0') {
    return (int)pcVar1 - (int)param_1;
  }
  return param_2;
}



undefined4 str_to_int_9(char *param_1,int param_2)

{
  char *pcVar1;
  int iVar2;
  int *piVar3;
  size_t sVar4;
  LPCSTR lpName;
  int *piVar5;
  bool bVar6;
  
  if (param_1 == (char *)0x0) {
    return 0xffffffff;
  }
  pcVar1 = (char *)str_to_int_12(param_1,0x3d);
  if (pcVar1 == (char *)0x0) {
    return 0xffffffff;
  }
  if (param_1 == pcVar1) {
    return 0xffffffff;
  }
  bVar6 = pcVar1[1] == '\0';
  if (DAT_100354d0 == DAT_100354d4) {
    DAT_100354d0 = (int *)str_to_int_11(DAT_100354d0);
  }
  if (DAT_100354d0 == (int *)0x0) {
    if ((param_2 == 0) || (DAT_100354d8 == (undefined4 *)0x0)) {
      if (bVar6) {
        return 0;
      }
      DAT_100354d0 = (int *)_malloc(4);
      if (DAT_100354d0 == (int *)0x0) {
        return 0xffffffff;
      }
      *DAT_100354d0 = 0;
      if (DAT_100354d8 == (undefined4 *)0x0) {
        DAT_100354d8 = (undefined4 *)_malloc(4);
        if (DAT_100354d8 == (undefined4 *)0x0) {
          return 0xffffffff;
        }
        *DAT_100354d8 = 0;
      }
    }
    else {
      iVar2 = env_var_management_14();
      if (iVar2 != 0) {
        return 0xffffffff;
      }
    }
  }
  piVar3 = DAT_100354d0;
  iVar2 = str_to_int_10(param_1,(int)pcVar1 - (int)param_1);
  if ((iVar2 < 0) || (*piVar3 == 0)) {
    if (bVar6) {
      return 0;
    }
    if (iVar2 < 0) {
      iVar2 = -iVar2;
    }
    piVar3 = (int *)realloc_internal(piVar3,iVar2 * 4 + 8);
    if (piVar3 == (int *)0x0) {
      return 0xffffffff;
    }
    piVar3[iVar2] = (int)param_1;
    piVar3[iVar2 + 1] = 0;
  }
  else {
    if (!bVar6) {
      piVar3[iVar2] = (int)param_1;
      goto LAB_10023669;
    }
    piVar5 = piVar3 + iVar2;
    free_memory((void *)piVar3[iVar2]);
    for (; *piVar5 != 0; piVar5 = piVar5 + 1) {
      iVar2 = iVar2 + 1;
      *piVar5 = piVar5[1];
    }
    piVar3 = (int *)realloc_internal(piVar3,iVar2 << 2);
    if (piVar3 == (int *)0x0) goto LAB_10023669;
  }
  DAT_100354d0 = piVar3;
LAB_10023669:
  if (param_2 != 0) {
    sVar4 = _strlen(param_1);
    lpName = (LPCSTR)_malloc(sVar4 + 2);
    if (lpName != (LPCSTR)0x0) {
      strcpy_internal_2(lpName,param_1);
      pcVar1[(int)lpName - (int)param_1] = '\0';
      SetEnvironmentVariableA
                (lpName,(LPCSTR)(~-(uint)bVar6 & (uint)(pcVar1 + ((int)lpName - (int)param_1) + 1)))
      ;
      free_memory(lpName);
    }
  }
  return 0;
}



int str_to_int_10(uchar *param_1,size_t param_2)

{
  uchar *_Str2;
  int iVar1;
  int *piVar2;
  
  _Str2 = (uchar *)*DAT_100354d0;
  piVar2 = DAT_100354d0;
  while( true ) {
    if (_Str2 == (uchar *)0x0) {
      return -((int)piVar2 - (int)DAT_100354d0 >> 2);
    }
    iVar1 = __mbsnbicoll(param_1,_Str2,param_2);
    if ((iVar1 == 0) &&
       ((*(char *)(*piVar2 + param_2) == '=' || (*(char *)(*piVar2 + param_2) == '\0')))) break;
    _Str2 = (uchar *)piVar2[1];
    piVar2 = piVar2 + 1;
  }
  return (int)piVar2 - (int)DAT_100354d0 >> 2;
}



undefined4 * str_to_int_11(int *param_1)

{
  int iVar1;
  int *piVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  int iVar5;
  undefined4 *puVar6;
  
  iVar5 = 0;
  if (param_1 != (int *)0x0) {
    iVar1 = *param_1;
    piVar2 = param_1;
    while (iVar1 != 0) {
      piVar2 = piVar2 + 1;
      iVar5 = iVar5 + 1;
      iVar1 = *piVar2;
    }
    puVar3 = (undefined4 *)_malloc(iVar5 * 4 + 4);
    if (puVar3 == (undefined4 *)0x0) {
      __amsg_exit(9);
    }
    iVar5 = *param_1;
    puVar6 = puVar3;
    while (iVar5 != 0) {
      param_1 = param_1 + 1;
      uVar4 = str_to_int_13(iVar5);
      *puVar6 = uVar4;
      puVar6 = puVar6 + 1;
      iVar5 = *param_1;
    }
    *puVar6 = 0;
    return puVar3;
  }
  return (undefined4 *)0x0;
}



byte * str_to_int_12(byte *param_1,uint param_2)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  
  if (DAT_1176621c == 0) {
    param_1 = (byte *)_strchr((char *)param_1,param_2);
  }
  else {
    lock_resource(0x19);
    while( true ) {
      bVar1 = *param_1;
      uVar2 = (uint)bVar1;
      if (bVar1 == 0) break;
      if (((&DAT_11766321)[uVar2] & 4) == 0) {
        pbVar3 = param_1;
        if (param_2 == uVar2) break;
      }
      else {
        pbVar3 = param_1 + 1;
        if (param_1[1] == 0) {
          unlock_resource(0x19);
          return (byte *)0x0;
        }
        if (param_2 == CONCAT11(bVar1,param_1[1])) {
          unlock_resource(0x19);
          return param_1;
        }
      }
      param_1 = pbVar3 + 1;
    }
    unlock_resource(0x19);
    param_1 = (byte *)(~-(uint)(param_2 != uVar2) & (uint)param_1);
  }
  return param_1;
}



undefined4 str_to_int_13(char *param_1)

{
  size_t sVar1;
  void *pvVar2;
  undefined4 uVar3;
  
  if (param_1 != (char *)0x0) {
    sVar1 = _strlen(param_1);
    pvVar2 = _malloc(sVar1 + 1);
    if (pvVar2 != (void *)0x0) {
      uVar3 = strcpy_internal_2(pvVar2,param_1);
      return uVar3;
    }
  }
  return 0;
}



void RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)

{
                    // WARNING: Could not recover jumptable at 0x10023840. Too many branches
                    // WARNING: Treating indirect jump as call
  RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
  return;
}


